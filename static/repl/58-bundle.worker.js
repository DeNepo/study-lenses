self.webpackChunk([58],{71:function(e,n,t){"use strict";t.r(n),n.default='/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the "License"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\ndeclare namespace ts {\n    const versionMajorMinor = "3.9";\n    /** The version of the TypeScript compiler release */\n    const version: string;\n    /**\n     * Type of objects whose values are all of the same type.\n     * The `in` and `for-in` operators can *not* be safely used,\n     * since `Object.prototype` may be modified by outside code.\n     */\n    interface MapLike<T> {\n        [index: string]: T;\n    }\n    interface SortedReadonlyArray<T> extends ReadonlyArray<T> {\n        " __sortedArrayBrand": any;\n    }\n    interface SortedArray<T> extends Array<T> {\n        " __sortedArrayBrand": any;\n    }\n    /** ES6 Map interface, only read methods included. */\n    interface ReadonlyMap<T> {\n        get(key: string): T | undefined;\n        has(key: string): boolean;\n        forEach(action: (value: T, key: string) => void): void;\n        readonly size: number;\n        keys(): Iterator<string>;\n        values(): Iterator<T>;\n        entries(): Iterator<[string, T]>;\n    }\n    /** ES6 Map interface. */\n    interface Map<T> extends ReadonlyMap<T> {\n        set(key: string, value: T): this;\n        delete(key: string): boolean;\n        clear(): void;\n    }\n    /** ES6 Iterator type. */\n    interface Iterator<T> {\n        next(): {\n            value: T;\n            done?: false;\n        } | {\n            value: never;\n            done: true;\n        };\n    }\n    /** Array that is only intended to be pushed to, never read. */\n    interface Push<T> {\n        push(...values: T[]): void;\n    }\n}\ndeclare namespace ts {\n    export type Path = string & {\n        __pathBrand: any;\n    };\n    export interface TextRange {\n        pos: number;\n        end: number;\n    }\n    export type JSDocSyntaxKind = SyntaxKind.EndOfFileToken | SyntaxKind.WhitespaceTrivia | SyntaxKind.AtToken | SyntaxKind.NewLineTrivia | SyntaxKind.AsteriskToken | SyntaxKind.OpenBraceToken | SyntaxKind.CloseBraceToken | SyntaxKind.LessThanToken | SyntaxKind.GreaterThanToken | SyntaxKind.OpenBracketToken | SyntaxKind.CloseBracketToken | SyntaxKind.EqualsToken | SyntaxKind.CommaToken | SyntaxKind.DotToken | SyntaxKind.Identifier | SyntaxKind.BacktickToken | SyntaxKind.Unknown | KeywordSyntaxKind;\n    export type KeywordSyntaxKind = SyntaxKind.AbstractKeyword | SyntaxKind.AnyKeyword | SyntaxKind.AsKeyword | SyntaxKind.AssertsKeyword | SyntaxKind.BigIntKeyword | SyntaxKind.BooleanKeyword | SyntaxKind.BreakKeyword | SyntaxKind.CaseKeyword | SyntaxKind.CatchKeyword | SyntaxKind.ClassKeyword | SyntaxKind.ContinueKeyword | SyntaxKind.ConstKeyword | SyntaxKind.ConstructorKeyword | SyntaxKind.DebuggerKeyword | SyntaxKind.DeclareKeyword | SyntaxKind.DefaultKeyword | SyntaxKind.DeleteKeyword | SyntaxKind.DoKeyword | SyntaxKind.ElseKeyword | SyntaxKind.EnumKeyword | SyntaxKind.ExportKeyword | SyntaxKind.ExtendsKeyword | SyntaxKind.FalseKeyword | SyntaxKind.FinallyKeyword | SyntaxKind.ForKeyword | SyntaxKind.FromKeyword | SyntaxKind.FunctionKeyword | SyntaxKind.GetKeyword | SyntaxKind.IfKeyword | SyntaxKind.ImplementsKeyword | SyntaxKind.ImportKeyword | SyntaxKind.InKeyword | SyntaxKind.InferKeyword | SyntaxKind.InstanceOfKeyword | SyntaxKind.InterfaceKeyword | SyntaxKind.IsKeyword | SyntaxKind.KeyOfKeyword | SyntaxKind.LetKeyword | SyntaxKind.ModuleKeyword | SyntaxKind.NamespaceKeyword | SyntaxKind.NeverKeyword | SyntaxKind.NewKeyword | SyntaxKind.NullKeyword | SyntaxKind.NumberKeyword | SyntaxKind.ObjectKeyword | SyntaxKind.PackageKeyword | SyntaxKind.PrivateKeyword | SyntaxKind.ProtectedKeyword | SyntaxKind.PublicKeyword | SyntaxKind.ReadonlyKeyword | SyntaxKind.RequireKeyword | SyntaxKind.GlobalKeyword | SyntaxKind.ReturnKeyword | SyntaxKind.SetKeyword | SyntaxKind.StaticKeyword | SyntaxKind.StringKeyword | SyntaxKind.SuperKeyword | SyntaxKind.SwitchKeyword | SyntaxKind.SymbolKeyword | SyntaxKind.ThisKeyword | SyntaxKind.ThrowKeyword | SyntaxKind.TrueKeyword | SyntaxKind.TryKeyword | SyntaxKind.TypeKeyword | SyntaxKind.TypeOfKeyword | SyntaxKind.UndefinedKeyword | SyntaxKind.UniqueKeyword | SyntaxKind.UnknownKeyword | SyntaxKind.VarKeyword | SyntaxKind.VoidKeyword | SyntaxKind.WhileKeyword | SyntaxKind.WithKeyword | SyntaxKind.YieldKeyword | SyntaxKind.AsyncKeyword | SyntaxKind.AwaitKeyword | SyntaxKind.OfKeyword;\n    export type JsxTokenSyntaxKind = SyntaxKind.LessThanSlashToken | SyntaxKind.EndOfFileToken | SyntaxKind.ConflictMarkerTrivia | SyntaxKind.JsxText | SyntaxKind.JsxTextAllWhiteSpaces | SyntaxKind.OpenBraceToken | SyntaxKind.LessThanToken;\n    export enum SyntaxKind {\n        Unknown = 0,\n        EndOfFileToken = 1,\n        SingleLineCommentTrivia = 2,\n        MultiLineCommentTrivia = 3,\n        NewLineTrivia = 4,\n        WhitespaceTrivia = 5,\n        ShebangTrivia = 6,\n        ConflictMarkerTrivia = 7,\n        NumericLiteral = 8,\n        BigIntLiteral = 9,\n        StringLiteral = 10,\n        JsxText = 11,\n        JsxTextAllWhiteSpaces = 12,\n        RegularExpressionLiteral = 13,\n        NoSubstitutionTemplateLiteral = 14,\n        TemplateHead = 15,\n        TemplateMiddle = 16,\n        TemplateTail = 17,\n        OpenBraceToken = 18,\n        CloseBraceToken = 19,\n        OpenParenToken = 20,\n        CloseParenToken = 21,\n        OpenBracketToken = 22,\n        CloseBracketToken = 23,\n        DotToken = 24,\n        DotDotDotToken = 25,\n        SemicolonToken = 26,\n        CommaToken = 27,\n        QuestionDotToken = 28,\n        LessThanToken = 29,\n        LessThanSlashToken = 30,\n        GreaterThanToken = 31,\n        LessThanEqualsToken = 32,\n        GreaterThanEqualsToken = 33,\n        EqualsEqualsToken = 34,\n        ExclamationEqualsToken = 35,\n        EqualsEqualsEqualsToken = 36,\n        ExclamationEqualsEqualsToken = 37,\n        EqualsGreaterThanToken = 38,\n        PlusToken = 39,\n        MinusToken = 40,\n        AsteriskToken = 41,\n        AsteriskAsteriskToken = 42,\n        SlashToken = 43,\n        PercentToken = 44,\n        PlusPlusToken = 45,\n        MinusMinusToken = 46,\n        LessThanLessThanToken = 47,\n        GreaterThanGreaterThanToken = 48,\n        GreaterThanGreaterThanGreaterThanToken = 49,\n        AmpersandToken = 50,\n        BarToken = 51,\n        CaretToken = 52,\n        ExclamationToken = 53,\n        TildeToken = 54,\n        AmpersandAmpersandToken = 55,\n        BarBarToken = 56,\n        QuestionToken = 57,\n        ColonToken = 58,\n        AtToken = 59,\n        QuestionQuestionToken = 60,\n        /** Only the JSDoc scanner produces BacktickToken. The normal scanner produces NoSubstitutionTemplateLiteral and related kinds. */\n        BacktickToken = 61,\n        EqualsToken = 62,\n        PlusEqualsToken = 63,\n        MinusEqualsToken = 64,\n        AsteriskEqualsToken = 65,\n        AsteriskAsteriskEqualsToken = 66,\n        SlashEqualsToken = 67,\n        PercentEqualsToken = 68,\n        LessThanLessThanEqualsToken = 69,\n        GreaterThanGreaterThanEqualsToken = 70,\n        GreaterThanGreaterThanGreaterThanEqualsToken = 71,\n        AmpersandEqualsToken = 72,\n        BarEqualsToken = 73,\n        CaretEqualsToken = 74,\n        Identifier = 75,\n        PrivateIdentifier = 76,\n        BreakKeyword = 77,\n        CaseKeyword = 78,\n        CatchKeyword = 79,\n        ClassKeyword = 80,\n        ConstKeyword = 81,\n        ContinueKeyword = 82,\n        DebuggerKeyword = 83,\n        DefaultKeyword = 84,\n        DeleteKeyword = 85,\n        DoKeyword = 86,\n        ElseKeyword = 87,\n        EnumKeyword = 88,\n        ExportKeyword = 89,\n        ExtendsKeyword = 90,\n        FalseKeyword = 91,\n        FinallyKeyword = 92,\n        ForKeyword = 93,\n        FunctionKeyword = 94,\n        IfKeyword = 95,\n        ImportKeyword = 96,\n        InKeyword = 97,\n        InstanceOfKeyword = 98,\n        NewKeyword = 99,\n        NullKeyword = 100,\n        ReturnKeyword = 101,\n        SuperKeyword = 102,\n        SwitchKeyword = 103,\n        ThisKeyword = 104,\n        ThrowKeyword = 105,\n        TrueKeyword = 106,\n        TryKeyword = 107,\n        TypeOfKeyword = 108,\n        VarKeyword = 109,\n        VoidKeyword = 110,\n        WhileKeyword = 111,\n        WithKeyword = 112,\n        ImplementsKeyword = 113,\n        InterfaceKeyword = 114,\n        LetKeyword = 115,\n        PackageKeyword = 116,\n        PrivateKeyword = 117,\n        ProtectedKeyword = 118,\n        PublicKeyword = 119,\n        StaticKeyword = 120,\n        YieldKeyword = 121,\n        AbstractKeyword = 122,\n        AsKeyword = 123,\n        AssertsKeyword = 124,\n        AnyKeyword = 125,\n        AsyncKeyword = 126,\n        AwaitKeyword = 127,\n        BooleanKeyword = 128,\n        ConstructorKeyword = 129,\n        DeclareKeyword = 130,\n        GetKeyword = 131,\n        InferKeyword = 132,\n        IsKeyword = 133,\n        KeyOfKeyword = 134,\n        ModuleKeyword = 135,\n        NamespaceKeyword = 136,\n        NeverKeyword = 137,\n        ReadonlyKeyword = 138,\n        RequireKeyword = 139,\n        NumberKeyword = 140,\n        ObjectKeyword = 141,\n        SetKeyword = 142,\n        StringKeyword = 143,\n        SymbolKeyword = 144,\n        TypeKeyword = 145,\n        UndefinedKeyword = 146,\n        UniqueKeyword = 147,\n        UnknownKeyword = 148,\n        FromKeyword = 149,\n        GlobalKeyword = 150,\n        BigIntKeyword = 151,\n        OfKeyword = 152,\n        QualifiedName = 153,\n        ComputedPropertyName = 154,\n        TypeParameter = 155,\n        Parameter = 156,\n        Decorator = 157,\n        PropertySignature = 158,\n        PropertyDeclaration = 159,\n        MethodSignature = 160,\n        MethodDeclaration = 161,\n        Constructor = 162,\n        GetAccessor = 163,\n        SetAccessor = 164,\n        CallSignature = 165,\n        ConstructSignature = 166,\n        IndexSignature = 167,\n        TypePredicate = 168,\n        TypeReference = 169,\n        FunctionType = 170,\n        ConstructorType = 171,\n        TypeQuery = 172,\n        TypeLiteral = 173,\n        ArrayType = 174,\n        TupleType = 175,\n        OptionalType = 176,\n        RestType = 177,\n        UnionType = 178,\n        IntersectionType = 179,\n        ConditionalType = 180,\n        InferType = 181,\n        ParenthesizedType = 182,\n        ThisType = 183,\n        TypeOperator = 184,\n        IndexedAccessType = 185,\n        MappedType = 186,\n        LiteralType = 187,\n        ImportType = 188,\n        ObjectBindingPattern = 189,\n        ArrayBindingPattern = 190,\n        BindingElement = 191,\n        ArrayLiteralExpression = 192,\n        ObjectLiteralExpression = 193,\n        PropertyAccessExpression = 194,\n        ElementAccessExpression = 195,\n        CallExpression = 196,\n        NewExpression = 197,\n        TaggedTemplateExpression = 198,\n        TypeAssertionExpression = 199,\n        ParenthesizedExpression = 200,\n        FunctionExpression = 201,\n        ArrowFunction = 202,\n        DeleteExpression = 203,\n        TypeOfExpression = 204,\n        VoidExpression = 205,\n        AwaitExpression = 206,\n        PrefixUnaryExpression = 207,\n        PostfixUnaryExpression = 208,\n        BinaryExpression = 209,\n        ConditionalExpression = 210,\n        TemplateExpression = 211,\n        YieldExpression = 212,\n        SpreadElement = 213,\n        ClassExpression = 214,\n        OmittedExpression = 215,\n        ExpressionWithTypeArguments = 216,\n        AsExpression = 217,\n        NonNullExpression = 218,\n        MetaProperty = 219,\n        SyntheticExpression = 220,\n        TemplateSpan = 221,\n        SemicolonClassElement = 222,\n        Block = 223,\n        EmptyStatement = 224,\n        VariableStatement = 225,\n        ExpressionStatement = 226,\n        IfStatement = 227,\n        DoStatement = 228,\n        WhileStatement = 229,\n        ForStatement = 230,\n        ForInStatement = 231,\n        ForOfStatement = 232,\n        ContinueStatement = 233,\n        BreakStatement = 234,\n        ReturnStatement = 235,\n        WithStatement = 236,\n        SwitchStatement = 237,\n        LabeledStatement = 238,\n        ThrowStatement = 239,\n        TryStatement = 240,\n        DebuggerStatement = 241,\n        VariableDeclaration = 242,\n        VariableDeclarationList = 243,\n        FunctionDeclaration = 244,\n        ClassDeclaration = 245,\n        InterfaceDeclaration = 246,\n        TypeAliasDeclaration = 247,\n        EnumDeclaration = 248,\n        ModuleDeclaration = 249,\n        ModuleBlock = 250,\n        CaseBlock = 251,\n        NamespaceExportDeclaration = 252,\n        ImportEqualsDeclaration = 253,\n        ImportDeclaration = 254,\n        ImportClause = 255,\n        NamespaceImport = 256,\n        NamedImports = 257,\n        ImportSpecifier = 258,\n        ExportAssignment = 259,\n        ExportDeclaration = 260,\n        NamedExports = 261,\n        NamespaceExport = 262,\n        ExportSpecifier = 263,\n        MissingDeclaration = 264,\n        ExternalModuleReference = 265,\n        JsxElement = 266,\n        JsxSelfClosingElement = 267,\n        JsxOpeningElement = 268,\n        JsxClosingElement = 269,\n        JsxFragment = 270,\n        JsxOpeningFragment = 271,\n        JsxClosingFragment = 272,\n        JsxAttribute = 273,\n        JsxAttributes = 274,\n        JsxSpreadAttribute = 275,\n        JsxExpression = 276,\n        CaseClause = 277,\n        DefaultClause = 278,\n        HeritageClause = 279,\n        CatchClause = 280,\n        PropertyAssignment = 281,\n        ShorthandPropertyAssignment = 282,\n        SpreadAssignment = 283,\n        EnumMember = 284,\n        UnparsedPrologue = 285,\n        UnparsedPrepend = 286,\n        UnparsedText = 287,\n        UnparsedInternalText = 288,\n        UnparsedSyntheticReference = 289,\n        SourceFile = 290,\n        Bundle = 291,\n        UnparsedSource = 292,\n        InputFiles = 293,\n        JSDocTypeExpression = 294,\n        JSDocAllType = 295,\n        JSDocUnknownType = 296,\n        JSDocNullableType = 297,\n        JSDocNonNullableType = 298,\n        JSDocOptionalType = 299,\n        JSDocFunctionType = 300,\n        JSDocVariadicType = 301,\n        JSDocNamepathType = 302,\n        JSDocComment = 303,\n        JSDocTypeLiteral = 304,\n        JSDocSignature = 305,\n        JSDocTag = 306,\n        JSDocAugmentsTag = 307,\n        JSDocImplementsTag = 308,\n        JSDocAuthorTag = 309,\n        JSDocClassTag = 310,\n        JSDocPublicTag = 311,\n        JSDocPrivateTag = 312,\n        JSDocProtectedTag = 313,\n        JSDocReadonlyTag = 314,\n        JSDocCallbackTag = 315,\n        JSDocEnumTag = 316,\n        JSDocParameterTag = 317,\n        JSDocReturnTag = 318,\n        JSDocThisTag = 319,\n        JSDocTypeTag = 320,\n        JSDocTemplateTag = 321,\n        JSDocTypedefTag = 322,\n        JSDocPropertyTag = 323,\n        SyntaxList = 324,\n        NotEmittedStatement = 325,\n        PartiallyEmittedExpression = 326,\n        CommaListExpression = 327,\n        MergeDeclarationMarker = 328,\n        EndOfDeclarationMarker = 329,\n        SyntheticReferenceExpression = 330,\n        Count = 331,\n        FirstAssignment = 62,\n        LastAssignment = 74,\n        FirstCompoundAssignment = 63,\n        LastCompoundAssignment = 74,\n        FirstReservedWord = 77,\n        LastReservedWord = 112,\n        FirstKeyword = 77,\n        LastKeyword = 152,\n        FirstFutureReservedWord = 113,\n        LastFutureReservedWord = 121,\n        FirstTypeNode = 168,\n        LastTypeNode = 188,\n        FirstPunctuation = 18,\n        LastPunctuation = 74,\n        FirstToken = 0,\n        LastToken = 152,\n        FirstTriviaToken = 2,\n        LastTriviaToken = 7,\n        FirstLiteralToken = 8,\n        LastLiteralToken = 14,\n        FirstTemplateToken = 14,\n        LastTemplateToken = 17,\n        FirstBinaryOperator = 29,\n        LastBinaryOperator = 74,\n        FirstStatement = 225,\n        LastStatement = 241,\n        FirstNode = 153,\n        FirstJSDocNode = 294,\n        LastJSDocNode = 323,\n        FirstJSDocTagNode = 306,\n        LastJSDocTagNode = 323,\n    }\n    export enum NodeFlags {\n        None = 0,\n        Let = 1,\n        Const = 2,\n        NestedNamespace = 4,\n        Synthesized = 8,\n        Namespace = 16,\n        OptionalChain = 32,\n        ExportContext = 64,\n        ContainsThis = 128,\n        HasImplicitReturn = 256,\n        HasExplicitReturn = 512,\n        GlobalAugmentation = 1024,\n        HasAsyncFunctions = 2048,\n        DisallowInContext = 4096,\n        YieldContext = 8192,\n        DecoratorContext = 16384,\n        AwaitContext = 32768,\n        ThisNodeHasError = 65536,\n        JavaScriptFile = 131072,\n        ThisNodeOrAnySubNodesHasError = 262144,\n        HasAggregatedChildData = 524288,\n        JSDoc = 4194304,\n        JsonFile = 33554432,\n        BlockScoped = 3,\n        ReachabilityCheckFlags = 768,\n        ReachabilityAndEmitFlags = 2816,\n        ContextFlags = 25358336,\n        TypeExcludesFlags = 40960,\n    }\n    export enum ModifierFlags {\n        None = 0,\n        Export = 1,\n        Ambient = 2,\n        Public = 4,\n        Private = 8,\n        Protected = 16,\n        Static = 32,\n        Readonly = 64,\n        Abstract = 128,\n        Async = 256,\n        Default = 512,\n        Const = 2048,\n        HasComputedFlags = 536870912,\n        AccessibilityModifier = 28,\n        ParameterPropertyModifier = 92,\n        NonPublicAccessibilityModifier = 24,\n        TypeScriptModifier = 2270,\n        ExportDefault = 513,\n        All = 3071\n    }\n    export enum JsxFlags {\n        None = 0,\n        /** An element from a named property of the JSX.IntrinsicElements interface */\n        IntrinsicNamedElement = 1,\n        /** An element inferred from the string index signature of the JSX.IntrinsicElements interface */\n        IntrinsicIndexedElement = 2,\n        IntrinsicElement = 3\n    }\n    export interface Node extends TextRange {\n        kind: SyntaxKind;\n        flags: NodeFlags;\n        decorators?: NodeArray<Decorator>;\n        modifiers?: ModifiersArray;\n        parent: Node;\n    }\n    export interface JSDocContainer {\n    }\n    export type HasJSDoc = ParameterDeclaration | CallSignatureDeclaration | ConstructSignatureDeclaration | MethodSignature | PropertySignature | ArrowFunction | ParenthesizedExpression | SpreadAssignment | ShorthandPropertyAssignment | PropertyAssignment | FunctionExpression | LabeledStatement | ExpressionStatement | VariableStatement | FunctionDeclaration | ConstructorDeclaration | MethodDeclaration | PropertyDeclaration | AccessorDeclaration | ClassLikeDeclaration | InterfaceDeclaration | TypeAliasDeclaration | EnumMember | EnumDeclaration | ModuleDeclaration | ImportEqualsDeclaration | IndexSignatureDeclaration | FunctionTypeNode | ConstructorTypeNode | JSDocFunctionType | ExportDeclaration | EndOfFileToken;\n    export type HasType = SignatureDeclaration | VariableDeclaration | ParameterDeclaration | PropertySignature | PropertyDeclaration | TypePredicateNode | ParenthesizedTypeNode | TypeOperatorNode | MappedTypeNode | AssertionExpression | TypeAliasDeclaration | JSDocTypeExpression | JSDocNonNullableType | JSDocNullableType | JSDocOptionalType | JSDocVariadicType;\n    export type HasTypeArguments = CallExpression | NewExpression | TaggedTemplateExpression | JsxOpeningElement | JsxSelfClosingElement;\n    export type HasInitializer = HasExpressionInitializer | ForStatement | ForInStatement | ForOfStatement | JsxAttribute;\n    export type HasExpressionInitializer = VariableDeclaration | ParameterDeclaration | BindingElement | PropertySignature | PropertyDeclaration | PropertyAssignment | EnumMember;\n    export interface NodeArray<T extends Node> extends ReadonlyArray<T>, TextRange {\n        hasTrailingComma?: boolean;\n    }\n    export interface Token<TKind extends SyntaxKind> extends Node {\n        kind: TKind;\n    }\n    export type DotToken = Token<SyntaxKind.DotToken>;\n    export type DotDotDotToken = Token<SyntaxKind.DotDotDotToken>;\n    export type QuestionToken = Token<SyntaxKind.QuestionToken>;\n    export type QuestionDotToken = Token<SyntaxKind.QuestionDotToken>;\n    export type ExclamationToken = Token<SyntaxKind.ExclamationToken>;\n    export type ColonToken = Token<SyntaxKind.ColonToken>;\n    export type EqualsToken = Token<SyntaxKind.EqualsToken>;\n    export type AsteriskToken = Token<SyntaxKind.AsteriskToken>;\n    export type EqualsGreaterThanToken = Token<SyntaxKind.EqualsGreaterThanToken>;\n    export type EndOfFileToken = Token<SyntaxKind.EndOfFileToken> & JSDocContainer;\n    export type ReadonlyToken = Token<SyntaxKind.ReadonlyKeyword>;\n    export type AwaitKeywordToken = Token<SyntaxKind.AwaitKeyword>;\n    export type PlusToken = Token<SyntaxKind.PlusToken>;\n    export type MinusToken = Token<SyntaxKind.MinusToken>;\n    export type AssertsToken = Token<SyntaxKind.AssertsKeyword>;\n    export type Modifier = Token<SyntaxKind.AbstractKeyword> | Token<SyntaxKind.AsyncKeyword> | Token<SyntaxKind.ConstKeyword> | Token<SyntaxKind.DeclareKeyword> | Token<SyntaxKind.DefaultKeyword> | Token<SyntaxKind.ExportKeyword> | Token<SyntaxKind.PublicKeyword> | Token<SyntaxKind.PrivateKeyword> | Token<SyntaxKind.ProtectedKeyword> | Token<SyntaxKind.ReadonlyKeyword> | Token<SyntaxKind.StaticKeyword>;\n    export type ModifiersArray = NodeArray<Modifier>;\n    export interface Identifier extends PrimaryExpression, Declaration {\n        kind: SyntaxKind.Identifier;\n        /**\n         * Prefer to use `id.unescapedText`. (Note: This is available only in services, not internally to the TypeScript compiler.)\n         * Text of identifier, but if the identifier begins with two underscores, this will begin with three.\n         */\n        escapedText: __String;\n        originalKeywordKind?: SyntaxKind;\n        isInJSDocNamespace?: boolean;\n    }\n    export interface TransientIdentifier extends Identifier {\n        resolvedSymbol: Symbol;\n    }\n    export interface QualifiedName extends Node {\n        kind: SyntaxKind.QualifiedName;\n        left: EntityName;\n        right: Identifier;\n    }\n    export type EntityName = Identifier | QualifiedName;\n    export type PropertyName = Identifier | StringLiteral | NumericLiteral | ComputedPropertyName | PrivateIdentifier;\n    export type DeclarationName = Identifier | PrivateIdentifier | StringLiteralLike | NumericLiteral | ComputedPropertyName | ElementAccessExpression | BindingPattern | EntityNameExpression;\n    export interface Declaration extends Node {\n        _declarationBrand: any;\n    }\n    export interface NamedDeclaration extends Declaration {\n        name?: DeclarationName;\n    }\n    export interface DeclarationStatement extends NamedDeclaration, Statement {\n        name?: Identifier | StringLiteral | NumericLiteral;\n    }\n    export interface ComputedPropertyName extends Node {\n        parent: Declaration;\n        kind: SyntaxKind.ComputedPropertyName;\n        expression: Expression;\n    }\n    export interface PrivateIdentifier extends Node {\n        kind: SyntaxKind.PrivateIdentifier;\n        escapedText: __String;\n    }\n    export interface Decorator extends Node {\n        kind: SyntaxKind.Decorator;\n        parent: NamedDeclaration;\n        expression: LeftHandSideExpression;\n    }\n    export interface TypeParameterDeclaration extends NamedDeclaration {\n        kind: SyntaxKind.TypeParameter;\n        parent: DeclarationWithTypeParameterChildren | InferTypeNode;\n        name: Identifier;\n        /** Note: Consider calling `getEffectiveConstraintOfTypeParameter` */\n        constraint?: TypeNode;\n        default?: TypeNode;\n        expression?: Expression;\n    }\n    export interface SignatureDeclarationBase extends NamedDeclaration, JSDocContainer {\n        kind: SignatureDeclaration["kind"];\n        name?: PropertyName;\n        typeParameters?: NodeArray<TypeParameterDeclaration>;\n        parameters: NodeArray<ParameterDeclaration>;\n        type?: TypeNode;\n    }\n    export type SignatureDeclaration = CallSignatureDeclaration | ConstructSignatureDeclaration | MethodSignature | IndexSignatureDeclaration | FunctionTypeNode | ConstructorTypeNode | JSDocFunctionType | FunctionDeclaration | MethodDeclaration | ConstructorDeclaration | AccessorDeclaration | FunctionExpression | ArrowFunction;\n    export interface CallSignatureDeclaration extends SignatureDeclarationBase, TypeElement {\n        kind: SyntaxKind.CallSignature;\n    }\n    export interface ConstructSignatureDeclaration extends SignatureDeclarationBase, TypeElement {\n        kind: SyntaxKind.ConstructSignature;\n    }\n    export type BindingName = Identifier | BindingPattern;\n    export interface VariableDeclaration extends NamedDeclaration {\n        kind: SyntaxKind.VariableDeclaration;\n        parent: VariableDeclarationList | CatchClause;\n        name: BindingName;\n        exclamationToken?: ExclamationToken;\n        type?: TypeNode;\n        initializer?: Expression;\n    }\n    export interface VariableDeclarationList extends Node {\n        kind: SyntaxKind.VariableDeclarationList;\n        parent: VariableStatement | ForStatement | ForOfStatement | ForInStatement;\n        declarations: NodeArray<VariableDeclaration>;\n    }\n    export interface ParameterDeclaration extends NamedDeclaration, JSDocContainer {\n        kind: SyntaxKind.Parameter;\n        parent: SignatureDeclaration;\n        dotDotDotToken?: DotDotDotToken;\n        name: BindingName;\n        questionToken?: QuestionToken;\n        type?: TypeNode;\n        initializer?: Expression;\n    }\n    export interface BindingElement extends NamedDeclaration {\n        kind: SyntaxKind.BindingElement;\n        parent: BindingPattern;\n        propertyName?: PropertyName;\n        dotDotDotToken?: DotDotDotToken;\n        name: BindingName;\n        initializer?: Expression;\n    }\n    export interface PropertySignature extends TypeElement, JSDocContainer {\n        kind: SyntaxKind.PropertySignature;\n        name: PropertyName;\n        questionToken?: QuestionToken;\n        type?: TypeNode;\n        initializer?: Expression;\n    }\n    export interface PropertyDeclaration extends ClassElement, JSDocContainer {\n        kind: SyntaxKind.PropertyDeclaration;\n        parent: ClassLikeDeclaration;\n        name: PropertyName;\n        questionToken?: QuestionToken;\n        exclamationToken?: ExclamationToken;\n        type?: TypeNode;\n        initializer?: Expression;\n    }\n    export interface ObjectLiteralElement extends NamedDeclaration {\n        _objectLiteralBrand: any;\n        name?: PropertyName;\n    }\n    /** Unlike ObjectLiteralElement, excludes JSXAttribute and JSXSpreadAttribute. */\n    export type ObjectLiteralElementLike = PropertyAssignment | ShorthandPropertyAssignment | SpreadAssignment | MethodDeclaration | AccessorDeclaration;\n    export interface PropertyAssignment extends ObjectLiteralElement, JSDocContainer {\n        parent: ObjectLiteralExpression;\n        kind: SyntaxKind.PropertyAssignment;\n        name: PropertyName;\n        questionToken?: QuestionToken;\n        initializer: Expression;\n    }\n    export interface ShorthandPropertyAssignment extends ObjectLiteralElement, JSDocContainer {\n        parent: ObjectLiteralExpression;\n        kind: SyntaxKind.ShorthandPropertyAssignment;\n        name: Identifier;\n        questionToken?: QuestionToken;\n        exclamationToken?: ExclamationToken;\n        equalsToken?: Token<SyntaxKind.EqualsToken>;\n        objectAssignmentInitializer?: Expression;\n    }\n    export interface SpreadAssignment extends ObjectLiteralElement, JSDocContainer {\n        parent: ObjectLiteralExpression;\n        kind: SyntaxKind.SpreadAssignment;\n        expression: Expression;\n    }\n    export type VariableLikeDeclaration = VariableDeclaration | ParameterDeclaration | BindingElement | PropertyDeclaration | PropertyAssignment | PropertySignature | JsxAttribute | ShorthandPropertyAssignment | EnumMember | JSDocPropertyTag | JSDocParameterTag;\n    export interface PropertyLikeDeclaration extends NamedDeclaration {\n        name: PropertyName;\n    }\n    export interface ObjectBindingPattern extends Node {\n        kind: SyntaxKind.ObjectBindingPattern;\n        parent: VariableDeclaration | ParameterDeclaration | BindingElement;\n        elements: NodeArray<BindingElement>;\n    }\n    export interface ArrayBindingPattern extends Node {\n        kind: SyntaxKind.ArrayBindingPattern;\n        parent: VariableDeclaration | ParameterDeclaration | BindingElement;\n        elements: NodeArray<ArrayBindingElement>;\n    }\n    export type BindingPattern = ObjectBindingPattern | ArrayBindingPattern;\n    export type ArrayBindingElement = BindingElement | OmittedExpression;\n    /**\n     * Several node kinds share function-like features such as a signature,\n     * a name, and a body. These nodes should extend FunctionLikeDeclarationBase.\n     * Examples:\n     * - FunctionDeclaration\n     * - MethodDeclaration\n     * - AccessorDeclaration\n     */\n    export interface FunctionLikeDeclarationBase extends SignatureDeclarationBase {\n        _functionLikeDeclarationBrand: any;\n        asteriskToken?: AsteriskToken;\n        questionToken?: QuestionToken;\n        exclamationToken?: ExclamationToken;\n        body?: Block | Expression;\n    }\n    export type FunctionLikeDeclaration = FunctionDeclaration | MethodDeclaration | GetAccessorDeclaration | SetAccessorDeclaration | ConstructorDeclaration | FunctionExpression | ArrowFunction;\n    /** @deprecated Use SignatureDeclaration */\n    export type FunctionLike = SignatureDeclaration;\n    export interface FunctionDeclaration extends FunctionLikeDeclarationBase, DeclarationStatement {\n        kind: SyntaxKind.FunctionDeclaration;\n        name?: Identifier;\n        body?: FunctionBody;\n    }\n    export interface MethodSignature extends SignatureDeclarationBase, TypeElement {\n        kind: SyntaxKind.MethodSignature;\n        parent: ObjectTypeDeclaration;\n        name: PropertyName;\n    }\n    export interface MethodDeclaration extends FunctionLikeDeclarationBase, ClassElement, ObjectLiteralElement, JSDocContainer {\n        kind: SyntaxKind.MethodDeclaration;\n        parent: ClassLikeDeclaration | ObjectLiteralExpression;\n        name: PropertyName;\n        body?: FunctionBody;\n    }\n    export interface ConstructorDeclaration extends FunctionLikeDeclarationBase, ClassElement, JSDocContainer {\n        kind: SyntaxKind.Constructor;\n        parent: ClassLikeDeclaration;\n        body?: FunctionBody;\n    }\n    /** For when we encounter a semicolon in a class declaration. ES6 allows these as class elements. */\n    export interface SemicolonClassElement extends ClassElement {\n        kind: SyntaxKind.SemicolonClassElement;\n        parent: ClassLikeDeclaration;\n    }\n    export interface GetAccessorDeclaration extends FunctionLikeDeclarationBase, ClassElement, ObjectLiteralElement, JSDocContainer {\n        kind: SyntaxKind.GetAccessor;\n        parent: ClassLikeDeclaration | ObjectLiteralExpression;\n        name: PropertyName;\n        body?: FunctionBody;\n    }\n    export interface SetAccessorDeclaration extends FunctionLikeDeclarationBase, ClassElement, ObjectLiteralElement, JSDocContainer {\n        kind: SyntaxKind.SetAccessor;\n        parent: ClassLikeDeclaration | ObjectLiteralExpression;\n        name: PropertyName;\n        body?: FunctionBody;\n    }\n    export type AccessorDeclaration = GetAccessorDeclaration | SetAccessorDeclaration;\n    export interface IndexSignatureDeclaration extends SignatureDeclarationBase, ClassElement, TypeElement {\n        kind: SyntaxKind.IndexSignature;\n        parent: ObjectTypeDeclaration;\n    }\n    export interface TypeNode extends Node {\n        _typeNodeBrand: any;\n    }\n    export interface KeywordTypeNode extends TypeNode {\n        kind: SyntaxKind.AnyKeyword | SyntaxKind.UnknownKeyword | SyntaxKind.NumberKeyword | SyntaxKind.BigIntKeyword | SyntaxKind.ObjectKeyword | SyntaxKind.BooleanKeyword | SyntaxKind.StringKeyword | SyntaxKind.SymbolKeyword | SyntaxKind.ThisKeyword | SyntaxKind.VoidKeyword | SyntaxKind.UndefinedKeyword | SyntaxKind.NullKeyword | SyntaxKind.NeverKeyword;\n    }\n    export interface ImportTypeNode extends NodeWithTypeArguments {\n        kind: SyntaxKind.ImportType;\n        isTypeOf?: boolean;\n        argument: TypeNode;\n        qualifier?: EntityName;\n    }\n    export interface ThisTypeNode extends TypeNode {\n        kind: SyntaxKind.ThisType;\n    }\n    export type FunctionOrConstructorTypeNode = FunctionTypeNode | ConstructorTypeNode;\n    export interface FunctionOrConstructorTypeNodeBase extends TypeNode, SignatureDeclarationBase {\n        kind: SyntaxKind.FunctionType | SyntaxKind.ConstructorType;\n        type: TypeNode;\n    }\n    export interface FunctionTypeNode extends FunctionOrConstructorTypeNodeBase {\n        kind: SyntaxKind.FunctionType;\n    }\n    export interface ConstructorTypeNode extends FunctionOrConstructorTypeNodeBase {\n        kind: SyntaxKind.ConstructorType;\n    }\n    export interface NodeWithTypeArguments extends TypeNode {\n        typeArguments?: NodeArray<TypeNode>;\n    }\n    export type TypeReferenceType = TypeReferenceNode | ExpressionWithTypeArguments;\n    export interface TypeReferenceNode extends NodeWithTypeArguments {\n        kind: SyntaxKind.TypeReference;\n        typeName: EntityName;\n    }\n    export interface TypePredicateNode extends TypeNode {\n        kind: SyntaxKind.TypePredicate;\n        parent: SignatureDeclaration | JSDocTypeExpression;\n        assertsModifier?: AssertsToken;\n        parameterName: Identifier | ThisTypeNode;\n        type?: TypeNode;\n    }\n    export interface TypeQueryNode extends TypeNode {\n        kind: SyntaxKind.TypeQuery;\n        exprName: EntityName;\n    }\n    export interface TypeLiteralNode extends TypeNode, Declaration {\n        kind: SyntaxKind.TypeLiteral;\n        members: NodeArray<TypeElement>;\n    }\n    export interface ArrayTypeNode extends TypeNode {\n        kind: SyntaxKind.ArrayType;\n        elementType: TypeNode;\n    }\n    export interface TupleTypeNode extends TypeNode {\n        kind: SyntaxKind.TupleType;\n        elementTypes: NodeArray<TypeNode>;\n    }\n    export interface OptionalTypeNode extends TypeNode {\n        kind: SyntaxKind.OptionalType;\n        type: TypeNode;\n    }\n    export interface RestTypeNode extends TypeNode {\n        kind: SyntaxKind.RestType;\n        type: TypeNode;\n    }\n    export type UnionOrIntersectionTypeNode = UnionTypeNode | IntersectionTypeNode;\n    export interface UnionTypeNode extends TypeNode {\n        kind: SyntaxKind.UnionType;\n        types: NodeArray<TypeNode>;\n    }\n    export interface IntersectionTypeNode extends TypeNode {\n        kind: SyntaxKind.IntersectionType;\n        types: NodeArray<TypeNode>;\n    }\n    export interface ConditionalTypeNode extends TypeNode {\n        kind: SyntaxKind.ConditionalType;\n        checkType: TypeNode;\n        extendsType: TypeNode;\n        trueType: TypeNode;\n        falseType: TypeNode;\n    }\n    export interface InferTypeNode extends TypeNode {\n        kind: SyntaxKind.InferType;\n        typeParameter: TypeParameterDeclaration;\n    }\n    export interface ParenthesizedTypeNode extends TypeNode {\n        kind: SyntaxKind.ParenthesizedType;\n        type: TypeNode;\n    }\n    export interface TypeOperatorNode extends TypeNode {\n        kind: SyntaxKind.TypeOperator;\n        operator: SyntaxKind.KeyOfKeyword | SyntaxKind.UniqueKeyword | SyntaxKind.ReadonlyKeyword;\n        type: TypeNode;\n    }\n    export interface IndexedAccessTypeNode extends TypeNode {\n        kind: SyntaxKind.IndexedAccessType;\n        objectType: TypeNode;\n        indexType: TypeNode;\n    }\n    export interface MappedTypeNode extends TypeNode, Declaration {\n        kind: SyntaxKind.MappedType;\n        readonlyToken?: ReadonlyToken | PlusToken | MinusToken;\n        typeParameter: TypeParameterDeclaration;\n        questionToken?: QuestionToken | PlusToken | MinusToken;\n        type?: TypeNode;\n    }\n    export interface LiteralTypeNode extends TypeNode {\n        kind: SyntaxKind.LiteralType;\n        literal: BooleanLiteral | LiteralExpression | PrefixUnaryExpression;\n    }\n    export interface StringLiteral extends LiteralExpression, Declaration {\n        kind: SyntaxKind.StringLiteral;\n    }\n    export type StringLiteralLike = StringLiteral | NoSubstitutionTemplateLiteral;\n    export interface Expression extends Node {\n        _expressionBrand: any;\n    }\n    export interface OmittedExpression extends Expression {\n        kind: SyntaxKind.OmittedExpression;\n    }\n    export interface PartiallyEmittedExpression extends LeftHandSideExpression {\n        kind: SyntaxKind.PartiallyEmittedExpression;\n        expression: Expression;\n    }\n    export interface UnaryExpression extends Expression {\n        _unaryExpressionBrand: any;\n    }\n    /** Deprecated, please use UpdateExpression */\n    export type IncrementExpression = UpdateExpression;\n    export interface UpdateExpression extends UnaryExpression {\n        _updateExpressionBrand: any;\n    }\n    export type PrefixUnaryOperator = SyntaxKind.PlusPlusToken | SyntaxKind.MinusMinusToken | SyntaxKind.PlusToken | SyntaxKind.MinusToken | SyntaxKind.TildeToken | SyntaxKind.ExclamationToken;\n    export interface PrefixUnaryExpression extends UpdateExpression {\n        kind: SyntaxKind.PrefixUnaryExpression;\n        operator: PrefixUnaryOperator;\n        operand: UnaryExpression;\n    }\n    export type PostfixUnaryOperator = SyntaxKind.PlusPlusToken | SyntaxKind.MinusMinusToken;\n    export interface PostfixUnaryExpression extends UpdateExpression {\n        kind: SyntaxKind.PostfixUnaryExpression;\n        operand: LeftHandSideExpression;\n        operator: PostfixUnaryOperator;\n    }\n    export interface LeftHandSideExpression extends UpdateExpression {\n        _leftHandSideExpressionBrand: any;\n    }\n    export interface MemberExpression extends LeftHandSideExpression {\n        _memberExpressionBrand: any;\n    }\n    export interface PrimaryExpression extends MemberExpression {\n        _primaryExpressionBrand: any;\n    }\n    export interface NullLiteral extends PrimaryExpression, TypeNode {\n        kind: SyntaxKind.NullKeyword;\n    }\n    export interface BooleanLiteral extends PrimaryExpression, TypeNode {\n        kind: SyntaxKind.TrueKeyword | SyntaxKind.FalseKeyword;\n    }\n    export interface ThisExpression extends PrimaryExpression, KeywordTypeNode {\n        kind: SyntaxKind.ThisKeyword;\n    }\n    export interface SuperExpression extends PrimaryExpression {\n        kind: SyntaxKind.SuperKeyword;\n    }\n    export interface ImportExpression extends PrimaryExpression {\n        kind: SyntaxKind.ImportKeyword;\n    }\n    export interface DeleteExpression extends UnaryExpression {\n        kind: SyntaxKind.DeleteExpression;\n        expression: UnaryExpression;\n    }\n    export interface TypeOfExpression extends UnaryExpression {\n        kind: SyntaxKind.TypeOfExpression;\n        expression: UnaryExpression;\n    }\n    export interface VoidExpression extends UnaryExpression {\n        kind: SyntaxKind.VoidExpression;\n        expression: UnaryExpression;\n    }\n    export interface AwaitExpression extends UnaryExpression {\n        kind: SyntaxKind.AwaitExpression;\n        expression: UnaryExpression;\n    }\n    export interface YieldExpression extends Expression {\n        kind: SyntaxKind.YieldExpression;\n        asteriskToken?: AsteriskToken;\n        expression?: Expression;\n    }\n    export interface SyntheticExpression extends Expression {\n        kind: SyntaxKind.SyntheticExpression;\n        isSpread: boolean;\n        type: Type;\n    }\n    export type ExponentiationOperator = SyntaxKind.AsteriskAsteriskToken;\n    export type MultiplicativeOperator = SyntaxKind.AsteriskToken | SyntaxKind.SlashToken | SyntaxKind.PercentToken;\n    export type MultiplicativeOperatorOrHigher = ExponentiationOperator | MultiplicativeOperator;\n    export type AdditiveOperator = SyntaxKind.PlusToken | SyntaxKind.MinusToken;\n    export type AdditiveOperatorOrHigher = MultiplicativeOperatorOrHigher | AdditiveOperator;\n    export type ShiftOperator = SyntaxKind.LessThanLessThanToken | SyntaxKind.GreaterThanGreaterThanToken | SyntaxKind.GreaterThanGreaterThanGreaterThanToken;\n    export type ShiftOperatorOrHigher = AdditiveOperatorOrHigher | ShiftOperator;\n    export type RelationalOperator = SyntaxKind.LessThanToken | SyntaxKind.LessThanEqualsToken | SyntaxKind.GreaterThanToken | SyntaxKind.GreaterThanEqualsToken | SyntaxKind.InstanceOfKeyword | SyntaxKind.InKeyword;\n    export type RelationalOperatorOrHigher = ShiftOperatorOrHigher | RelationalOperator;\n    export type EqualityOperator = SyntaxKind.EqualsEqualsToken | SyntaxKind.EqualsEqualsEqualsToken | SyntaxKind.ExclamationEqualsEqualsToken | SyntaxKind.ExclamationEqualsToken;\n    export type EqualityOperatorOrHigher = RelationalOperatorOrHigher | EqualityOperator;\n    export type BitwiseOperator = SyntaxKind.AmpersandToken | SyntaxKind.BarToken | SyntaxKind.CaretToken;\n    export type BitwiseOperatorOrHigher = EqualityOperatorOrHigher | BitwiseOperator;\n    export type LogicalOperator = SyntaxKind.AmpersandAmpersandToken | SyntaxKind.BarBarToken;\n    export type LogicalOperatorOrHigher = BitwiseOperatorOrHigher | LogicalOperator;\n    export type CompoundAssignmentOperator = SyntaxKind.PlusEqualsToken | SyntaxKind.MinusEqualsToken | SyntaxKind.AsteriskAsteriskEqualsToken | SyntaxKind.AsteriskEqualsToken | SyntaxKind.SlashEqualsToken | SyntaxKind.PercentEqualsToken | SyntaxKind.AmpersandEqualsToken | SyntaxKind.BarEqualsToken | SyntaxKind.CaretEqualsToken | SyntaxKind.LessThanLessThanEqualsToken | SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken | SyntaxKind.GreaterThanGreaterThanEqualsToken;\n    export type AssignmentOperator = SyntaxKind.EqualsToken | CompoundAssignmentOperator;\n    export type AssignmentOperatorOrHigher = SyntaxKind.QuestionQuestionToken | LogicalOperatorOrHigher | AssignmentOperator;\n    export type BinaryOperator = AssignmentOperatorOrHigher | SyntaxKind.CommaToken;\n    export type BinaryOperatorToken = Token<BinaryOperator>;\n    export interface BinaryExpression extends Expression, Declaration {\n        kind: SyntaxKind.BinaryExpression;\n        left: Expression;\n        operatorToken: BinaryOperatorToken;\n        right: Expression;\n    }\n    export type AssignmentOperatorToken = Token<AssignmentOperator>;\n    export interface AssignmentExpression<TOperator extends AssignmentOperatorToken> extends BinaryExpression {\n        left: LeftHandSideExpression;\n        operatorToken: TOperator;\n    }\n    export interface ObjectDestructuringAssignment extends AssignmentExpression<EqualsToken> {\n        left: ObjectLiteralExpression;\n    }\n    export interface ArrayDestructuringAssignment extends AssignmentExpression<EqualsToken> {\n        left: ArrayLiteralExpression;\n    }\n    export type DestructuringAssignment = ObjectDestructuringAssignment | ArrayDestructuringAssignment;\n    export type BindingOrAssignmentElement = VariableDeclaration | ParameterDeclaration | BindingElement | PropertyAssignment | ShorthandPropertyAssignment | SpreadAssignment | OmittedExpression | SpreadElement | ArrayLiteralExpression | ObjectLiteralExpression | AssignmentExpression<EqualsToken> | Identifier | PropertyAccessExpression | ElementAccessExpression;\n    export type BindingOrAssignmentElementRestIndicator = DotDotDotToken | SpreadElement | SpreadAssignment;\n    export type BindingOrAssignmentElementTarget = BindingOrAssignmentPattern | Identifier | PropertyAccessExpression | ElementAccessExpression | OmittedExpression;\n    export type ObjectBindingOrAssignmentPattern = ObjectBindingPattern | ObjectLiteralExpression;\n    export type ArrayBindingOrAssignmentPattern = ArrayBindingPattern | ArrayLiteralExpression;\n    export type AssignmentPattern = ObjectLiteralExpression | ArrayLiteralExpression;\n    export type BindingOrAssignmentPattern = ObjectBindingOrAssignmentPattern | ArrayBindingOrAssignmentPattern;\n    export interface ConditionalExpression extends Expression {\n        kind: SyntaxKind.ConditionalExpression;\n        condition: Expression;\n        questionToken: QuestionToken;\n        whenTrue: Expression;\n        colonToken: ColonToken;\n        whenFalse: Expression;\n    }\n    export type FunctionBody = Block;\n    export type ConciseBody = FunctionBody | Expression;\n    export interface FunctionExpression extends PrimaryExpression, FunctionLikeDeclarationBase, JSDocContainer {\n        kind: SyntaxKind.FunctionExpression;\n        name?: Identifier;\n        body: FunctionBody;\n    }\n    export interface ArrowFunction extends Expression, FunctionLikeDeclarationBase, JSDocContainer {\n        kind: SyntaxKind.ArrowFunction;\n        equalsGreaterThanToken: EqualsGreaterThanToken;\n        body: ConciseBody;\n        name: never;\n    }\n    export interface LiteralLikeNode extends Node {\n        text: string;\n        isUnterminated?: boolean;\n        hasExtendedUnicodeEscape?: boolean;\n    }\n    export interface TemplateLiteralLikeNode extends LiteralLikeNode {\n        rawText?: string;\n    }\n    export interface LiteralExpression extends LiteralLikeNode, PrimaryExpression {\n        _literalExpressionBrand: any;\n    }\n    export interface RegularExpressionLiteral extends LiteralExpression {\n        kind: SyntaxKind.RegularExpressionLiteral;\n    }\n    export interface NoSubstitutionTemplateLiteral extends LiteralExpression, TemplateLiteralLikeNode, Declaration {\n        kind: SyntaxKind.NoSubstitutionTemplateLiteral;\n    }\n    export enum TokenFlags {\n        None = 0,\n        Scientific = 16,\n        Octal = 32,\n        HexSpecifier = 64,\n        BinarySpecifier = 128,\n        OctalSpecifier = 256,\n    }\n    export interface NumericLiteral extends LiteralExpression, Declaration {\n        kind: SyntaxKind.NumericLiteral;\n    }\n    export interface BigIntLiteral extends LiteralExpression {\n        kind: SyntaxKind.BigIntLiteral;\n    }\n    export interface TemplateHead extends TemplateLiteralLikeNode {\n        kind: SyntaxKind.TemplateHead;\n        parent: TemplateExpression;\n    }\n    export interface TemplateMiddle extends TemplateLiteralLikeNode {\n        kind: SyntaxKind.TemplateMiddle;\n        parent: TemplateSpan;\n    }\n    export interface TemplateTail extends TemplateLiteralLikeNode {\n        kind: SyntaxKind.TemplateTail;\n        parent: TemplateSpan;\n    }\n    export type TemplateLiteral = TemplateExpression | NoSubstitutionTemplateLiteral;\n    export interface TemplateExpression extends PrimaryExpression {\n        kind: SyntaxKind.TemplateExpression;\n        head: TemplateHead;\n        templateSpans: NodeArray<TemplateSpan>;\n    }\n    export interface TemplateSpan extends Node {\n        kind: SyntaxKind.TemplateSpan;\n        parent: TemplateExpression;\n        expression: Expression;\n        literal: TemplateMiddle | TemplateTail;\n    }\n    export interface ParenthesizedExpression extends PrimaryExpression, JSDocContainer {\n        kind: SyntaxKind.ParenthesizedExpression;\n        expression: Expression;\n    }\n    export interface ArrayLiteralExpression extends PrimaryExpression {\n        kind: SyntaxKind.ArrayLiteralExpression;\n        elements: NodeArray<Expression>;\n    }\n    export interface SpreadElement extends Expression {\n        kind: SyntaxKind.SpreadElement;\n        parent: ArrayLiteralExpression | CallExpression | NewExpression;\n        expression: Expression;\n    }\n    /**\n     * This interface is a base interface for ObjectLiteralExpression and JSXAttributes to extend from. JSXAttributes is similar to\n     * ObjectLiteralExpression in that it contains array of properties; however, JSXAttributes\' properties can only be\n     * JSXAttribute or JSXSpreadAttribute. ObjectLiteralExpression, on the other hand, can only have properties of type\n     * ObjectLiteralElement (e.g. PropertyAssignment, ShorthandPropertyAssignment etc.)\n     */\n    export interface ObjectLiteralExpressionBase<T extends ObjectLiteralElement> extends PrimaryExpression, Declaration {\n        properties: NodeArray<T>;\n    }\n    export interface ObjectLiteralExpression extends ObjectLiteralExpressionBase<ObjectLiteralElementLike> {\n        kind: SyntaxKind.ObjectLiteralExpression;\n    }\n    export type EntityNameExpression = Identifier | PropertyAccessEntityNameExpression;\n    export type EntityNameOrEntityNameExpression = EntityName | EntityNameExpression;\n    export interface PropertyAccessExpression extends MemberExpression, NamedDeclaration {\n        kind: SyntaxKind.PropertyAccessExpression;\n        expression: LeftHandSideExpression;\n        questionDotToken?: QuestionDotToken;\n        name: Identifier | PrivateIdentifier;\n    }\n    export interface PropertyAccessChain extends PropertyAccessExpression {\n        _optionalChainBrand: any;\n        name: Identifier;\n    }\n    export interface SuperPropertyAccessExpression extends PropertyAccessExpression {\n        expression: SuperExpression;\n    }\n    /** Brand for a PropertyAccessExpression which, like a QualifiedName, consists of a sequence of identifiers separated by dots. */\n    export interface PropertyAccessEntityNameExpression extends PropertyAccessExpression {\n        _propertyAccessExpressionLikeQualifiedNameBrand?: any;\n        expression: EntityNameExpression;\n        name: Identifier;\n    }\n    export interface ElementAccessExpression extends MemberExpression {\n        kind: SyntaxKind.ElementAccessExpression;\n        expression: LeftHandSideExpression;\n        questionDotToken?: QuestionDotToken;\n        argumentExpression: Expression;\n    }\n    export interface ElementAccessChain extends ElementAccessExpression {\n        _optionalChainBrand: any;\n    }\n    export interface SuperElementAccessExpression extends ElementAccessExpression {\n        expression: SuperExpression;\n    }\n    export type SuperProperty = SuperPropertyAccessExpression | SuperElementAccessExpression;\n    export interface CallExpression extends LeftHandSideExpression, Declaration {\n        kind: SyntaxKind.CallExpression;\n        expression: LeftHandSideExpression;\n        questionDotToken?: QuestionDotToken;\n        typeArguments?: NodeArray<TypeNode>;\n        arguments: NodeArray<Expression>;\n    }\n    export interface CallChain extends CallExpression {\n        _optionalChainBrand: any;\n    }\n    export type OptionalChain = PropertyAccessChain | ElementAccessChain | CallChain | NonNullChain;\n    export interface SuperCall extends CallExpression {\n        expression: SuperExpression;\n    }\n    export interface ImportCall extends CallExpression {\n        expression: ImportExpression;\n    }\n    export interface ExpressionWithTypeArguments extends NodeWithTypeArguments {\n        kind: SyntaxKind.ExpressionWithTypeArguments;\n        parent: HeritageClause | JSDocAugmentsTag | JSDocImplementsTag;\n        expression: LeftHandSideExpression;\n    }\n    export interface NewExpression extends PrimaryExpression, Declaration {\n        kind: SyntaxKind.NewExpression;\n        expression: LeftHandSideExpression;\n        typeArguments?: NodeArray<TypeNode>;\n        arguments?: NodeArray<Expression>;\n    }\n    export interface TaggedTemplateExpression extends MemberExpression {\n        kind: SyntaxKind.TaggedTemplateExpression;\n        tag: LeftHandSideExpression;\n        typeArguments?: NodeArray<TypeNode>;\n        template: TemplateLiteral;\n    }\n    export type CallLikeExpression = CallExpression | NewExpression | TaggedTemplateExpression | Decorator | JsxOpeningLikeElement;\n    export interface AsExpression extends Expression {\n        kind: SyntaxKind.AsExpression;\n        expression: Expression;\n        type: TypeNode;\n    }\n    export interface TypeAssertion extends UnaryExpression {\n        kind: SyntaxKind.TypeAssertionExpression;\n        type: TypeNode;\n        expression: UnaryExpression;\n    }\n    export type AssertionExpression = TypeAssertion | AsExpression;\n    export interface NonNullExpression extends LeftHandSideExpression {\n        kind: SyntaxKind.NonNullExpression;\n        expression: Expression;\n    }\n    export interface NonNullChain extends NonNullExpression {\n        _optionalChainBrand: any;\n    }\n    export interface MetaProperty extends PrimaryExpression {\n        kind: SyntaxKind.MetaProperty;\n        keywordToken: SyntaxKind.NewKeyword | SyntaxKind.ImportKeyword;\n        name: Identifier;\n    }\n    export interface JsxElement extends PrimaryExpression {\n        kind: SyntaxKind.JsxElement;\n        openingElement: JsxOpeningElement;\n        children: NodeArray<JsxChild>;\n        closingElement: JsxClosingElement;\n    }\n    export type JsxOpeningLikeElement = JsxSelfClosingElement | JsxOpeningElement;\n    export type JsxAttributeLike = JsxAttribute | JsxSpreadAttribute;\n    export type JsxTagNameExpression = Identifier | ThisExpression | JsxTagNamePropertyAccess;\n    export interface JsxTagNamePropertyAccess extends PropertyAccessExpression {\n        expression: JsxTagNameExpression;\n    }\n    export interface JsxAttributes extends ObjectLiteralExpressionBase<JsxAttributeLike> {\n        kind: SyntaxKind.JsxAttributes;\n        parent: JsxOpeningLikeElement;\n    }\n    export interface JsxOpeningElement extends Expression {\n        kind: SyntaxKind.JsxOpeningElement;\n        parent: JsxElement;\n        tagName: JsxTagNameExpression;\n        typeArguments?: NodeArray<TypeNode>;\n        attributes: JsxAttributes;\n    }\n    export interface JsxSelfClosingElement extends PrimaryExpression {\n        kind: SyntaxKind.JsxSelfClosingElement;\n        tagName: JsxTagNameExpression;\n        typeArguments?: NodeArray<TypeNode>;\n        attributes: JsxAttributes;\n    }\n    export interface JsxFragment extends PrimaryExpression {\n        kind: SyntaxKind.JsxFragment;\n        openingFragment: JsxOpeningFragment;\n        children: NodeArray<JsxChild>;\n        closingFragment: JsxClosingFragment;\n    }\n    export interface JsxOpeningFragment extends Expression {\n        kind: SyntaxKind.JsxOpeningFragment;\n        parent: JsxFragment;\n    }\n    export interface JsxClosingFragment extends Expression {\n        kind: SyntaxKind.JsxClosingFragment;\n        parent: JsxFragment;\n    }\n    export interface JsxAttribute extends ObjectLiteralElement {\n        kind: SyntaxKind.JsxAttribute;\n        parent: JsxAttributes;\n        name: Identifier;\n        initializer?: StringLiteral | JsxExpression;\n    }\n    export interface JsxSpreadAttribute extends ObjectLiteralElement {\n        kind: SyntaxKind.JsxSpreadAttribute;\n        parent: JsxAttributes;\n        expression: Expression;\n    }\n    export interface JsxClosingElement extends Node {\n        kind: SyntaxKind.JsxClosingElement;\n        parent: JsxElement;\n        tagName: JsxTagNameExpression;\n    }\n    export interface JsxExpression extends Expression {\n        kind: SyntaxKind.JsxExpression;\n        parent: JsxElement | JsxAttributeLike;\n        dotDotDotToken?: Token<SyntaxKind.DotDotDotToken>;\n        expression?: Expression;\n    }\n    export interface JsxText extends LiteralLikeNode {\n        kind: SyntaxKind.JsxText;\n        containsOnlyTriviaWhiteSpaces: boolean;\n        parent: JsxElement;\n    }\n    export type JsxChild = JsxText | JsxExpression | JsxElement | JsxSelfClosingElement | JsxFragment;\n    export interface Statement extends Node {\n        _statementBrand: any;\n    }\n    export interface NotEmittedStatement extends Statement {\n        kind: SyntaxKind.NotEmittedStatement;\n    }\n    /**\n     * A list of comma-separated expressions. This node is only created by transformations.\n     */\n    export interface CommaListExpression extends Expression {\n        kind: SyntaxKind.CommaListExpression;\n        elements: NodeArray<Expression>;\n    }\n    export interface EmptyStatement extends Statement {\n        kind: SyntaxKind.EmptyStatement;\n    }\n    export interface DebuggerStatement extends Statement {\n        kind: SyntaxKind.DebuggerStatement;\n    }\n    export interface MissingDeclaration extends DeclarationStatement {\n        kind: SyntaxKind.MissingDeclaration;\n        name?: Identifier;\n    }\n    export type BlockLike = SourceFile | Block | ModuleBlock | CaseOrDefaultClause;\n    export interface Block extends Statement {\n        kind: SyntaxKind.Block;\n        statements: NodeArray<Statement>;\n    }\n    export interface VariableStatement extends Statement, JSDocContainer {\n        kind: SyntaxKind.VariableStatement;\n        declarationList: VariableDeclarationList;\n    }\n    export interface ExpressionStatement extends Statement, JSDocContainer {\n        kind: SyntaxKind.ExpressionStatement;\n        expression: Expression;\n    }\n    export interface IfStatement extends Statement {\n        kind: SyntaxKind.IfStatement;\n        expression: Expression;\n        thenStatement: Statement;\n        elseStatement?: Statement;\n    }\n    export interface IterationStatement extends Statement {\n        statement: Statement;\n    }\n    export interface DoStatement extends IterationStatement {\n        kind: SyntaxKind.DoStatement;\n        expression: Expression;\n    }\n    export interface WhileStatement extends IterationStatement {\n        kind: SyntaxKind.WhileStatement;\n        expression: Expression;\n    }\n    export type ForInitializer = VariableDeclarationList | Expression;\n    export interface ForStatement extends IterationStatement {\n        kind: SyntaxKind.ForStatement;\n        initializer?: ForInitializer;\n        condition?: Expression;\n        incrementor?: Expression;\n    }\n    export type ForInOrOfStatement = ForInStatement | ForOfStatement;\n    export interface ForInStatement extends IterationStatement {\n        kind: SyntaxKind.ForInStatement;\n        initializer: ForInitializer;\n        expression: Expression;\n    }\n    export interface ForOfStatement extends IterationStatement {\n        kind: SyntaxKind.ForOfStatement;\n        awaitModifier?: AwaitKeywordToken;\n        initializer: ForInitializer;\n        expression: Expression;\n    }\n    export interface BreakStatement extends Statement {\n        kind: SyntaxKind.BreakStatement;\n        label?: Identifier;\n    }\n    export interface ContinueStatement extends Statement {\n        kind: SyntaxKind.ContinueStatement;\n        label?: Identifier;\n    }\n    export type BreakOrContinueStatement = BreakStatement | ContinueStatement;\n    export interface ReturnStatement extends Statement {\n        kind: SyntaxKind.ReturnStatement;\n        expression?: Expression;\n    }\n    export interface WithStatement extends Statement {\n        kind: SyntaxKind.WithStatement;\n        expression: Expression;\n        statement: Statement;\n    }\n    export interface SwitchStatement extends Statement {\n        kind: SyntaxKind.SwitchStatement;\n        expression: Expression;\n        caseBlock: CaseBlock;\n        possiblyExhaustive?: boolean;\n    }\n    export interface CaseBlock extends Node {\n        kind: SyntaxKind.CaseBlock;\n        parent: SwitchStatement;\n        clauses: NodeArray<CaseOrDefaultClause>;\n    }\n    export interface CaseClause extends Node {\n        kind: SyntaxKind.CaseClause;\n        parent: CaseBlock;\n        expression: Expression;\n        statements: NodeArray<Statement>;\n    }\n    export interface DefaultClause extends Node {\n        kind: SyntaxKind.DefaultClause;\n        parent: CaseBlock;\n        statements: NodeArray<Statement>;\n    }\n    export type CaseOrDefaultClause = CaseClause | DefaultClause;\n    export interface LabeledStatement extends Statement, JSDocContainer {\n        kind: SyntaxKind.LabeledStatement;\n        label: Identifier;\n        statement: Statement;\n    }\n    export interface ThrowStatement extends Statement {\n        kind: SyntaxKind.ThrowStatement;\n        expression?: Expression;\n    }\n    export interface TryStatement extends Statement {\n        kind: SyntaxKind.TryStatement;\n        tryBlock: Block;\n        catchClause?: CatchClause;\n        finallyBlock?: Block;\n    }\n    export interface CatchClause extends Node {\n        kind: SyntaxKind.CatchClause;\n        parent: TryStatement;\n        variableDeclaration?: VariableDeclaration;\n        block: Block;\n    }\n    export type ObjectTypeDeclaration = ClassLikeDeclaration | InterfaceDeclaration | TypeLiteralNode;\n    export type DeclarationWithTypeParameters = DeclarationWithTypeParameterChildren | JSDocTypedefTag | JSDocCallbackTag | JSDocSignature;\n    export type DeclarationWithTypeParameterChildren = SignatureDeclaration | ClassLikeDeclaration | InterfaceDeclaration | TypeAliasDeclaration | JSDocTemplateTag;\n    export interface ClassLikeDeclarationBase extends NamedDeclaration, JSDocContainer {\n        kind: SyntaxKind.ClassDeclaration | SyntaxKind.ClassExpression;\n        name?: Identifier;\n        typeParameters?: NodeArray<TypeParameterDeclaration>;\n        heritageClauses?: NodeArray<HeritageClause>;\n        members: NodeArray<ClassElement>;\n    }\n    export interface ClassDeclaration extends ClassLikeDeclarationBase, DeclarationStatement {\n        kind: SyntaxKind.ClassDeclaration;\n        /** May be undefined in `export default class { ... }`. */\n        name?: Identifier;\n    }\n    export interface ClassExpression extends ClassLikeDeclarationBase, PrimaryExpression {\n        kind: SyntaxKind.ClassExpression;\n    }\n    export type ClassLikeDeclaration = ClassDeclaration | ClassExpression;\n    export interface ClassElement extends NamedDeclaration {\n        _classElementBrand: any;\n        name?: PropertyName;\n    }\n    export interface TypeElement extends NamedDeclaration {\n        _typeElementBrand: any;\n        name?: PropertyName;\n        questionToken?: QuestionToken;\n    }\n    export interface InterfaceDeclaration extends DeclarationStatement, JSDocContainer {\n        kind: SyntaxKind.InterfaceDeclaration;\n        name: Identifier;\n        typeParameters?: NodeArray<TypeParameterDeclaration>;\n        heritageClauses?: NodeArray<HeritageClause>;\n        members: NodeArray<TypeElement>;\n    }\n    export interface HeritageClause extends Node {\n        kind: SyntaxKind.HeritageClause;\n        parent: InterfaceDeclaration | ClassLikeDeclaration;\n        token: SyntaxKind.ExtendsKeyword | SyntaxKind.ImplementsKeyword;\n        types: NodeArray<ExpressionWithTypeArguments>;\n    }\n    export interface TypeAliasDeclaration extends DeclarationStatement, JSDocContainer {\n        kind: SyntaxKind.TypeAliasDeclaration;\n        name: Identifier;\n        typeParameters?: NodeArray<TypeParameterDeclaration>;\n        type: TypeNode;\n    }\n    export interface EnumMember extends NamedDeclaration, JSDocContainer {\n        kind: SyntaxKind.EnumMember;\n        parent: EnumDeclaration;\n        name: PropertyName;\n        initializer?: Expression;\n    }\n    export interface EnumDeclaration extends DeclarationStatement, JSDocContainer {\n        kind: SyntaxKind.EnumDeclaration;\n        name: Identifier;\n        members: NodeArray<EnumMember>;\n    }\n    export type ModuleName = Identifier | StringLiteral;\n    export type ModuleBody = NamespaceBody | JSDocNamespaceBody;\n    export interface ModuleDeclaration extends DeclarationStatement, JSDocContainer {\n        kind: SyntaxKind.ModuleDeclaration;\n        parent: ModuleBody | SourceFile;\n        name: ModuleName;\n        body?: ModuleBody | JSDocNamespaceDeclaration;\n    }\n    export type NamespaceBody = ModuleBlock | NamespaceDeclaration;\n    export interface NamespaceDeclaration extends ModuleDeclaration {\n        name: Identifier;\n        body: NamespaceBody;\n    }\n    export type JSDocNamespaceBody = Identifier | JSDocNamespaceDeclaration;\n    export interface JSDocNamespaceDeclaration extends ModuleDeclaration {\n        name: Identifier;\n        body?: JSDocNamespaceBody;\n    }\n    export interface ModuleBlock extends Node, Statement {\n        kind: SyntaxKind.ModuleBlock;\n        parent: ModuleDeclaration;\n        statements: NodeArray<Statement>;\n    }\n    export type ModuleReference = EntityName | ExternalModuleReference;\n    /**\n     * One of:\n     * - import x = require("mod");\n     * - import x = M.x;\n     */\n    export interface ImportEqualsDeclaration extends DeclarationStatement, JSDocContainer {\n        kind: SyntaxKind.ImportEqualsDeclaration;\n        parent: SourceFile | ModuleBlock;\n        name: Identifier;\n        moduleReference: ModuleReference;\n    }\n    export interface ExternalModuleReference extends Node {\n        kind: SyntaxKind.ExternalModuleReference;\n        parent: ImportEqualsDeclaration;\n        expression: Expression;\n    }\n    export interface ImportDeclaration extends Statement {\n        kind: SyntaxKind.ImportDeclaration;\n        parent: SourceFile | ModuleBlock;\n        importClause?: ImportClause;\n        /** If this is not a StringLiteral it will be a grammar error. */\n        moduleSpecifier: Expression;\n    }\n    export type NamedImportBindings = NamespaceImport | NamedImports;\n    export type NamedExportBindings = NamespaceExport | NamedExports;\n    export interface ImportClause extends NamedDeclaration {\n        kind: SyntaxKind.ImportClause;\n        parent: ImportDeclaration;\n        isTypeOnly: boolean;\n        name?: Identifier;\n        namedBindings?: NamedImportBindings;\n    }\n    export interface NamespaceImport extends NamedDeclaration {\n        kind: SyntaxKind.NamespaceImport;\n        parent: ImportClause;\n        name: Identifier;\n    }\n    export interface NamespaceExport extends NamedDeclaration {\n        kind: SyntaxKind.NamespaceExport;\n        parent: ExportDeclaration;\n        name: Identifier;\n    }\n    export interface NamespaceExportDeclaration extends DeclarationStatement {\n        kind: SyntaxKind.NamespaceExportDeclaration;\n        name: Identifier;\n    }\n    export interface ExportDeclaration extends DeclarationStatement, JSDocContainer {\n        kind: SyntaxKind.ExportDeclaration;\n        parent: SourceFile | ModuleBlock;\n        isTypeOnly: boolean;\n        /** Will not be assigned in the case of `export * from "foo";` */\n        exportClause?: NamedExportBindings;\n        /** If this is not a StringLiteral it will be a grammar error. */\n        moduleSpecifier?: Expression;\n    }\n    export interface NamedImports extends Node {\n        kind: SyntaxKind.NamedImports;\n        parent: ImportClause;\n        elements: NodeArray<ImportSpecifier>;\n    }\n    export interface NamedExports extends Node {\n        kind: SyntaxKind.NamedExports;\n        parent: ExportDeclaration;\n        elements: NodeArray<ExportSpecifier>;\n    }\n    export type NamedImportsOrExports = NamedImports | NamedExports;\n    export interface ImportSpecifier extends NamedDeclaration {\n        kind: SyntaxKind.ImportSpecifier;\n        parent: NamedImports;\n        propertyName?: Identifier;\n        name: Identifier;\n    }\n    export interface ExportSpecifier extends NamedDeclaration {\n        kind: SyntaxKind.ExportSpecifier;\n        parent: NamedExports;\n        propertyName?: Identifier;\n        name: Identifier;\n    }\n    export type ImportOrExportSpecifier = ImportSpecifier | ExportSpecifier;\n    export type TypeOnlyCompatibleAliasDeclaration = ImportClause | NamespaceImport | ImportOrExportSpecifier;\n    /**\n     * This is either an `export =` or an `export default` declaration.\n     * Unless `isExportEquals` is set, this node was parsed as an `export default`.\n     */\n    export interface ExportAssignment extends DeclarationStatement {\n        kind: SyntaxKind.ExportAssignment;\n        parent: SourceFile;\n        isExportEquals?: boolean;\n        expression: Expression;\n    }\n    export interface FileReference extends TextRange {\n        fileName: string;\n    }\n    export interface CheckJsDirective extends TextRange {\n        enabled: boolean;\n    }\n    export type CommentKind = SyntaxKind.SingleLineCommentTrivia | SyntaxKind.MultiLineCommentTrivia;\n    export interface CommentRange extends TextRange {\n        hasTrailingNewLine?: boolean;\n        kind: CommentKind;\n    }\n    export interface SynthesizedComment extends CommentRange {\n        text: string;\n        pos: -1;\n        end: -1;\n    }\n    export interface JSDocTypeExpression extends TypeNode {\n        kind: SyntaxKind.JSDocTypeExpression;\n        type: TypeNode;\n    }\n    export interface JSDocType extends TypeNode {\n        _jsDocTypeBrand: any;\n    }\n    export interface JSDocAllType extends JSDocType {\n        kind: SyntaxKind.JSDocAllType;\n    }\n    export interface JSDocUnknownType extends JSDocType {\n        kind: SyntaxKind.JSDocUnknownType;\n    }\n    export interface JSDocNonNullableType extends JSDocType {\n        kind: SyntaxKind.JSDocNonNullableType;\n        type: TypeNode;\n    }\n    export interface JSDocNullableType extends JSDocType {\n        kind: SyntaxKind.JSDocNullableType;\n        type: TypeNode;\n    }\n    export interface JSDocOptionalType extends JSDocType {\n        kind: SyntaxKind.JSDocOptionalType;\n        type: TypeNode;\n    }\n    export interface JSDocFunctionType extends JSDocType, SignatureDeclarationBase {\n        kind: SyntaxKind.JSDocFunctionType;\n    }\n    export interface JSDocVariadicType extends JSDocType {\n        kind: SyntaxKind.JSDocVariadicType;\n        type: TypeNode;\n    }\n    export interface JSDocNamepathType extends JSDocType {\n        kind: SyntaxKind.JSDocNamepathType;\n        type: TypeNode;\n    }\n    export type JSDocTypeReferencingNode = JSDocVariadicType | JSDocOptionalType | JSDocNullableType | JSDocNonNullableType;\n    export interface JSDoc extends Node {\n        kind: SyntaxKind.JSDocComment;\n        parent: HasJSDoc;\n        tags?: NodeArray<JSDocTag>;\n        comment?: string;\n    }\n    export interface JSDocTag extends Node {\n        parent: JSDoc | JSDocTypeLiteral;\n        tagName: Identifier;\n        comment?: string;\n    }\n    export interface JSDocUnknownTag extends JSDocTag {\n        kind: SyntaxKind.JSDocTag;\n    }\n    /**\n     * Note that `@extends` is a synonym of `@augments`.\n     * Both tags are represented by this interface.\n     */\n    export interface JSDocAugmentsTag extends JSDocTag {\n        kind: SyntaxKind.JSDocAugmentsTag;\n        class: ExpressionWithTypeArguments & {\n            expression: Identifier | PropertyAccessEntityNameExpression;\n        };\n    }\n    export interface JSDocImplementsTag extends JSDocTag {\n        kind: SyntaxKind.JSDocImplementsTag;\n        class: ExpressionWithTypeArguments & {\n            expression: Identifier | PropertyAccessEntityNameExpression;\n        };\n    }\n    export interface JSDocAuthorTag extends JSDocTag {\n        kind: SyntaxKind.JSDocAuthorTag;\n    }\n    export interface JSDocClassTag extends JSDocTag {\n        kind: SyntaxKind.JSDocClassTag;\n    }\n    export interface JSDocPublicTag extends JSDocTag {\n        kind: SyntaxKind.JSDocPublicTag;\n    }\n    export interface JSDocPrivateTag extends JSDocTag {\n        kind: SyntaxKind.JSDocPrivateTag;\n    }\n    export interface JSDocProtectedTag extends JSDocTag {\n        kind: SyntaxKind.JSDocProtectedTag;\n    }\n    export interface JSDocReadonlyTag extends JSDocTag {\n        kind: SyntaxKind.JSDocReadonlyTag;\n    }\n    export interface JSDocEnumTag extends JSDocTag, Declaration {\n        parent: JSDoc;\n        kind: SyntaxKind.JSDocEnumTag;\n        typeExpression?: JSDocTypeExpression;\n    }\n    export interface JSDocThisTag extends JSDocTag {\n        kind: SyntaxKind.JSDocThisTag;\n        typeExpression?: JSDocTypeExpression;\n    }\n    export interface JSDocTemplateTag extends JSDocTag {\n        kind: SyntaxKind.JSDocTemplateTag;\n        constraint: JSDocTypeExpression | undefined;\n        typeParameters: NodeArray<TypeParameterDeclaration>;\n    }\n    export interface JSDocReturnTag extends JSDocTag {\n        kind: SyntaxKind.JSDocReturnTag;\n        typeExpression?: JSDocTypeExpression;\n    }\n    export interface JSDocTypeTag extends JSDocTag {\n        kind: SyntaxKind.JSDocTypeTag;\n        typeExpression: JSDocTypeExpression;\n    }\n    export interface JSDocTypedefTag extends JSDocTag, NamedDeclaration {\n        parent: JSDoc;\n        kind: SyntaxKind.JSDocTypedefTag;\n        fullName?: JSDocNamespaceDeclaration | Identifier;\n        name?: Identifier;\n        typeExpression?: JSDocTypeExpression | JSDocTypeLiteral;\n    }\n    export interface JSDocCallbackTag extends JSDocTag, NamedDeclaration {\n        parent: JSDoc;\n        kind: SyntaxKind.JSDocCallbackTag;\n        fullName?: JSDocNamespaceDeclaration | Identifier;\n        name?: Identifier;\n        typeExpression: JSDocSignature;\n    }\n    export interface JSDocSignature extends JSDocType, Declaration {\n        kind: SyntaxKind.JSDocSignature;\n        typeParameters?: readonly JSDocTemplateTag[];\n        parameters: readonly JSDocParameterTag[];\n        type: JSDocReturnTag | undefined;\n    }\n    export interface JSDocPropertyLikeTag extends JSDocTag, Declaration {\n        parent: JSDoc;\n        name: EntityName;\n        typeExpression?: JSDocTypeExpression;\n        /** Whether the property name came before the type -- non-standard for JSDoc, but Typescript-like */\n        isNameFirst: boolean;\n        isBracketed: boolean;\n    }\n    export interface JSDocPropertyTag extends JSDocPropertyLikeTag {\n        kind: SyntaxKind.JSDocPropertyTag;\n    }\n    export interface JSDocParameterTag extends JSDocPropertyLikeTag {\n        kind: SyntaxKind.JSDocParameterTag;\n    }\n    export interface JSDocTypeLiteral extends JSDocType {\n        kind: SyntaxKind.JSDocTypeLiteral;\n        jsDocPropertyTags?: readonly JSDocPropertyLikeTag[];\n        /** If true, then this type literal represents an *array* of its type. */\n        isArrayType?: boolean;\n    }\n    export enum FlowFlags {\n        Unreachable = 1,\n        Start = 2,\n        BranchLabel = 4,\n        LoopLabel = 8,\n        Assignment = 16,\n        TrueCondition = 32,\n        FalseCondition = 64,\n        SwitchClause = 128,\n        ArrayMutation = 256,\n        Call = 512,\n        ReduceLabel = 1024,\n        Referenced = 2048,\n        Shared = 4096,\n        Label = 12,\n        Condition = 96\n    }\n    export type FlowNode = AfterFinallyFlow | PreFinallyFlow | FlowStart | FlowLabel | FlowAssignment | FlowCall | FlowCondition | FlowSwitchClause | FlowArrayMutation;\n    export interface FlowNodeBase {\n        flags: FlowFlags;\n        id?: number;\n    }\n    export interface FlowLock {\n        locked?: boolean;\n    }\n    export interface AfterFinallyFlow extends FlowNodeBase, FlowLock {\n        antecedent: FlowNode;\n    }\n    export interface PreFinallyFlow extends FlowNodeBase {\n        antecedent: FlowNode;\n        lock: FlowLock;\n    }\n    export interface FlowStart extends FlowNodeBase {\n        node?: FunctionExpression | ArrowFunction | MethodDeclaration;\n    }\n    export interface FlowLabel extends FlowNodeBase {\n        antecedents: FlowNode[] | undefined;\n    }\n    export interface FlowAssignment extends FlowNodeBase {\n        node: Expression | VariableDeclaration | BindingElement;\n        antecedent: FlowNode;\n    }\n    export interface FlowCall extends FlowNodeBase {\n        node: CallExpression;\n        antecedent: FlowNode;\n    }\n    export interface FlowCondition extends FlowNodeBase {\n        node: Expression;\n        antecedent: FlowNode;\n    }\n    export interface FlowSwitchClause extends FlowNodeBase {\n        switchStatement: SwitchStatement;\n        clauseStart: number;\n        clauseEnd: number;\n        antecedent: FlowNode;\n    }\n    export interface FlowArrayMutation extends FlowNodeBase {\n        node: CallExpression | BinaryExpression;\n        antecedent: FlowNode;\n    }\n    export interface FlowReduceLabel extends FlowNodeBase {\n        target: FlowLabel;\n        antecedents: FlowNode[];\n        antecedent: FlowNode;\n    }\n    export type FlowType = Type | IncompleteType;\n    export interface IncompleteType {\n        flags: TypeFlags;\n        type: Type;\n    }\n    export interface AmdDependency {\n        path: string;\n        name?: string;\n    }\n    export interface SourceFile extends Declaration {\n        kind: SyntaxKind.SourceFile;\n        statements: NodeArray<Statement>;\n        endOfFileToken: Token<SyntaxKind.EndOfFileToken>;\n        fileName: string;\n        text: string;\n        amdDependencies: readonly AmdDependency[];\n        moduleName?: string;\n        referencedFiles: readonly FileReference[];\n        typeReferenceDirectives: readonly FileReference[];\n        libReferenceDirectives: readonly FileReference[];\n        languageVariant: LanguageVariant;\n        isDeclarationFile: boolean;\n        /**\n         * lib.d.ts should have a reference comment like\n         *\n         *  /// <reference no-default-lib="true"/>\n         *\n         * If any other file has this comment, it signals not to include lib.d.ts\n         * because this containing file is intended to act as a default library.\n         */\n        hasNoDefaultLib: boolean;\n        languageVersion: ScriptTarget;\n    }\n    export interface Bundle extends Node {\n        kind: SyntaxKind.Bundle;\n        prepends: readonly (InputFiles | UnparsedSource)[];\n        sourceFiles: readonly SourceFile[];\n    }\n    export interface InputFiles extends Node {\n        kind: SyntaxKind.InputFiles;\n        javascriptPath?: string;\n        javascriptText: string;\n        javascriptMapPath?: string;\n        javascriptMapText?: string;\n        declarationPath?: string;\n        declarationText: string;\n        declarationMapPath?: string;\n        declarationMapText?: string;\n    }\n    export interface UnparsedSource extends Node {\n        kind: SyntaxKind.UnparsedSource;\n        fileName: string;\n        text: string;\n        prologues: readonly UnparsedPrologue[];\n        helpers: readonly UnscopedEmitHelper[] | undefined;\n        referencedFiles: readonly FileReference[];\n        typeReferenceDirectives: readonly string[] | undefined;\n        libReferenceDirectives: readonly FileReference[];\n        hasNoDefaultLib?: boolean;\n        sourceMapPath?: string;\n        sourceMapText?: string;\n        syntheticReferences?: readonly UnparsedSyntheticReference[];\n        texts: readonly UnparsedSourceText[];\n    }\n    export type UnparsedSourceText = UnparsedPrepend | UnparsedTextLike;\n    export type UnparsedNode = UnparsedPrologue | UnparsedSourceText | UnparsedSyntheticReference;\n    export interface UnparsedSection extends Node {\n        kind: SyntaxKind;\n        data?: string;\n        parent: UnparsedSource;\n    }\n    export interface UnparsedPrologue extends UnparsedSection {\n        kind: SyntaxKind.UnparsedPrologue;\n        data: string;\n        parent: UnparsedSource;\n    }\n    export interface UnparsedPrepend extends UnparsedSection {\n        kind: SyntaxKind.UnparsedPrepend;\n        data: string;\n        parent: UnparsedSource;\n        texts: readonly UnparsedTextLike[];\n    }\n    export interface UnparsedTextLike extends UnparsedSection {\n        kind: SyntaxKind.UnparsedText | SyntaxKind.UnparsedInternalText;\n        parent: UnparsedSource;\n    }\n    export interface UnparsedSyntheticReference extends UnparsedSection {\n        kind: SyntaxKind.UnparsedSyntheticReference;\n        parent: UnparsedSource;\n    }\n    export interface JsonSourceFile extends SourceFile {\n        statements: NodeArray<JsonObjectExpressionStatement>;\n    }\n    export interface TsConfigSourceFile extends JsonSourceFile {\n        extendedSourceFiles?: string[];\n    }\n    export interface JsonMinusNumericLiteral extends PrefixUnaryExpression {\n        kind: SyntaxKind.PrefixUnaryExpression;\n        operator: SyntaxKind.MinusToken;\n        operand: NumericLiteral;\n    }\n    export interface JsonObjectExpressionStatement extends ExpressionStatement {\n        expression: ObjectLiteralExpression | ArrayLiteralExpression | JsonMinusNumericLiteral | NumericLiteral | StringLiteral | BooleanLiteral | NullLiteral;\n    }\n    export interface ScriptReferenceHost {\n        getCompilerOptions(): CompilerOptions;\n        getSourceFile(fileName: string): SourceFile | undefined;\n        getSourceFileByPath(path: Path): SourceFile | undefined;\n        getCurrentDirectory(): string;\n    }\n    export interface ParseConfigHost {\n        useCaseSensitiveFileNames: boolean;\n        readDirectory(rootDir: string, extensions: readonly string[], excludes: readonly string[] | undefined, includes: readonly string[], depth?: number): readonly string[];\n        /**\n         * Gets a value indicating whether the specified path exists and is a file.\n         * @param path The path to test.\n         */\n        fileExists(path: string): boolean;\n        readFile(path: string): string | undefined;\n        trace?(s: string): void;\n    }\n    /**\n     * Branded string for keeping track of when we\'ve turned an ambiguous path\n     * specified like "./blah" to an absolute path to an actual\n     * tsconfig file, e.g. "/root/blah/tsconfig.json"\n     */\n    export type ResolvedConfigFileName = string & {\n        _isResolvedConfigFileName: never;\n    };\n    export type WriteFileCallback = (fileName: string, data: string, writeByteOrderMark: boolean, onError?: (message: string) => void, sourceFiles?: readonly SourceFile[]) => void;\n    export class OperationCanceledException {\n    }\n    export interface CancellationToken {\n        isCancellationRequested(): boolean;\n        /** @throws OperationCanceledException if isCancellationRequested is true */\n        throwIfCancellationRequested(): void;\n    }\n    export interface Program extends ScriptReferenceHost {\n        getCurrentDirectory(): string;\n        /**\n         * Get a list of root file names that were passed to a \'createProgram\'\n         */\n        getRootFileNames(): readonly string[];\n        /**\n         * Get a list of files in the program\n         */\n        getSourceFiles(): readonly SourceFile[];\n        /**\n         * Emits the JavaScript and declaration files.  If targetSourceFile is not specified, then\n         * the JavaScript and declaration files will be produced for all the files in this program.\n         * If targetSourceFile is specified, then only the JavaScript and declaration for that\n         * specific file will be generated.\n         *\n         * If writeFile is not specified then the writeFile callback from the compiler host will be\n         * used for writing the JavaScript and declaration files.  Otherwise, the writeFile parameter\n         * will be invoked when writing the JavaScript and declaration files.\n         */\n        emit(targetSourceFile?: SourceFile, writeFile?: WriteFileCallback, cancellationToken?: CancellationToken, emitOnlyDtsFiles?: boolean, customTransformers?: CustomTransformers): EmitResult;\n        getOptionsDiagnostics(cancellationToken?: CancellationToken): readonly Diagnostic[];\n        getGlobalDiagnostics(cancellationToken?: CancellationToken): readonly Diagnostic[];\n        getSyntacticDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly DiagnosticWithLocation[];\n        /** The first time this is called, it will return global diagnostics (no location). */\n        getSemanticDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly Diagnostic[];\n        getDeclarationDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly DiagnosticWithLocation[];\n        getConfigFileParsingDiagnostics(): readonly Diagnostic[];\n        /**\n         * Gets a type checker that can be used to semantically analyze source files in the program.\n         */\n        getTypeChecker(): TypeChecker;\n        getNodeCount(): number;\n        getIdentifierCount(): number;\n        getSymbolCount(): number;\n        getTypeCount(): number;\n        getInstantiationCount(): number;\n        getRelationCacheSizes(): {\n            assignable: number;\n            identity: number;\n            subtype: number;\n            strictSubtype: number;\n        };\n        isSourceFileFromExternalLibrary(file: SourceFile): boolean;\n        isSourceFileDefaultLibrary(file: SourceFile): boolean;\n        getProjectReferences(): readonly ProjectReference[] | undefined;\n        getResolvedProjectReferences(): readonly (ResolvedProjectReference | undefined)[] | undefined;\n    }\n    export interface ResolvedProjectReference {\n        commandLine: ParsedCommandLine;\n        sourceFile: SourceFile;\n        references?: readonly (ResolvedProjectReference | undefined)[];\n    }\n    export type CustomTransformerFactory = (context: TransformationContext) => CustomTransformer;\n    export interface CustomTransformer {\n        transformSourceFile(node: SourceFile): SourceFile;\n        transformBundle(node: Bundle): Bundle;\n    }\n    export interface CustomTransformers {\n        /** Custom transformers to evaluate before built-in .js transformations. */\n        before?: (TransformerFactory<SourceFile> | CustomTransformerFactory)[];\n        /** Custom transformers to evaluate after built-in .js transformations. */\n        after?: (TransformerFactory<SourceFile> | CustomTransformerFactory)[];\n        /** Custom transformers to evaluate after built-in .d.ts transformations. */\n        afterDeclarations?: (TransformerFactory<Bundle | SourceFile> | CustomTransformerFactory)[];\n    }\n    export interface SourceMapSpan {\n        /** Line number in the .js file. */\n        emittedLine: number;\n        /** Column number in the .js file. */\n        emittedColumn: number;\n        /** Line number in the .ts file. */\n        sourceLine: number;\n        /** Column number in the .ts file. */\n        sourceColumn: number;\n        /** Optional name (index into names array) associated with this span. */\n        nameIndex?: number;\n        /** .ts file (index into sources array) associated with this span */\n        sourceIndex: number;\n    }\n    /** Return code used by getEmitOutput function to indicate status of the function */\n    export enum ExitStatus {\n        Success = 0,\n        DiagnosticsPresent_OutputsSkipped = 1,\n        DiagnosticsPresent_OutputsGenerated = 2,\n        InvalidProject_OutputsSkipped = 3,\n        ProjectReferenceCycle_OutputsSkipped = 4,\n        /** @deprecated Use ProjectReferenceCycle_OutputsSkipped instead. */\n        ProjectReferenceCycle_OutputsSkupped = 4\n    }\n    export interface EmitResult {\n        emitSkipped: boolean;\n        /** Contains declaration emit diagnostics */\n        diagnostics: readonly Diagnostic[];\n        emittedFiles?: string[];\n    }\n    export interface TypeChecker {\n        getTypeOfSymbolAtLocation(symbol: Symbol, node: Node): Type;\n        getDeclaredTypeOfSymbol(symbol: Symbol): Type;\n        getPropertiesOfType(type: Type): Symbol[];\n        getPropertyOfType(type: Type, propertyName: string): Symbol | undefined;\n        getPrivateIdentifierPropertyOfType(leftType: Type, name: string, location: Node): Symbol | undefined;\n        getIndexInfoOfType(type: Type, kind: IndexKind): IndexInfo | undefined;\n        getSignaturesOfType(type: Type, kind: SignatureKind): readonly Signature[];\n        getIndexTypeOfType(type: Type, kind: IndexKind): Type | undefined;\n        getBaseTypes(type: InterfaceType): BaseType[];\n        getBaseTypeOfLiteralType(type: Type): Type;\n        getWidenedType(type: Type): Type;\n        getReturnTypeOfSignature(signature: Signature): Type;\n        getNullableType(type: Type, flags: TypeFlags): Type;\n        getNonNullableType(type: Type): Type;\n        getTypeArguments(type: TypeReference): readonly Type[];\n        /** Note that the resulting nodes cannot be checked. */\n        typeToTypeNode(type: Type, enclosingDeclaration?: Node, flags?: NodeBuilderFlags): TypeNode | undefined;\n        /** Note that the resulting nodes cannot be checked. */\n        signatureToSignatureDeclaration(signature: Signature, kind: SyntaxKind, enclosingDeclaration?: Node, flags?: NodeBuilderFlags): (SignatureDeclaration & {\n            typeArguments?: NodeArray<TypeNode>;\n        }) | undefined;\n        /** Note that the resulting nodes cannot be checked. */\n        indexInfoToIndexSignatureDeclaration(indexInfo: IndexInfo, kind: IndexKind, enclosingDeclaration?: Node, flags?: NodeBuilderFlags): IndexSignatureDeclaration | undefined;\n        /** Note that the resulting nodes cannot be checked. */\n        symbolToEntityName(symbol: Symbol, meaning: SymbolFlags, enclosingDeclaration?: Node, flags?: NodeBuilderFlags): EntityName | undefined;\n        /** Note that the resulting nodes cannot be checked. */\n        symbolToExpression(symbol: Symbol, meaning: SymbolFlags, enclosingDeclaration?: Node, flags?: NodeBuilderFlags): Expression | undefined;\n        /** Note that the resulting nodes cannot be checked. */\n        symbolToTypeParameterDeclarations(symbol: Symbol, enclosingDeclaration?: Node, flags?: NodeBuilderFlags): NodeArray<TypeParameterDeclaration> | undefined;\n        /** Note that the resulting nodes cannot be checked. */\n        symbolToParameterDeclaration(symbol: Symbol, enclosingDeclaration?: Node, flags?: NodeBuilderFlags): ParameterDeclaration | undefined;\n        /** Note that the resulting nodes cannot be checked. */\n        typeParameterToDeclaration(parameter: TypeParameter, enclosingDeclaration?: Node, flags?: NodeBuilderFlags): TypeParameterDeclaration | undefined;\n        getSymbolsInScope(location: Node, meaning: SymbolFlags): Symbol[];\n        getSymbolAtLocation(node: Node): Symbol | undefined;\n        getSymbolsOfParameterPropertyDeclaration(parameter: ParameterDeclaration, parameterName: string): Symbol[];\n        /**\n         * The function returns the value (local variable) symbol of an identifier in the short-hand property assignment.\n         * This is necessary as an identifier in short-hand property assignment can contains two meaning: property name and property value.\n         */\n        getShorthandAssignmentValueSymbol(location: Node): Symbol | undefined;\n        getExportSpecifierLocalTargetSymbol(location: ExportSpecifier): Symbol | undefined;\n        /**\n         * If a symbol is a local symbol with an associated exported symbol, returns the exported symbol.\n         * Otherwise returns its input.\n         * For example, at `export type T = number;`:\n         *     - `getSymbolAtLocation` at the location `T` will return the exported symbol for `T`.\n         *     - But the result of `getSymbolsInScope` will contain the *local* symbol for `T`, not the exported symbol.\n         *     - Calling `getExportSymbolOfSymbol` on that local symbol will return the exported symbol.\n         */\n        getExportSymbolOfSymbol(symbol: Symbol): Symbol;\n        getPropertySymbolOfDestructuringAssignment(location: Identifier): Symbol | undefined;\n        getTypeOfAssignmentPattern(pattern: AssignmentPattern): Type;\n        getTypeAtLocation(node: Node): Type;\n        getTypeFromTypeNode(node: TypeNode): Type;\n        signatureToString(signature: Signature, enclosingDeclaration?: Node, flags?: TypeFormatFlags, kind?: SignatureKind): string;\n        typeToString(type: Type, enclosingDeclaration?: Node, flags?: TypeFormatFlags): string;\n        symbolToString(symbol: Symbol, enclosingDeclaration?: Node, meaning?: SymbolFlags, flags?: SymbolFormatFlags): string;\n        typePredicateToString(predicate: TypePredicate, enclosingDeclaration?: Node, flags?: TypeFormatFlags): string;\n        getFullyQualifiedName(symbol: Symbol): string;\n        getAugmentedPropertiesOfType(type: Type): Symbol[];\n        getRootSymbols(symbol: Symbol): readonly Symbol[];\n        getContextualType(node: Expression): Type | undefined;\n        /**\n         * returns unknownSignature in the case of an error.\n         * returns undefined if the node is not valid.\n         * @param argumentCount Apparent number of arguments, passed in case of a possibly incomplete call. This should come from an ArgumentListInfo. See `signatureHelp.ts`.\n         */\n        getResolvedSignature(node: CallLikeExpression, candidatesOutArray?: Signature[], argumentCount?: number): Signature | undefined;\n        getSignatureFromDeclaration(declaration: SignatureDeclaration): Signature | undefined;\n        isImplementationOfOverload(node: SignatureDeclaration): boolean | undefined;\n        isUndefinedSymbol(symbol: Symbol): boolean;\n        isArgumentsSymbol(symbol: Symbol): boolean;\n        isUnknownSymbol(symbol: Symbol): boolean;\n        getConstantValue(node: EnumMember | PropertyAccessExpression | ElementAccessExpression): string | number | undefined;\n        isValidPropertyAccess(node: PropertyAccessExpression | QualifiedName | ImportTypeNode, propertyName: string): boolean;\n        /** Follow all aliases to get the original symbol. */\n        getAliasedSymbol(symbol: Symbol): Symbol;\n        getExportsOfModule(moduleSymbol: Symbol): Symbol[];\n        getJsxIntrinsicTagNamesAt(location: Node): Symbol[];\n        isOptionalParameter(node: ParameterDeclaration): boolean;\n        getAmbientModules(): Symbol[];\n        tryGetMemberInModuleExports(memberName: string, moduleSymbol: Symbol): Symbol | undefined;\n        getApparentType(type: Type): Type;\n        getBaseConstraintOfType(type: Type): Type | undefined;\n        getDefaultFromTypeParameter(type: Type): Type | undefined;\n        /**\n         * Depending on the operation performed, it may be appropriate to throw away the checker\n         * if the cancellation token is triggered. Typically, if it is used for error checking\n         * and the operation is cancelled, then it should be discarded, otherwise it is safe to keep.\n         */\n        runWithCancellationToken<T>(token: CancellationToken, cb: (checker: TypeChecker) => T): T;\n    }\n    export enum NodeBuilderFlags {\n        None = 0,\n        NoTruncation = 1,\n        WriteArrayAsGenericType = 2,\n        GenerateNamesForShadowedTypeParams = 4,\n        UseStructuralFallback = 8,\n        ForbidIndexedAccessSymbolReferences = 16,\n        WriteTypeArgumentsOfSignature = 32,\n        UseFullyQualifiedType = 64,\n        UseOnlyExternalAliasing = 128,\n        SuppressAnyReturnType = 256,\n        WriteTypeParametersInQualifiedName = 512,\n        MultilineObjectLiterals = 1024,\n        WriteClassExpressionAsTypeLiteral = 2048,\n        UseTypeOfFunction = 4096,\n        OmitParameterModifiers = 8192,\n        UseAliasDefinedOutsideCurrentScope = 16384,\n        UseSingleQuotesForStringLiteralType = 268435456,\n        NoTypeReduction = 536870912,\n        AllowThisInObjectLiteral = 32768,\n        AllowQualifedNameInPlaceOfIdentifier = 65536,\n        AllowAnonymousIdentifier = 131072,\n        AllowEmptyUnionOrIntersection = 262144,\n        AllowEmptyTuple = 524288,\n        AllowUniqueESSymbolType = 1048576,\n        AllowEmptyIndexInfoType = 2097152,\n        AllowNodeModulesRelativePaths = 67108864,\n        IgnoreErrors = 70221824,\n        InObjectTypeLiteral = 4194304,\n        InTypeAlias = 8388608,\n        InInitialEntityName = 16777216,\n        InReverseMappedType = 33554432\n    }\n    export enum TypeFormatFlags {\n        None = 0,\n        NoTruncation = 1,\n        WriteArrayAsGenericType = 2,\n        UseStructuralFallback = 8,\n        WriteTypeArgumentsOfSignature = 32,\n        UseFullyQualifiedType = 64,\n        SuppressAnyReturnType = 256,\n        MultilineObjectLiterals = 1024,\n        WriteClassExpressionAsTypeLiteral = 2048,\n        UseTypeOfFunction = 4096,\n        OmitParameterModifiers = 8192,\n        UseAliasDefinedOutsideCurrentScope = 16384,\n        UseSingleQuotesForStringLiteralType = 268435456,\n        NoTypeReduction = 536870912,\n        AllowUniqueESSymbolType = 1048576,\n        AddUndefined = 131072,\n        WriteArrowStyleSignature = 262144,\n        InArrayType = 524288,\n        InElementType = 2097152,\n        InFirstTypeArgument = 4194304,\n        InTypeAlias = 8388608,\n        /** @deprecated */ WriteOwnNameForAnyLike = 0,\n        NodeBuilderFlagsMask = 814775659\n    }\n    export enum SymbolFormatFlags {\n        None = 0,\n        WriteTypeParametersOrArguments = 1,\n        UseOnlyExternalAliasing = 2,\n        AllowAnyNodeKind = 4,\n        UseAliasDefinedOutsideCurrentScope = 8,\n    }\n    export enum TypePredicateKind {\n        This = 0,\n        Identifier = 1,\n        AssertsThis = 2,\n        AssertsIdentifier = 3\n    }\n    export interface TypePredicateBase {\n        kind: TypePredicateKind;\n        type: Type | undefined;\n    }\n    export interface ThisTypePredicate extends TypePredicateBase {\n        kind: TypePredicateKind.This;\n        parameterName: undefined;\n        parameterIndex: undefined;\n        type: Type;\n    }\n    export interface IdentifierTypePredicate extends TypePredicateBase {\n        kind: TypePredicateKind.Identifier;\n        parameterName: string;\n        parameterIndex: number;\n        type: Type;\n    }\n    export interface AssertsThisTypePredicate extends TypePredicateBase {\n        kind: TypePredicateKind.AssertsThis;\n        parameterName: undefined;\n        parameterIndex: undefined;\n        type: Type | undefined;\n    }\n    export interface AssertsIdentifierTypePredicate extends TypePredicateBase {\n        kind: TypePredicateKind.AssertsIdentifier;\n        parameterName: string;\n        parameterIndex: number;\n        type: Type | undefined;\n    }\n    export type TypePredicate = ThisTypePredicate | IdentifierTypePredicate | AssertsThisTypePredicate | AssertsIdentifierTypePredicate;\n    export enum SymbolFlags {\n        None = 0,\n        FunctionScopedVariable = 1,\n        BlockScopedVariable = 2,\n        Property = 4,\n        EnumMember = 8,\n        Function = 16,\n        Class = 32,\n        Interface = 64,\n        ConstEnum = 128,\n        RegularEnum = 256,\n        ValueModule = 512,\n        NamespaceModule = 1024,\n        TypeLiteral = 2048,\n        ObjectLiteral = 4096,\n        Method = 8192,\n        Constructor = 16384,\n        GetAccessor = 32768,\n        SetAccessor = 65536,\n        Signature = 131072,\n        TypeParameter = 262144,\n        TypeAlias = 524288,\n        ExportValue = 1048576,\n        Alias = 2097152,\n        Prototype = 4194304,\n        ExportStar = 8388608,\n        Optional = 16777216,\n        Transient = 33554432,\n        Assignment = 67108864,\n        ModuleExports = 134217728,\n        Enum = 384,\n        Variable = 3,\n        Value = 111551,\n        Type = 788968,\n        Namespace = 1920,\n        Module = 1536,\n        Accessor = 98304,\n        FunctionScopedVariableExcludes = 111550,\n        BlockScopedVariableExcludes = 111551,\n        ParameterExcludes = 111551,\n        PropertyExcludes = 0,\n        EnumMemberExcludes = 900095,\n        FunctionExcludes = 110991,\n        ClassExcludes = 899503,\n        InterfaceExcludes = 788872,\n        RegularEnumExcludes = 899327,\n        ConstEnumExcludes = 899967,\n        ValueModuleExcludes = 110735,\n        NamespaceModuleExcludes = 0,\n        MethodExcludes = 103359,\n        GetAccessorExcludes = 46015,\n        SetAccessorExcludes = 78783,\n        TypeParameterExcludes = 526824,\n        TypeAliasExcludes = 788968,\n        AliasExcludes = 2097152,\n        ModuleMember = 2623475,\n        ExportHasLocal = 944,\n        BlockScoped = 418,\n        PropertyOrAccessor = 98308,\n        ClassMember = 106500,\n    }\n    export interface Symbol {\n        flags: SymbolFlags;\n        escapedName: __String;\n        declarations: Declaration[];\n        valueDeclaration: Declaration;\n        members?: SymbolTable;\n        exports?: SymbolTable;\n        globalExports?: SymbolTable;\n    }\n    export enum InternalSymbolName {\n        Call = "__call",\n        Constructor = "__constructor",\n        New = "__new",\n        Index = "__index",\n        ExportStar = "__export",\n        Global = "__global",\n        Missing = "__missing",\n        Type = "__type",\n        Object = "__object",\n        JSXAttributes = "__jsxAttributes",\n        Class = "__class",\n        Function = "__function",\n        Computed = "__computed",\n        Resolving = "__resolving__",\n        ExportEquals = "export=",\n        Default = "default",\n        This = "this"\n    }\n    /**\n     * This represents a string whose leading underscore have been escaped by adding extra leading underscores.\n     * The shape of this brand is rather unique compared to others we\'ve used.\n     * Instead of just an intersection of a string and an object, it is that union-ed\n     * with an intersection of void and an object. This makes it wholly incompatible\n     * with a normal string (which is good, it cannot be misused on assignment or on usage),\n     * while still being comparable with a normal string via === (also good) and castable from a string.\n     */\n    export type __String = (string & {\n        __escapedIdentifier: void;\n    }) | (void & {\n        __escapedIdentifier: void;\n    }) | InternalSymbolName;\n    /** ReadonlyMap where keys are `__String`s. */\n    export interface ReadonlyUnderscoreEscapedMap<T> {\n        get(key: __String): T | undefined;\n        has(key: __String): boolean;\n        forEach(action: (value: T, key: __String) => void): void;\n        readonly size: number;\n        keys(): Iterator<__String>;\n        values(): Iterator<T>;\n        entries(): Iterator<[__String, T]>;\n    }\n    /** Map where keys are `__String`s. */\n    export interface UnderscoreEscapedMap<T> extends ReadonlyUnderscoreEscapedMap<T> {\n        set(key: __String, value: T): this;\n        delete(key: __String): boolean;\n        clear(): void;\n    }\n    /** SymbolTable based on ES6 Map interface. */\n    export type SymbolTable = UnderscoreEscapedMap<Symbol>;\n    export enum TypeFlags {\n        Any = 1,\n        Unknown = 2,\n        String = 4,\n        Number = 8,\n        Boolean = 16,\n        Enum = 32,\n        BigInt = 64,\n        StringLiteral = 128,\n        NumberLiteral = 256,\n        BooleanLiteral = 512,\n        EnumLiteral = 1024,\n        BigIntLiteral = 2048,\n        ESSymbol = 4096,\n        UniqueESSymbol = 8192,\n        Void = 16384,\n        Undefined = 32768,\n        Null = 65536,\n        Never = 131072,\n        TypeParameter = 262144,\n        Object = 524288,\n        Union = 1048576,\n        Intersection = 2097152,\n        Index = 4194304,\n        IndexedAccess = 8388608,\n        Conditional = 16777216,\n        Substitution = 33554432,\n        NonPrimitive = 67108864,\n        Literal = 2944,\n        Unit = 109440,\n        StringOrNumberLiteral = 384,\n        PossiblyFalsy = 117724,\n        StringLike = 132,\n        NumberLike = 296,\n        BigIntLike = 2112,\n        BooleanLike = 528,\n        EnumLike = 1056,\n        ESSymbolLike = 12288,\n        VoidLike = 49152,\n        UnionOrIntersection = 3145728,\n        StructuredType = 3670016,\n        TypeVariable = 8650752,\n        InstantiableNonPrimitive = 58982400,\n        InstantiablePrimitive = 4194304,\n        Instantiable = 63176704,\n        StructuredOrInstantiable = 66846720,\n        Narrowable = 133970943,\n        NotUnionOrUnit = 67637251,\n    }\n    export type DestructuringPattern = BindingPattern | ObjectLiteralExpression | ArrayLiteralExpression;\n    export interface Type {\n        flags: TypeFlags;\n        symbol: Symbol;\n        pattern?: DestructuringPattern;\n        aliasSymbol?: Symbol;\n        aliasTypeArguments?: readonly Type[];\n    }\n    export interface LiteralType extends Type {\n        value: string | number | PseudoBigInt;\n        freshType: LiteralType;\n        regularType: LiteralType;\n    }\n    export interface UniqueESSymbolType extends Type {\n        symbol: Symbol;\n        escapedName: __String;\n    }\n    export interface StringLiteralType extends LiteralType {\n        value: string;\n    }\n    export interface NumberLiteralType extends LiteralType {\n        value: number;\n    }\n    export interface BigIntLiteralType extends LiteralType {\n        value: PseudoBigInt;\n    }\n    export interface EnumType extends Type {\n    }\n    export enum ObjectFlags {\n        Class = 1,\n        Interface = 2,\n        Reference = 4,\n        Tuple = 8,\n        Anonymous = 16,\n        Mapped = 32,\n        Instantiated = 64,\n        ObjectLiteral = 128,\n        EvolvingArray = 256,\n        ObjectLiteralPatternWithComputedProperties = 512,\n        ContainsSpread = 1024,\n        ReverseMapped = 2048,\n        JsxAttributes = 4096,\n        MarkerType = 8192,\n        JSLiteral = 16384,\n        FreshLiteral = 32768,\n        ArrayLiteral = 65536,\n        ObjectRestType = 131072,\n        ClassOrInterface = 3,\n    }\n    export interface ObjectType extends Type {\n        objectFlags: ObjectFlags;\n    }\n    /** Class and interface types (ObjectFlags.Class and ObjectFlags.Interface). */\n    export interface InterfaceType extends ObjectType {\n        typeParameters: TypeParameter[] | undefined;\n        outerTypeParameters: TypeParameter[] | undefined;\n        localTypeParameters: TypeParameter[] | undefined;\n        thisType: TypeParameter | undefined;\n    }\n    export type BaseType = ObjectType | IntersectionType | TypeVariable;\n    export interface InterfaceTypeWithDeclaredMembers extends InterfaceType {\n        declaredProperties: Symbol[];\n        declaredCallSignatures: Signature[];\n        declaredConstructSignatures: Signature[];\n        declaredStringIndexInfo?: IndexInfo;\n        declaredNumberIndexInfo?: IndexInfo;\n    }\n    /**\n     * Type references (ObjectFlags.Reference). When a class or interface has type parameters or\n     * a "this" type, references to the class or interface are made using type references. The\n     * typeArguments property specifies the types to substitute for the type parameters of the\n     * class or interface and optionally includes an extra element that specifies the type to\n     * substitute for "this" in the resulting instantiation. When no extra argument is present,\n     * the type reference itself is substituted for "this". The typeArguments property is undefined\n     * if the class or interface has no type parameters and the reference isn\'t specifying an\n     * explicit "this" argument.\n     */\n    export interface TypeReference extends ObjectType {\n        target: GenericType;\n        node?: TypeReferenceNode | ArrayTypeNode | TupleTypeNode;\n    }\n    export interface DeferredTypeReference extends TypeReference {\n    }\n    export interface GenericType extends InterfaceType, TypeReference {\n    }\n    export interface TupleType extends GenericType {\n        minLength: number;\n        hasRestElement: boolean;\n        readonly: boolean;\n        associatedNames?: __String[];\n    }\n    export interface TupleTypeReference extends TypeReference {\n        target: TupleType;\n    }\n    export interface UnionOrIntersectionType extends Type {\n        types: Type[];\n    }\n    export interface UnionType extends UnionOrIntersectionType {\n    }\n    export interface IntersectionType extends UnionOrIntersectionType {\n    }\n    export type StructuredType = ObjectType | UnionType | IntersectionType;\n    export interface EvolvingArrayType extends ObjectType {\n        elementType: Type;\n        finalArrayType?: Type;\n    }\n    export interface InstantiableType extends Type {\n    }\n    export interface TypeParameter extends InstantiableType {\n    }\n    export interface IndexedAccessType extends InstantiableType {\n        objectType: Type;\n        indexType: Type;\n        constraint?: Type;\n        simplifiedForReading?: Type;\n        simplifiedForWriting?: Type;\n    }\n    export type TypeVariable = TypeParameter | IndexedAccessType;\n    export interface IndexType extends InstantiableType {\n        type: InstantiableType | UnionOrIntersectionType;\n    }\n    export interface ConditionalRoot {\n        node: ConditionalTypeNode;\n        checkType: Type;\n        extendsType: Type;\n        trueType: Type;\n        falseType: Type;\n        isDistributive: boolean;\n        inferTypeParameters?: TypeParameter[];\n        outerTypeParameters?: TypeParameter[];\n        instantiations?: Map<Type>;\n        aliasSymbol?: Symbol;\n        aliasTypeArguments?: Type[];\n    }\n    export interface ConditionalType extends InstantiableType {\n        root: ConditionalRoot;\n        checkType: Type;\n        extendsType: Type;\n        resolvedTrueType: Type;\n        resolvedFalseType: Type;\n    }\n    export interface SubstitutionType extends InstantiableType {\n        baseType: Type;\n        substitute: Type;\n    }\n    export enum SignatureKind {\n        Call = 0,\n        Construct = 1\n    }\n    export interface Signature {\n        declaration?: SignatureDeclaration | JSDocSignature;\n        typeParameters?: readonly TypeParameter[];\n        parameters: readonly Symbol[];\n    }\n    export enum IndexKind {\n        String = 0,\n        Number = 1\n    }\n    export interface IndexInfo {\n        type: Type;\n        isReadonly: boolean;\n        declaration?: IndexSignatureDeclaration;\n    }\n    export enum InferencePriority {\n        NakedTypeVariable = 1,\n        HomomorphicMappedType = 2,\n        PartialHomomorphicMappedType = 4,\n        MappedTypeConstraint = 8,\n        ContravariantConditional = 16,\n        ReturnType = 32,\n        LiteralKeyof = 64,\n        NoConstraints = 128,\n        AlwaysStrict = 256,\n        MaxValue = 512,\n        PriorityImpliesCombination = 104,\n        Circularity = -1\n    }\n    /** @deprecated Use FileExtensionInfo instead. */\n    export type JsFileExtensionInfo = FileExtensionInfo;\n    export interface FileExtensionInfo {\n        extension: string;\n        isMixedContent: boolean;\n        scriptKind?: ScriptKind;\n    }\n    export interface DiagnosticMessage {\n        key: string;\n        category: DiagnosticCategory;\n        code: number;\n        message: string;\n        reportsUnnecessary?: {};\n    }\n    /**\n     * A linked list of formatted diagnostic messages to be used as part of a multiline message.\n     * It is built from the bottom up, leaving the head to be the "main" diagnostic.\n     * While it seems that DiagnosticMessageChain is structurally similar to DiagnosticMessage,\n     * the difference is that messages are all preformatted in DMC.\n     */\n    export interface DiagnosticMessageChain {\n        messageText: string;\n        category: DiagnosticCategory;\n        code: number;\n        next?: DiagnosticMessageChain[];\n    }\n    export interface Diagnostic extends DiagnosticRelatedInformation {\n        /** May store more in future. For now, this will simply be `true` to indicate when a diagnostic is an unused-identifier diagnostic. */\n        reportsUnnecessary?: {};\n        source?: string;\n        relatedInformation?: DiagnosticRelatedInformation[];\n    }\n    export interface DiagnosticRelatedInformation {\n        category: DiagnosticCategory;\n        code: number;\n        file: SourceFile | undefined;\n        start: number | undefined;\n        length: number | undefined;\n        messageText: string | DiagnosticMessageChain;\n    }\n    export interface DiagnosticWithLocation extends Diagnostic {\n        file: SourceFile;\n        start: number;\n        length: number;\n    }\n    export enum DiagnosticCategory {\n        Warning = 0,\n        Error = 1,\n        Suggestion = 2,\n        Message = 3\n    }\n    export enum ModuleResolutionKind {\n        Classic = 1,\n        NodeJs = 2\n    }\n    export interface PluginImport {\n        name: string;\n    }\n    export interface ProjectReference {\n        /** A normalized path on disk */\n        path: string;\n        /** The path as the user originally wrote it */\n        originalPath?: string;\n        /** True if the output of this reference should be prepended to the output of this project. Only valid for --outFile compilations */\n        prepend?: boolean;\n        /** True if it is intended that this reference form a circularity */\n        circular?: boolean;\n    }\n    export enum WatchFileKind {\n        FixedPollingInterval = 0,\n        PriorityPollingInterval = 1,\n        DynamicPriorityPolling = 2,\n        UseFsEvents = 3,\n        UseFsEventsOnParentDirectory = 4\n    }\n    export enum WatchDirectoryKind {\n        UseFsEvents = 0,\n        FixedPollingInterval = 1,\n        DynamicPriorityPolling = 2\n    }\n    export enum PollingWatchKind {\n        FixedInterval = 0,\n        PriorityInterval = 1,\n        DynamicPriority = 2\n    }\n    export type CompilerOptionsValue = string | number | boolean | (string | number)[] | string[] | MapLike<string[]> | PluginImport[] | ProjectReference[] | null | undefined;\n    export interface CompilerOptions {\n        allowJs?: boolean;\n        allowSyntheticDefaultImports?: boolean;\n        allowUmdGlobalAccess?: boolean;\n        allowUnreachableCode?: boolean;\n        allowUnusedLabels?: boolean;\n        alwaysStrict?: boolean;\n        baseUrl?: string;\n        charset?: string;\n        checkJs?: boolean;\n        declaration?: boolean;\n        declarationMap?: boolean;\n        emitDeclarationOnly?: boolean;\n        declarationDir?: string;\n        disableSizeLimit?: boolean;\n        disableSourceOfProjectReferenceRedirect?: boolean;\n        disableSolutionSearching?: boolean;\n        downlevelIteration?: boolean;\n        emitBOM?: boolean;\n        emitDecoratorMetadata?: boolean;\n        experimentalDecorators?: boolean;\n        forceConsistentCasingInFileNames?: boolean;\n        importHelpers?: boolean;\n        importsNotUsedAsValues?: ImportsNotUsedAsValues;\n        inlineSourceMap?: boolean;\n        inlineSources?: boolean;\n        isolatedModules?: boolean;\n        jsx?: JsxEmit;\n        keyofStringsOnly?: boolean;\n        lib?: string[];\n        locale?: string;\n        mapRoot?: string;\n        maxNodeModuleJsDepth?: number;\n        module?: ModuleKind;\n        moduleResolution?: ModuleResolutionKind;\n        newLine?: NewLineKind;\n        noEmit?: boolean;\n        noEmitHelpers?: boolean;\n        noEmitOnError?: boolean;\n        noErrorTruncation?: boolean;\n        noFallthroughCasesInSwitch?: boolean;\n        noImplicitAny?: boolean;\n        noImplicitReturns?: boolean;\n        noImplicitThis?: boolean;\n        noStrictGenericChecks?: boolean;\n        noUnusedLocals?: boolean;\n        noUnusedParameters?: boolean;\n        noImplicitUseStrict?: boolean;\n        assumeChangesOnlyAffectDirectDependencies?: boolean;\n        noLib?: boolean;\n        noResolve?: boolean;\n        out?: string;\n        outDir?: string;\n        outFile?: string;\n        paths?: MapLike<string[]>;\n        preserveConstEnums?: boolean;\n        preserveSymlinks?: boolean;\n        project?: string;\n        reactNamespace?: string;\n        jsxFactory?: string;\n        composite?: boolean;\n        incremental?: boolean;\n        tsBuildInfoFile?: string;\n        removeComments?: boolean;\n        rootDir?: string;\n        rootDirs?: string[];\n        skipLibCheck?: boolean;\n        skipDefaultLibCheck?: boolean;\n        sourceMap?: boolean;\n        sourceRoot?: string;\n        strict?: boolean;\n        strictFunctionTypes?: boolean;\n        strictBindCallApply?: boolean;\n        strictNullChecks?: boolean;\n        strictPropertyInitialization?: boolean;\n        stripInternal?: boolean;\n        suppressExcessPropertyErrors?: boolean;\n        suppressImplicitAnyIndexErrors?: boolean;\n        target?: ScriptTarget;\n        traceResolution?: boolean;\n        resolveJsonModule?: boolean;\n        types?: string[];\n        /** Paths used to compute primary types search locations */\n        typeRoots?: string[];\n        esModuleInterop?: boolean;\n        useDefineForClassFields?: boolean;\n        [option: string]: CompilerOptionsValue | TsConfigSourceFile | undefined;\n    }\n    export interface WatchOptions {\n        watchFile?: WatchFileKind;\n        watchDirectory?: WatchDirectoryKind;\n        fallbackPolling?: PollingWatchKind;\n        synchronousWatchDirectory?: boolean;\n        [option: string]: CompilerOptionsValue | undefined;\n    }\n    export interface TypeAcquisition {\n        /**\n         * @deprecated typingOptions.enableAutoDiscovery\n         * Use typeAcquisition.enable instead.\n         */\n        enableAutoDiscovery?: boolean;\n        enable?: boolean;\n        include?: string[];\n        exclude?: string[];\n        [option: string]: string[] | boolean | undefined;\n    }\n    export enum ModuleKind {\n        None = 0,\n        CommonJS = 1,\n        AMD = 2,\n        UMD = 3,\n        System = 4,\n        ES2015 = 5,\n        ES2020 = 6,\n        ESNext = 99\n    }\n    export enum JsxEmit {\n        None = 0,\n        Preserve = 1,\n        React = 2,\n        ReactNative = 3\n    }\n    export enum ImportsNotUsedAsValues {\n        Remove = 0,\n        Preserve = 1,\n        Error = 2\n    }\n    export enum NewLineKind {\n        CarriageReturnLineFeed = 0,\n        LineFeed = 1\n    }\n    export interface LineAndCharacter {\n        /** 0-based. */\n        line: number;\n        character: number;\n    }\n    export enum ScriptKind {\n        Unknown = 0,\n        JS = 1,\n        JSX = 2,\n        TS = 3,\n        TSX = 4,\n        External = 5,\n        JSON = 6,\n        /**\n         * Used on extensions that doesn\'t define the ScriptKind but the content defines it.\n         * Deferred extensions are going to be included in all project contexts.\n         */\n        Deferred = 7\n    }\n    export enum ScriptTarget {\n        ES3 = 0,\n        ES5 = 1,\n        ES2015 = 2,\n        ES2016 = 3,\n        ES2017 = 4,\n        ES2018 = 5,\n        ES2019 = 6,\n        ES2020 = 7,\n        ESNext = 99,\n        JSON = 100,\n        Latest = 99\n    }\n    export enum LanguageVariant {\n        Standard = 0,\n        JSX = 1\n    }\n    /** Either a parsed command line or a parsed tsconfig.json */\n    export interface ParsedCommandLine {\n        options: CompilerOptions;\n        typeAcquisition?: TypeAcquisition;\n        fileNames: string[];\n        projectReferences?: readonly ProjectReference[];\n        watchOptions?: WatchOptions;\n        raw?: any;\n        errors: Diagnostic[];\n        wildcardDirectories?: MapLike<WatchDirectoryFlags>;\n        compileOnSave?: boolean;\n    }\n    export enum WatchDirectoryFlags {\n        None = 0,\n        Recursive = 1\n    }\n    export interface ExpandResult {\n        fileNames: string[];\n        wildcardDirectories: MapLike<WatchDirectoryFlags>;\n    }\n    export interface CreateProgramOptions {\n        rootNames: readonly string[];\n        options: CompilerOptions;\n        projectReferences?: readonly ProjectReference[];\n        host?: CompilerHost;\n        oldProgram?: Program;\n        configFileParsingDiagnostics?: readonly Diagnostic[];\n    }\n    export interface ModuleResolutionHost {\n        fileExists(fileName: string): boolean;\n        readFile(fileName: string): string | undefined;\n        trace?(s: string): void;\n        directoryExists?(directoryName: string): boolean;\n        /**\n         * Resolve a symbolic link.\n         * @see https://nodejs.org/api/fs.html#fs_fs_realpathsync_path_options\n         */\n        realpath?(path: string): string;\n        getCurrentDirectory?(): string;\n        getDirectories?(path: string): string[];\n    }\n    /**\n     * Represents the result of module resolution.\n     * Module resolution will pick up tsx/jsx/js files even if \'--jsx\' and \'--allowJs\' are turned off.\n     * The Program will then filter results based on these flags.\n     *\n     * Prefer to return a `ResolvedModuleFull` so that the file type does not have to be inferred.\n     */\n    export interface ResolvedModule {\n        /** Path of the file the module was resolved to. */\n        resolvedFileName: string;\n        /** True if `resolvedFileName` comes from `node_modules`. */\n        isExternalLibraryImport?: boolean;\n    }\n    /**\n     * ResolvedModule with an explicitly provided `extension` property.\n     * Prefer this over `ResolvedModule`.\n     * If changing this, remember to change `moduleResolutionIsEqualTo`.\n     */\n    export interface ResolvedModuleFull extends ResolvedModule {\n        /**\n         * Extension of resolvedFileName. This must match what\'s at the end of resolvedFileName.\n         * This is optional for backwards-compatibility, but will be added if not provided.\n         */\n        extension: Extension;\n        packageId?: PackageId;\n    }\n    /**\n     * Unique identifier with a package name and version.\n     * If changing this, remember to change `packageIdIsEqual`.\n     */\n    export interface PackageId {\n        /**\n         * Name of the package.\n         * Should not include `@types`.\n         * If accessing a non-index file, this should include its name e.g. "foo/bar".\n         */\n        name: string;\n        /**\n         * Name of a submodule within this package.\n         * May be "".\n         */\n        subModuleName: string;\n        /** Version of the package, e.g. "1.2.3" */\n        version: string;\n    }\n    export enum Extension {\n        Ts = ".ts",\n        Tsx = ".tsx",\n        Dts = ".d.ts",\n        Js = ".js",\n        Jsx = ".jsx",\n        Json = ".json",\n        TsBuildInfo = ".tsbuildinfo"\n    }\n    export interface ResolvedModuleWithFailedLookupLocations {\n        readonly resolvedModule: ResolvedModuleFull | undefined;\n    }\n    export interface ResolvedTypeReferenceDirective {\n        primary: boolean;\n        resolvedFileName: string | undefined;\n        packageId?: PackageId;\n        /** True if `resolvedFileName` comes from `node_modules`. */\n        isExternalLibraryImport?: boolean;\n    }\n    export interface ResolvedTypeReferenceDirectiveWithFailedLookupLocations {\n        readonly resolvedTypeReferenceDirective: ResolvedTypeReferenceDirective | undefined;\n        readonly failedLookupLocations: string[];\n    }\n    export interface CompilerHost extends ModuleResolutionHost {\n        getSourceFile(fileName: string, languageVersion: ScriptTarget, onError?: (message: string) => void, shouldCreateNewSourceFile?: boolean): SourceFile | undefined;\n        getSourceFileByPath?(fileName: string, path: Path, languageVersion: ScriptTarget, onError?: (message: string) => void, shouldCreateNewSourceFile?: boolean): SourceFile | undefined;\n        getCancellationToken?(): CancellationToken;\n        getDefaultLibFileName(options: CompilerOptions): string;\n        getDefaultLibLocation?(): string;\n        writeFile: WriteFileCallback;\n        getCurrentDirectory(): string;\n        getCanonicalFileName(fileName: string): string;\n        useCaseSensitiveFileNames(): boolean;\n        getNewLine(): string;\n        readDirectory?(rootDir: string, extensions: readonly string[], excludes: readonly string[] | undefined, includes: readonly string[], depth?: number): string[];\n        resolveModuleNames?(moduleNames: string[], containingFile: string, reusedNames: string[] | undefined, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions): (ResolvedModule | undefined)[];\n        /**\n         * This method is a companion for \'resolveModuleNames\' and is used to resolve \'types\' references to actual type declaration files\n         */\n        resolveTypeReferenceDirectives?(typeReferenceDirectiveNames: string[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions): (ResolvedTypeReferenceDirective | undefined)[];\n        getEnvironmentVariable?(name: string): string | undefined;\n        createHash?(data: string): string;\n        getParsedCommandLine?(fileName: string): ParsedCommandLine | undefined;\n    }\n    export interface SourceMapRange extends TextRange {\n        source?: SourceMapSource;\n    }\n    export interface SourceMapSource {\n        fileName: string;\n        text: string;\n        skipTrivia?: (pos: number) => number;\n    }\n    export enum EmitFlags {\n        None = 0,\n        SingleLine = 1,\n        AdviseOnEmitNode = 2,\n        NoSubstitution = 4,\n        CapturesThis = 8,\n        NoLeadingSourceMap = 16,\n        NoTrailingSourceMap = 32,\n        NoSourceMap = 48,\n        NoNestedSourceMaps = 64,\n        NoTokenLeadingSourceMaps = 128,\n        NoTokenTrailingSourceMaps = 256,\n        NoTokenSourceMaps = 384,\n        NoLeadingComments = 512,\n        NoTrailingComments = 1024,\n        NoComments = 1536,\n        NoNestedComments = 2048,\n        HelperName = 4096,\n        ExportName = 8192,\n        LocalName = 16384,\n        InternalName = 32768,\n        Indented = 65536,\n        NoIndentation = 131072,\n        AsyncFunctionBody = 262144,\n        ReuseTempVariableScope = 524288,\n        CustomPrologue = 1048576,\n        NoHoisting = 2097152,\n        HasEndOfDeclarationMarker = 4194304,\n        Iterator = 8388608,\n        NoAsciiEscaping = 16777216,\n    }\n    export interface EmitHelper {\n        readonly name: string;\n        readonly scoped: boolean;\n        readonly text: string | ((node: EmitHelperUniqueNameCallback) => string);\n        readonly priority?: number;\n        readonly dependencies?: EmitHelper[];\n    }\n    export interface UnscopedEmitHelper extends EmitHelper {\n        readonly scoped: false;\n        readonly text: string;\n    }\n    export type EmitHelperUniqueNameCallback = (name: string) => string;\n    export enum EmitHint {\n        SourceFile = 0,\n        Expression = 1,\n        IdentifierName = 2,\n        MappedTypeParameter = 3,\n        Unspecified = 4,\n        EmbeddedStatement = 5,\n        JsxAttributeValue = 6\n    }\n    export interface TransformationContext {\n        /** Gets the compiler options supplied to the transformer. */\n        getCompilerOptions(): CompilerOptions;\n        /** Starts a new lexical environment. */\n        startLexicalEnvironment(): void;\n        /** Suspends the current lexical environment, usually after visiting a parameter list. */\n        suspendLexicalEnvironment(): void;\n        /** Resumes a suspended lexical environment, usually before visiting a function body. */\n        resumeLexicalEnvironment(): void;\n        /** Ends a lexical environment, returning any declarations. */\n        endLexicalEnvironment(): Statement[] | undefined;\n        /** Hoists a function declaration to the containing scope. */\n        hoistFunctionDeclaration(node: FunctionDeclaration): void;\n        /** Hoists a variable declaration to the containing scope. */\n        hoistVariableDeclaration(node: Identifier): void;\n        /** Records a request for a non-scoped emit helper in the current context. */\n        requestEmitHelper(helper: EmitHelper): void;\n        /** Gets and resets the requested non-scoped emit helpers. */\n        readEmitHelpers(): EmitHelper[] | undefined;\n        /** Enables expression substitutions in the pretty printer for the provided SyntaxKind. */\n        enableSubstitution(kind: SyntaxKind): void;\n        /** Determines whether expression substitutions are enabled for the provided node. */\n        isSubstitutionEnabled(node: Node): boolean;\n        /**\n         * Hook used by transformers to substitute expressions just before they\n         * are emitted by the pretty printer.\n         *\n         * NOTE: Transformation hooks should only be modified during `Transformer` initialization,\n         * before returning the `NodeTransformer` callback.\n         */\n        onSubstituteNode: (hint: EmitHint, node: Node) => Node;\n        /**\n         * Enables before/after emit notifications in the pretty printer for the provided\n         * SyntaxKind.\n         */\n        enableEmitNotification(kind: SyntaxKind): void;\n        /**\n         * Determines whether before/after emit notifications should be raised in the pretty\n         * printer when it emits a node.\n         */\n        isEmitNotificationEnabled(node: Node): boolean;\n        /**\n         * Hook used to allow transformers to capture state before or after\n         * the printer emits a node.\n         *\n         * NOTE: Transformation hooks should only be modified during `Transformer` initialization,\n         * before returning the `NodeTransformer` callback.\n         */\n        onEmitNode: (hint: EmitHint, node: Node, emitCallback: (hint: EmitHint, node: Node) => void) => void;\n    }\n    export interface TransformationResult<T extends Node> {\n        /** Gets the transformed source files. */\n        transformed: T[];\n        /** Gets diagnostics for the transformation. */\n        diagnostics?: DiagnosticWithLocation[];\n        /**\n         * Gets a substitute for a node, if one is available; otherwise, returns the original node.\n         *\n         * @param hint A hint as to the intended usage of the node.\n         * @param node The node to substitute.\n         */\n        substituteNode(hint: EmitHint, node: Node): Node;\n        /**\n         * Emits a node with possible notification.\n         *\n         * @param hint A hint as to the intended usage of the node.\n         * @param node The node to emit.\n         * @param emitCallback A callback used to emit the node.\n         */\n        emitNodeWithNotification(hint: EmitHint, node: Node, emitCallback: (hint: EmitHint, node: Node) => void): void;\n        /**\n         * Indicates if a given node needs an emit notification\n         *\n         * @param node The node to emit.\n         */\n        isEmitNotificationEnabled?(node: Node): boolean;\n        /**\n         * Clean up EmitNode entries on any parse-tree nodes.\n         */\n        dispose(): void;\n    }\n    /**\n     * A function that is used to initialize and return a `Transformer` callback, which in turn\n     * will be used to transform one or more nodes.\n     */\n    export type TransformerFactory<T extends Node> = (context: TransformationContext) => Transformer<T>;\n    /**\n     * A function that transforms a node.\n     */\n    export type Transformer<T extends Node> = (node: T) => T;\n    /**\n     * A function that accepts and possibly transforms a node.\n     */\n    export type Visitor = (node: Node) => VisitResult<Node>;\n    export type VisitResult<T extends Node> = T | T[] | undefined;\n    export interface Printer {\n        /**\n         * Print a node and its subtree as-is, without any emit transformations.\n         * @param hint A value indicating the purpose of a node. This is primarily used to\n         * distinguish between an `Identifier` used in an expression position, versus an\n         * `Identifier` used as an `IdentifierName` as part of a declaration. For most nodes you\n         * should just pass `Unspecified`.\n         * @param node The node to print. The node and its subtree are printed as-is, without any\n         * emit transformations.\n         * @param sourceFile A source file that provides context for the node. The source text of\n         * the file is used to emit the original source content for literals and identifiers, while\n         * the identifiers of the source file are used when generating unique names to avoid\n         * collisions.\n         */\n        printNode(hint: EmitHint, node: Node, sourceFile: SourceFile): string;\n        /**\n         * Prints a list of nodes using the given format flags\n         */\n        printList<T extends Node>(format: ListFormat, list: NodeArray<T>, sourceFile: SourceFile): string;\n        /**\n         * Prints a source file as-is, without any emit transformations.\n         */\n        printFile(sourceFile: SourceFile): string;\n        /**\n         * Prints a bundle of source files as-is, without any emit transformations.\n         */\n        printBundle(bundle: Bundle): string;\n    }\n    export interface PrintHandlers {\n        /**\n         * A hook used by the Printer when generating unique names to avoid collisions with\n         * globally defined names that exist outside of the current source file.\n         */\n        hasGlobalName?(name: string): boolean;\n        /**\n         * A hook used by the Printer to provide notifications prior to emitting a node. A\n         * compatible implementation **must** invoke `emitCallback` with the provided `hint` and\n         * `node` values.\n         * @param hint A hint indicating the intended purpose of the node.\n         * @param node The node to emit.\n         * @param emitCallback A callback that, when invoked, will emit the node.\n         * @example\n         * ```ts\n         * var printer = createPrinter(printerOptions, {\n         *   onEmitNode(hint, node, emitCallback) {\n         *     // set up or track state prior to emitting the node...\n         *     emitCallback(hint, node);\n         *     // restore state after emitting the node...\n         *   }\n         * });\n         * ```\n         */\n        onEmitNode?(hint: EmitHint, node: Node | undefined, emitCallback: (hint: EmitHint, node: Node | undefined) => void): void;\n        /**\n         * A hook used to check if an emit notification is required for a node.\n         * @param node The node to emit.\n         */\n        isEmitNotificationEnabled?(node: Node | undefined): boolean;\n        /**\n         * A hook used by the Printer to perform just-in-time substitution of a node. This is\n         * primarily used by node transformations that need to substitute one node for another,\n         * such as replacing `myExportedVar` with `exports.myExportedVar`.\n         * @param hint A hint indicating the intended purpose of the node.\n         * @param node The node to emit.\n         * @example\n         * ```ts\n         * var printer = createPrinter(printerOptions, {\n         *   substituteNode(hint, node) {\n         *     // perform substitution if necessary...\n         *     return node;\n         *   }\n         * });\n         * ```\n         */\n        substituteNode?(hint: EmitHint, node: Node): Node;\n    }\n    export interface PrinterOptions {\n        removeComments?: boolean;\n        newLine?: NewLineKind;\n        omitTrailingSemicolon?: boolean;\n        noEmitHelpers?: boolean;\n    }\n    export interface GetEffectiveTypeRootsHost {\n        directoryExists?(directoryName: string): boolean;\n        getCurrentDirectory?(): string;\n    }\n    export interface TextSpan {\n        start: number;\n        length: number;\n    }\n    export interface TextChangeRange {\n        span: TextSpan;\n        newLength: number;\n    }\n    export interface SyntaxList extends Node {\n        _children: Node[];\n    }\n    export enum ListFormat {\n        None = 0,\n        SingleLine = 0,\n        MultiLine = 1,\n        PreserveLines = 2,\n        LinesMask = 3,\n        NotDelimited = 0,\n        BarDelimited = 4,\n        AmpersandDelimited = 8,\n        CommaDelimited = 16,\n        AsteriskDelimited = 32,\n        DelimitersMask = 60,\n        AllowTrailingComma = 64,\n        Indented = 128,\n        SpaceBetweenBraces = 256,\n        SpaceBetweenSiblings = 512,\n        Braces = 1024,\n        Parenthesis = 2048,\n        AngleBrackets = 4096,\n        SquareBrackets = 8192,\n        BracketsMask = 15360,\n        OptionalIfUndefined = 16384,\n        OptionalIfEmpty = 32768,\n        Optional = 49152,\n        PreferNewLine = 65536,\n        NoTrailingNewLine = 131072,\n        NoInterveningComments = 262144,\n        NoSpaceIfEmpty = 524288,\n        SingleElement = 1048576,\n        SpaceAfterList = 2097152,\n        Modifiers = 262656,\n        HeritageClauses = 512,\n        SingleLineTypeLiteralMembers = 768,\n        MultiLineTypeLiteralMembers = 32897,\n        TupleTypeElements = 528,\n        UnionTypeConstituents = 516,\n        IntersectionTypeConstituents = 520,\n        ObjectBindingPatternElements = 525136,\n        ArrayBindingPatternElements = 524880,\n        ObjectLiteralExpressionProperties = 526226,\n        ArrayLiteralExpressionElements = 8914,\n        CommaListElements = 528,\n        CallExpressionArguments = 2576,\n        NewExpressionArguments = 18960,\n        TemplateExpressionSpans = 262144,\n        SingleLineBlockStatements = 768,\n        MultiLineBlockStatements = 129,\n        VariableDeclarationList = 528,\n        SingleLineFunctionBodyStatements = 768,\n        MultiLineFunctionBodyStatements = 1,\n        ClassHeritageClauses = 0,\n        ClassMembers = 129,\n        InterfaceMembers = 129,\n        EnumMembers = 145,\n        CaseBlockClauses = 129,\n        NamedImportsOrExportsElements = 525136,\n        JsxElementOrFragmentChildren = 262144,\n        JsxElementAttributes = 262656,\n        CaseOrDefaultClauseStatements = 163969,\n        HeritageClauseTypes = 528,\n        SourceFileStatements = 131073,\n        Decorators = 2146305,\n        TypeArguments = 53776,\n        TypeParameters = 53776,\n        Parameters = 2576,\n        IndexSignatureParameters = 8848,\n        JSDocComment = 33\n    }\n    export interface UserPreferences {\n        readonly disableSuggestions?: boolean;\n        readonly quotePreference?: "auto" | "double" | "single";\n        readonly includeCompletionsForModuleExports?: boolean;\n        readonly includeAutomaticOptionalChainCompletions?: boolean;\n        readonly includeCompletionsWithInsertText?: boolean;\n        readonly importModuleSpecifierPreference?: "auto" | "relative" | "non-relative";\n        /** Determines whether we import `foo/index.ts` as "foo", "foo/index", or "foo/index.js" */\n        readonly importModuleSpecifierEnding?: "auto" | "minimal" | "index" | "js";\n        readonly allowTextChangesInNewFiles?: boolean;\n        readonly providePrefixAndSuffixTextForRename?: boolean;\n    }\n    /** Represents a bigint literal value without requiring bigint support */\n    export interface PseudoBigInt {\n        negative: boolean;\n        base10Value: string;\n    }\n    export {};\n}\ndeclare function setTimeout(handler: (...args: any[]) => void, timeout: number): any;\ndeclare function clearTimeout(handle: any): void;\ndeclare namespace ts {\n    export enum FileWatcherEventKind {\n        Created = 0,\n        Changed = 1,\n        Deleted = 2\n    }\n    export type FileWatcherCallback = (fileName: string, eventKind: FileWatcherEventKind) => void;\n    export type DirectoryWatcherCallback = (fileName: string) => void;\n    export interface System {\n        args: string[];\n        newLine: string;\n        useCaseSensitiveFileNames: boolean;\n        write(s: string): void;\n        writeOutputIsTTY?(): boolean;\n        readFile(path: string, encoding?: string): string | undefined;\n        getFileSize?(path: string): number;\n        writeFile(path: string, data: string, writeByteOrderMark?: boolean): void;\n        /**\n         * @pollingInterval - this parameter is used in polling-based watchers and ignored in watchers that\n         * use native OS file watching\n         */\n        watchFile?(path: string, callback: FileWatcherCallback, pollingInterval?: number, options?: WatchOptions): FileWatcher;\n        watchDirectory?(path: string, callback: DirectoryWatcherCallback, recursive?: boolean, options?: WatchOptions): FileWatcher;\n        resolvePath(path: string): string;\n        fileExists(path: string): boolean;\n        directoryExists(path: string): boolean;\n        createDirectory(path: string): void;\n        getExecutingFilePath(): string;\n        getCurrentDirectory(): string;\n        getDirectories(path: string): string[];\n        readDirectory(path: string, extensions?: readonly string[], exclude?: readonly string[], include?: readonly string[], depth?: number): string[];\n        getModifiedTime?(path: string): Date | undefined;\n        setModifiedTime?(path: string, time: Date): void;\n        deleteFile?(path: string): void;\n        /**\n         * A good implementation is node.js\' `crypto.createHash`. (https://nodejs.org/api/crypto.html#crypto_crypto_createhash_algorithm)\n         */\n        createHash?(data: string): string;\n        /** This must be cryptographically secure. Only implement this method using `crypto.createHash("sha256")`. */\n        createSHA256Hash?(data: string): string;\n        getMemoryUsage?(): number;\n        exit(exitCode?: number): void;\n        realpath?(path: string): string;\n        setTimeout?(callback: (...args: any[]) => void, ms: number, ...args: any[]): any;\n        clearTimeout?(timeoutId: any): void;\n        clearScreen?(): void;\n        base64decode?(input: string): string;\n        base64encode?(input: string): string;\n    }\n    export interface FileWatcher {\n        close(): void;\n    }\n    export function getNodeMajorVersion(): number | undefined;\n    export let sys: System;\n    export {};\n}\ndeclare namespace ts {\n    type ErrorCallback = (message: DiagnosticMessage, length: number) => void;\n    interface Scanner {\n        getStartPos(): number;\n        getToken(): SyntaxKind;\n        getTextPos(): number;\n        getTokenPos(): number;\n        getTokenText(): string;\n        getTokenValue(): string;\n        hasUnicodeEscape(): boolean;\n        hasExtendedUnicodeEscape(): boolean;\n        hasPrecedingLineBreak(): boolean;\n        isIdentifier(): boolean;\n        isReservedWord(): boolean;\n        isUnterminated(): boolean;\n        reScanGreaterToken(): SyntaxKind;\n        reScanSlashToken(): SyntaxKind;\n        reScanTemplateToken(isTaggedTemplate: boolean): SyntaxKind;\n        reScanTemplateHeadOrNoSubstitutionTemplate(): SyntaxKind;\n        scanJsxIdentifier(): SyntaxKind;\n        scanJsxAttributeValue(): SyntaxKind;\n        reScanJsxAttributeValue(): SyntaxKind;\n        reScanJsxToken(): JsxTokenSyntaxKind;\n        reScanLessThanToken(): SyntaxKind;\n        reScanQuestionToken(): SyntaxKind;\n        scanJsxToken(): JsxTokenSyntaxKind;\n        scanJsDocToken(): JSDocSyntaxKind;\n        scan(): SyntaxKind;\n        getText(): string;\n        setText(text: string | undefined, start?: number, length?: number): void;\n        setOnError(onError: ErrorCallback | undefined): void;\n        setScriptTarget(scriptTarget: ScriptTarget): void;\n        setLanguageVariant(variant: LanguageVariant): void;\n        setTextPos(textPos: number): void;\n        lookAhead<T>(callback: () => T): T;\n        scanRange<T>(start: number, length: number, callback: () => T): T;\n        tryScan<T>(callback: () => T): T;\n    }\n    function tokenToString(t: SyntaxKind): string | undefined;\n    function getPositionOfLineAndCharacter(sourceFile: SourceFileLike, line: number, character: number): number;\n    function getLineAndCharacterOfPosition(sourceFile: SourceFileLike, position: number): LineAndCharacter;\n    function isWhiteSpaceLike(ch: number): boolean;\n    /** Does not include line breaks. For that, see isWhiteSpaceLike. */\n    function isWhiteSpaceSingleLine(ch: number): boolean;\n    function isLineBreak(ch: number): boolean;\n    function couldStartTrivia(text: string, pos: number): boolean;\n    function forEachLeadingCommentRange<U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean) => U): U | undefined;\n    function forEachLeadingCommentRange<T, U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean, state: T) => U, state: T): U | undefined;\n    function forEachTrailingCommentRange<U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean) => U): U | undefined;\n    function forEachTrailingCommentRange<T, U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean, state: T) => U, state: T): U | undefined;\n    function reduceEachLeadingCommentRange<T, U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean, state: T, memo: U) => U, state: T, initial: U): U | undefined;\n    function reduceEachTrailingCommentRange<T, U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean, state: T, memo: U) => U, state: T, initial: U): U | undefined;\n    function getLeadingCommentRanges(text: string, pos: number): CommentRange[] | undefined;\n    function getTrailingCommentRanges(text: string, pos: number): CommentRange[] | undefined;\n    /** Optionally, get the shebang */\n    function getShebang(text: string): string | undefined;\n    function isIdentifierStart(ch: number, languageVersion: ScriptTarget | undefined): boolean;\n    function isIdentifierPart(ch: number, languageVersion: ScriptTarget | undefined, identifierVariant?: LanguageVariant): boolean;\n    function createScanner(languageVersion: ScriptTarget, skipTrivia: boolean, languageVariant?: LanguageVariant, textInitial?: string, onError?: ErrorCallback, start?: number, length?: number): Scanner;\n}\ndeclare namespace ts {\n    function isExternalModuleNameRelative(moduleName: string): boolean;\n    function sortAndDeduplicateDiagnostics<T extends Diagnostic>(diagnostics: readonly T[]): SortedReadonlyArray<T>;\n    function getDefaultLibFileName(options: CompilerOptions): string;\n    function textSpanEnd(span: TextSpan): number;\n    function textSpanIsEmpty(span: TextSpan): boolean;\n    function textSpanContainsPosition(span: TextSpan, position: number): boolean;\n    function textSpanContainsTextSpan(span: TextSpan, other: TextSpan): boolean;\n    function textSpanOverlapsWith(span: TextSpan, other: TextSpan): boolean;\n    function textSpanOverlap(span1: TextSpan, span2: TextSpan): TextSpan | undefined;\n    function textSpanIntersectsWithTextSpan(span: TextSpan, other: TextSpan): boolean;\n    function textSpanIntersectsWith(span: TextSpan, start: number, length: number): boolean;\n    function decodedTextSpanIntersectsWith(start1: number, length1: number, start2: number, length2: number): boolean;\n    function textSpanIntersectsWithPosition(span: TextSpan, position: number): boolean;\n    function textSpanIntersection(span1: TextSpan, span2: TextSpan): TextSpan | undefined;\n    function createTextSpan(start: number, length: number): TextSpan;\n    function createTextSpanFromBounds(start: number, end: number): TextSpan;\n    function textChangeRangeNewSpan(range: TextChangeRange): TextSpan;\n    function textChangeRangeIsUnchanged(range: TextChangeRange): boolean;\n    function createTextChangeRange(span: TextSpan, newLength: number): TextChangeRange;\n    let unchangedTextChangeRange: TextChangeRange;\n    /**\n     * Called to merge all the changes that occurred across several versions of a script snapshot\n     * into a single change.  i.e. if a user keeps making successive edits to a script we will\n     * have a text change from V1 to V2, V2 to V3, ..., Vn.\n     *\n     * This function will then merge those changes into a single change range valid between V1 and\n     * Vn.\n     */\n    function collapseTextChangeRangesAcrossMultipleVersions(changes: readonly TextChangeRange[]): TextChangeRange;\n    function getTypeParameterOwner(d: Declaration): Declaration | undefined;\n    type ParameterPropertyDeclaration = ParameterDeclaration & {\n        parent: ConstructorDeclaration;\n        name: Identifier;\n    };\n    function isParameterPropertyDeclaration(node: Node, parent: Node): node is ParameterPropertyDeclaration;\n    function isEmptyBindingPattern(node: BindingName): node is BindingPattern;\n    function isEmptyBindingElement(node: BindingElement): boolean;\n    function walkUpBindingElementsAndPatterns(binding: BindingElement): VariableDeclaration | ParameterDeclaration;\n    function getCombinedModifierFlags(node: Declaration): ModifierFlags;\n    function getCombinedNodeFlags(node: Node): NodeFlags;\n    /**\n     * Checks to see if the locale is in the appropriate format,\n     * and if it is, attempts to set the appropriate language.\n     */\n    function validateLocaleAndSetLanguage(locale: string, sys: {\n        getExecutingFilePath(): string;\n        resolvePath(path: string): string;\n        fileExists(fileName: string): boolean;\n        readFile(fileName: string): string | undefined;\n    }, errors?: Push<Diagnostic>): void;\n    function getOriginalNode(node: Node): Node;\n    function getOriginalNode<T extends Node>(node: Node, nodeTest: (node: Node) => node is T): T;\n    function getOriginalNode(node: Node | undefined): Node | undefined;\n    function getOriginalNode<T extends Node>(node: Node | undefined, nodeTest: (node: Node | undefined) => node is T): T | undefined;\n    /**\n     * Gets a value indicating whether a node originated in the parse tree.\n     *\n     * @param node The node to test.\n     */\n    function isParseTreeNode(node: Node): boolean;\n    /**\n     * Gets the original parse tree node for a node.\n     *\n     * @param node The original node.\n     * @returns The original parse tree node if found; otherwise, undefined.\n     */\n    function getParseTreeNode(node: Node): Node;\n    /**\n     * Gets the original parse tree node for a node.\n     *\n     * @param node The original node.\n     * @param nodeTest A callback used to ensure the correct type of parse tree node is returned.\n     * @returns The original parse tree node if found; otherwise, undefined.\n     */\n    function getParseTreeNode<T extends Node>(node: Node | undefined, nodeTest?: (node: Node) => node is T): T | undefined;\n    /** Add an extra underscore to identifiers that start with two underscores to avoid issues with magic names like \'__proto__\' */\n    function escapeLeadingUnderscores(identifier: string): __String;\n    /**\n     * Remove extra underscore from escaped identifier text content.\n     *\n     * @param identifier The escaped identifier text.\n     * @returns The unescaped identifier text.\n     */\n    function unescapeLeadingUnderscores(identifier: __String): string;\n    function idText(identifierOrPrivateName: Identifier | PrivateIdentifier): string;\n    function symbolName(symbol: Symbol): string;\n    function getNameOfJSDocTypedef(declaration: JSDocTypedefTag): Identifier | PrivateIdentifier | undefined;\n    function getNameOfDeclaration(declaration: Declaration | Expression): DeclarationName | undefined;\n    /**\n     * Gets the JSDoc parameter tags for the node if present.\n     *\n     * @remarks Returns any JSDoc param tag whose name matches the provided\n     * parameter, whether a param tag on a containing function\n     * expression, or a param tag on a variable declaration whose\n     * initializer is the containing function. The tags closest to the\n     * node are returned first, so in the previous example, the param\n     * tag on the containing function expression would be first.\n     *\n     * For binding patterns, parameter tags are matched by position.\n     */\n    function getJSDocParameterTags(param: ParameterDeclaration): readonly JSDocParameterTag[];\n    /**\n     * Gets the JSDoc type parameter tags for the node if present.\n     *\n     * @remarks Returns any JSDoc template tag whose names match the provided\n     * parameter, whether a template tag on a containing function\n     * expression, or a template tag on a variable declaration whose\n     * initializer is the containing function. The tags closest to the\n     * node are returned first, so in the previous example, the template\n     * tag on the containing function expression would be first.\n     */\n    function getJSDocTypeParameterTags(param: TypeParameterDeclaration): readonly JSDocTemplateTag[];\n    /**\n     * Return true if the node has JSDoc parameter tags.\n     *\n     * @remarks Includes parameter tags that are not directly on the node,\n     * for example on a variable declaration whose initializer is a function expression.\n     */\n    function hasJSDocParameterTags(node: FunctionLikeDeclaration | SignatureDeclaration): boolean;\n    /** Gets the JSDoc augments tag for the node if present */\n    function getJSDocAugmentsTag(node: Node): JSDocAugmentsTag | undefined;\n    /** Gets the JSDoc implements tags for the node if present */\n    function getJSDocImplementsTags(node: Node): readonly JSDocImplementsTag[];\n    /** Gets the JSDoc class tag for the node if present */\n    function getJSDocClassTag(node: Node): JSDocClassTag | undefined;\n    /** Gets the JSDoc public tag for the node if present */\n    function getJSDocPublicTag(node: Node): JSDocPublicTag | undefined;\n    /** Gets the JSDoc private tag for the node if present */\n    function getJSDocPrivateTag(node: Node): JSDocPrivateTag | undefined;\n    /** Gets the JSDoc protected tag for the node if present */\n    function getJSDocProtectedTag(node: Node): JSDocProtectedTag | undefined;\n    /** Gets the JSDoc protected tag for the node if present */\n    function getJSDocReadonlyTag(node: Node): JSDocReadonlyTag | undefined;\n    /** Gets the JSDoc enum tag for the node if present */\n    function getJSDocEnumTag(node: Node): JSDocEnumTag | undefined;\n    /** Gets the JSDoc this tag for the node if present */\n    function getJSDocThisTag(node: Node): JSDocThisTag | undefined;\n    /** Gets the JSDoc return tag for the node if present */\n    function getJSDocReturnTag(node: Node): JSDocReturnTag | undefined;\n    /** Gets the JSDoc template tag for the node if present */\n    function getJSDocTemplateTag(node: Node): JSDocTemplateTag | undefined;\n    /** Gets the JSDoc type tag for the node if present and valid */\n    function getJSDocTypeTag(node: Node): JSDocTypeTag | undefined;\n    /**\n     * Gets the type node for the node if provided via JSDoc.\n     *\n     * @remarks The search includes any JSDoc param tag that relates\n     * to the provided parameter, for example a type tag on the\n     * parameter itself, or a param tag on a containing function\n     * expression, or a param tag on a variable declaration whose\n     * initializer is the containing function. The tags closest to the\n     * node are examined first, so in the previous example, the type\n     * tag directly on the node would be returned.\n     */\n    function getJSDocType(node: Node): TypeNode | undefined;\n    /**\n     * Gets the return type node for the node if provided via JSDoc return tag or type tag.\n     *\n     * @remarks `getJSDocReturnTag` just gets the whole JSDoc tag. This function\n     * gets the type from inside the braces, after the fat arrow, etc.\n     */\n    function getJSDocReturnType(node: Node): TypeNode | undefined;\n    /** Get all JSDoc tags related to a node, including those on parent nodes. */\n    function getJSDocTags(node: Node): readonly JSDocTag[];\n    /** Gets all JSDoc tags that match a specified predicate */\n    function getAllJSDocTags<T extends JSDocTag>(node: Node, predicate: (tag: JSDocTag) => tag is T): readonly T[];\n    /** Gets all JSDoc tags of a specified kind */\n    function getAllJSDocTagsOfKind(node: Node, kind: SyntaxKind): readonly JSDocTag[];\n    /**\n     * Gets the effective type parameters. If the node was parsed in a\n     * JavaScript file, gets the type parameters from the `@template` tag from JSDoc.\n     */\n    function getEffectiveTypeParameterDeclarations(node: DeclarationWithTypeParameters): readonly TypeParameterDeclaration[];\n    function getEffectiveConstraintOfTypeParameter(node: TypeParameterDeclaration): TypeNode | undefined;\n    function isNumericLiteral(node: Node): node is NumericLiteral;\n    function isBigIntLiteral(node: Node): node is BigIntLiteral;\n    function isStringLiteral(node: Node): node is StringLiteral;\n    function isJsxText(node: Node): node is JsxText;\n    function isRegularExpressionLiteral(node: Node): node is RegularExpressionLiteral;\n    function isNoSubstitutionTemplateLiteral(node: Node): node is NoSubstitutionTemplateLiteral;\n    function isTemplateHead(node: Node): node is TemplateHead;\n    function isTemplateMiddle(node: Node): node is TemplateMiddle;\n    function isTemplateTail(node: Node): node is TemplateTail;\n    function isIdentifier(node: Node): node is Identifier;\n    function isQualifiedName(node: Node): node is QualifiedName;\n    function isComputedPropertyName(node: Node): node is ComputedPropertyName;\n    function isPrivateIdentifier(node: Node): node is PrivateIdentifier;\n    function isIdentifierOrPrivateIdentifier(node: Node): node is Identifier | PrivateIdentifier;\n    function isTypeParameterDeclaration(node: Node): node is TypeParameterDeclaration;\n    function isParameter(node: Node): node is ParameterDeclaration;\n    function isDecorator(node: Node): node is Decorator;\n    function isPropertySignature(node: Node): node is PropertySignature;\n    function isPropertyDeclaration(node: Node): node is PropertyDeclaration;\n    function isMethodSignature(node: Node): node is MethodSignature;\n    function isMethodDeclaration(node: Node): node is MethodDeclaration;\n    function isConstructorDeclaration(node: Node): node is ConstructorDeclaration;\n    function isGetAccessorDeclaration(node: Node): node is GetAccessorDeclaration;\n    function isSetAccessorDeclaration(node: Node): node is SetAccessorDeclaration;\n    function isCallSignatureDeclaration(node: Node): node is CallSignatureDeclaration;\n    function isConstructSignatureDeclaration(node: Node): node is ConstructSignatureDeclaration;\n    function isIndexSignatureDeclaration(node: Node): node is IndexSignatureDeclaration;\n    function isTypePredicateNode(node: Node): node is TypePredicateNode;\n    function isTypeReferenceNode(node: Node): node is TypeReferenceNode;\n    function isFunctionTypeNode(node: Node): node is FunctionTypeNode;\n    function isConstructorTypeNode(node: Node): node is ConstructorTypeNode;\n    function isTypeQueryNode(node: Node): node is TypeQueryNode;\n    function isTypeLiteralNode(node: Node): node is TypeLiteralNode;\n    function isArrayTypeNode(node: Node): node is ArrayTypeNode;\n    function isTupleTypeNode(node: Node): node is TupleTypeNode;\n    function isUnionTypeNode(node: Node): node is UnionTypeNode;\n    function isIntersectionTypeNode(node: Node): node is IntersectionTypeNode;\n    function isConditionalTypeNode(node: Node): node is ConditionalTypeNode;\n    function isInferTypeNode(node: Node): node is InferTypeNode;\n    function isParenthesizedTypeNode(node: Node): node is ParenthesizedTypeNode;\n    function isThisTypeNode(node: Node): node is ThisTypeNode;\n    function isTypeOperatorNode(node: Node): node is TypeOperatorNode;\n    function isIndexedAccessTypeNode(node: Node): node is IndexedAccessTypeNode;\n    function isMappedTypeNode(node: Node): node is MappedTypeNode;\n    function isLiteralTypeNode(node: Node): node is LiteralTypeNode;\n    function isImportTypeNode(node: Node): node is ImportTypeNode;\n    function isObjectBindingPattern(node: Node): node is ObjectBindingPattern;\n    function isArrayBindingPattern(node: Node): node is ArrayBindingPattern;\n    function isBindingElement(node: Node): node is BindingElement;\n    function isArrayLiteralExpression(node: Node): node is ArrayLiteralExpression;\n    function isObjectLiteralExpression(node: Node): node is ObjectLiteralExpression;\n    function isPropertyAccessExpression(node: Node): node is PropertyAccessExpression;\n    function isPropertyAccessChain(node: Node): node is PropertyAccessChain;\n    function isElementAccessExpression(node: Node): node is ElementAccessExpression;\n    function isElementAccessChain(node: Node): node is ElementAccessChain;\n    function isCallExpression(node: Node): node is CallExpression;\n    function isCallChain(node: Node): node is CallChain;\n    function isOptionalChain(node: Node): node is PropertyAccessChain | ElementAccessChain | CallChain | NonNullChain;\n    function isNullishCoalesce(node: Node): boolean;\n    function isNewExpression(node: Node): node is NewExpression;\n    function isTaggedTemplateExpression(node: Node): node is TaggedTemplateExpression;\n    function isTypeAssertion(node: Node): node is TypeAssertion;\n    function isConstTypeReference(node: Node): boolean;\n    function isParenthesizedExpression(node: Node): node is ParenthesizedExpression;\n    function skipPartiallyEmittedExpressions(node: Expression): Expression;\n    function skipPartiallyEmittedExpressions(node: Node): Node;\n    function isFunctionExpression(node: Node): node is FunctionExpression;\n    function isArrowFunction(node: Node): node is ArrowFunction;\n    function isDeleteExpression(node: Node): node is DeleteExpression;\n    function isTypeOfExpression(node: Node): node is TypeOfExpression;\n    function isVoidExpression(node: Node): node is VoidExpression;\n    function isAwaitExpression(node: Node): node is AwaitExpression;\n    function isPrefixUnaryExpression(node: Node): node is PrefixUnaryExpression;\n    function isPostfixUnaryExpression(node: Node): node is PostfixUnaryExpression;\n    function isBinaryExpression(node: Node): node is BinaryExpression;\n    function isConditionalExpression(node: Node): node is ConditionalExpression;\n    function isTemplateExpression(node: Node): node is TemplateExpression;\n    function isYieldExpression(node: Node): node is YieldExpression;\n    function isSpreadElement(node: Node): node is SpreadElement;\n    function isClassExpression(node: Node): node is ClassExpression;\n    function isOmittedExpression(node: Node): node is OmittedExpression;\n    function isExpressionWithTypeArguments(node: Node): node is ExpressionWithTypeArguments;\n    function isAsExpression(node: Node): node is AsExpression;\n    function isNonNullExpression(node: Node): node is NonNullExpression;\n    function isNonNullChain(node: Node): node is NonNullChain;\n    function isMetaProperty(node: Node): node is MetaProperty;\n    function isTemplateSpan(node: Node): node is TemplateSpan;\n    function isSemicolonClassElement(node: Node): node is SemicolonClassElement;\n    function isBlock(node: Node): node is Block;\n    function isVariableStatement(node: Node): node is VariableStatement;\n    function isEmptyStatement(node: Node): node is EmptyStatement;\n    function isExpressionStatement(node: Node): node is ExpressionStatement;\n    function isIfStatement(node: Node): node is IfStatement;\n    function isDoStatement(node: Node): node is DoStatement;\n    function isWhileStatement(node: Node): node is WhileStatement;\n    function isForStatement(node: Node): node is ForStatement;\n    function isForInStatement(node: Node): node is ForInStatement;\n    function isForOfStatement(node: Node): node is ForOfStatement;\n    function isContinueStatement(node: Node): node is ContinueStatement;\n    function isBreakStatement(node: Node): node is BreakStatement;\n    function isBreakOrContinueStatement(node: Node): node is BreakOrContinueStatement;\n    function isReturnStatement(node: Node): node is ReturnStatement;\n    function isWithStatement(node: Node): node is WithStatement;\n    function isSwitchStatement(node: Node): node is SwitchStatement;\n    function isLabeledStatement(node: Node): node is LabeledStatement;\n    function isThrowStatement(node: Node): node is ThrowStatement;\n    function isTryStatement(node: Node): node is TryStatement;\n    function isDebuggerStatement(node: Node): node is DebuggerStatement;\n    function isVariableDeclaration(node: Node): node is VariableDeclaration;\n    function isVariableDeclarationList(node: Node): node is VariableDeclarationList;\n    function isFunctionDeclaration(node: Node): node is FunctionDeclaration;\n    function isClassDeclaration(node: Node): node is ClassDeclaration;\n    function isInterfaceDeclaration(node: Node): node is InterfaceDeclaration;\n    function isTypeAliasDeclaration(node: Node): node is TypeAliasDeclaration;\n    function isEnumDeclaration(node: Node): node is EnumDeclaration;\n    function isModuleDeclaration(node: Node): node is ModuleDeclaration;\n    function isModuleBlock(node: Node): node is ModuleBlock;\n    function isCaseBlock(node: Node): node is CaseBlock;\n    function isNamespaceExportDeclaration(node: Node): node is NamespaceExportDeclaration;\n    function isImportEqualsDeclaration(node: Node): node is ImportEqualsDeclaration;\n    function isImportDeclaration(node: Node): node is ImportDeclaration;\n    function isImportClause(node: Node): node is ImportClause;\n    function isNamespaceImport(node: Node): node is NamespaceImport;\n    function isNamespaceExport(node: Node): node is NamespaceExport;\n    function isNamedExportBindings(node: Node): node is NamedExportBindings;\n    function isNamedImports(node: Node): node is NamedImports;\n    function isImportSpecifier(node: Node): node is ImportSpecifier;\n    function isExportAssignment(node: Node): node is ExportAssignment;\n    function isExportDeclaration(node: Node): node is ExportDeclaration;\n    function isNamedExports(node: Node): node is NamedExports;\n    function isExportSpecifier(node: Node): node is ExportSpecifier;\n    function isMissingDeclaration(node: Node): node is MissingDeclaration;\n    function isExternalModuleReference(node: Node): node is ExternalModuleReference;\n    function isJsxElement(node: Node): node is JsxElement;\n    function isJsxSelfClosingElement(node: Node): node is JsxSelfClosingElement;\n    function isJsxOpeningElement(node: Node): node is JsxOpeningElement;\n    function isJsxClosingElement(node: Node): node is JsxClosingElement;\n    function isJsxFragment(node: Node): node is JsxFragment;\n    function isJsxOpeningFragment(node: Node): node is JsxOpeningFragment;\n    function isJsxClosingFragment(node: Node): node is JsxClosingFragment;\n    function isJsxAttribute(node: Node): node is JsxAttribute;\n    function isJsxAttributes(node: Node): node is JsxAttributes;\n    function isJsxSpreadAttribute(node: Node): node is JsxSpreadAttribute;\n    function isJsxExpression(node: Node): node is JsxExpression;\n    function isCaseClause(node: Node): node is CaseClause;\n    function isDefaultClause(node: Node): node is DefaultClause;\n    function isHeritageClause(node: Node): node is HeritageClause;\n    function isCatchClause(node: Node): node is CatchClause;\n    function isPropertyAssignment(node: Node): node is PropertyAssignment;\n    function isShorthandPropertyAssignment(node: Node): node is ShorthandPropertyAssignment;\n    function isSpreadAssignment(node: Node): node is SpreadAssignment;\n    function isEnumMember(node: Node): node is EnumMember;\n    function isSourceFile(node: Node): node is SourceFile;\n    function isBundle(node: Node): node is Bundle;\n    function isUnparsedSource(node: Node): node is UnparsedSource;\n    function isUnparsedPrepend(node: Node): node is UnparsedPrepend;\n    function isUnparsedTextLike(node: Node): node is UnparsedTextLike;\n    function isUnparsedNode(node: Node): node is UnparsedNode;\n    function isJSDocTypeExpression(node: Node): node is JSDocTypeExpression;\n    function isJSDocAllType(node: Node): node is JSDocAllType;\n    function isJSDocUnknownType(node: Node): node is JSDocUnknownType;\n    function isJSDocNullableType(node: Node): node is JSDocNullableType;\n    function isJSDocNonNullableType(node: Node): node is JSDocNonNullableType;\n    function isJSDocOptionalType(node: Node): node is JSDocOptionalType;\n    function isJSDocFunctionType(node: Node): node is JSDocFunctionType;\n    function isJSDocVariadicType(node: Node): node is JSDocVariadicType;\n    function isJSDoc(node: Node): node is JSDoc;\n    function isJSDocAuthorTag(node: Node): node is JSDocAuthorTag;\n    function isJSDocAugmentsTag(node: Node): node is JSDocAugmentsTag;\n    function isJSDocImplementsTag(node: Node): node is JSDocImplementsTag;\n    function isJSDocClassTag(node: Node): node is JSDocClassTag;\n    function isJSDocPublicTag(node: Node): node is JSDocPublicTag;\n    function isJSDocPrivateTag(node: Node): node is JSDocPrivateTag;\n    function isJSDocProtectedTag(node: Node): node is JSDocProtectedTag;\n    function isJSDocReadonlyTag(node: Node): node is JSDocReadonlyTag;\n    function isJSDocEnumTag(node: Node): node is JSDocEnumTag;\n    function isJSDocThisTag(node: Node): node is JSDocThisTag;\n    function isJSDocParameterTag(node: Node): node is JSDocParameterTag;\n    function isJSDocReturnTag(node: Node): node is JSDocReturnTag;\n    function isJSDocTypeTag(node: Node): node is JSDocTypeTag;\n    function isJSDocTemplateTag(node: Node): node is JSDocTemplateTag;\n    function isJSDocTypedefTag(node: Node): node is JSDocTypedefTag;\n    function isJSDocPropertyTag(node: Node): node is JSDocPropertyTag;\n    function isJSDocPropertyLikeTag(node: Node): node is JSDocPropertyLikeTag;\n    function isJSDocTypeLiteral(node: Node): node is JSDocTypeLiteral;\n    function isJSDocCallbackTag(node: Node): node is JSDocCallbackTag;\n    function isJSDocSignature(node: Node): node is JSDocSignature;\n    /**\n     * True if node is of some token syntax kind.\n     * For example, this is true for an IfKeyword but not for an IfStatement.\n     * Literals are considered tokens, except TemplateLiteral, but does include TemplateHead/Middle/Tail.\n     */\n    function isToken(n: Node): boolean;\n    function isLiteralExpression(node: Node): node is LiteralExpression;\n    type TemplateLiteralToken = NoSubstitutionTemplateLiteral | TemplateHead | TemplateMiddle | TemplateTail;\n    function isTemplateLiteralToken(node: Node): node is TemplateLiteralToken;\n    function isTemplateMiddleOrTemplateTail(node: Node): node is TemplateMiddle | TemplateTail;\n    function isImportOrExportSpecifier(node: Node): node is ImportSpecifier | ExportSpecifier;\n    function isTypeOnlyImportOrExportDeclaration(node: Node): node is TypeOnlyCompatibleAliasDeclaration;\n    function isStringTextContainingNode(node: Node): node is StringLiteral | TemplateLiteralToken;\n    function isModifier(node: Node): node is Modifier;\n    function isEntityName(node: Node): node is EntityName;\n    function isPropertyName(node: Node): node is PropertyName;\n    function isBindingName(node: Node): node is BindingName;\n    function isFunctionLike(node: Node): node is SignatureDeclaration;\n    function isClassElement(node: Node): node is ClassElement;\n    function isClassLike(node: Node): node is ClassLikeDeclaration;\n    function isAccessor(node: Node): node is AccessorDeclaration;\n    function isTypeElement(node: Node): node is TypeElement;\n    function isClassOrTypeElement(node: Node): node is ClassElement | TypeElement;\n    function isObjectLiteralElementLike(node: Node): node is ObjectLiteralElementLike;\n    /**\n     * Node test that determines whether a node is a valid type node.\n     * This differs from the `isPartOfTypeNode` function which determines whether a node is *part*\n     * of a TypeNode.\n     */\n    function isTypeNode(node: Node): node is TypeNode;\n    function isFunctionOrConstructorTypeNode(node: Node): node is FunctionTypeNode | ConstructorTypeNode;\n    function isPropertyAccessOrQualifiedName(node: Node): node is PropertyAccessExpression | QualifiedName;\n    function isCallLikeExpression(node: Node): node is CallLikeExpression;\n    function isCallOrNewExpression(node: Node): node is CallExpression | NewExpression;\n    function isTemplateLiteral(node: Node): node is TemplateLiteral;\n    function isAssertionExpression(node: Node): node is AssertionExpression;\n    function isIterationStatement(node: Node, lookInLabeledStatements: false): node is IterationStatement;\n    function isIterationStatement(node: Node, lookInLabeledStatements: boolean): node is IterationStatement | LabeledStatement;\n    function isJsxOpeningLikeElement(node: Node): node is JsxOpeningLikeElement;\n    function isCaseOrDefaultClause(node: Node): node is CaseOrDefaultClause;\n    /** True if node is of a kind that may contain comment text. */\n    function isJSDocCommentContainingNode(node: Node): boolean;\n    function isSetAccessor(node: Node): node is SetAccessorDeclaration;\n    function isGetAccessor(node: Node): node is GetAccessorDeclaration;\n    /** True if has initializer node attached to it. */\n    function hasOnlyExpressionInitializer(node: Node): node is HasExpressionInitializer;\n    function isObjectLiteralElement(node: Node): node is ObjectLiteralElement;\n    function isStringLiteralLike(node: Node): node is StringLiteralLike;\n}\ndeclare namespace ts {\n    export function createNode(kind: SyntaxKind, pos?: number, end?: number): Node;\n    /**\n     * Invokes a callback for each child of the given node. The \'cbNode\' callback is invoked for all child nodes\n     * stored in properties. If a \'cbNodes\' callback is specified, it is invoked for embedded arrays; otherwise,\n     * embedded arrays are flattened and the \'cbNode\' callback is invoked for each element. If a callback returns\n     * a truthy value, iteration stops and that value is returned. Otherwise, undefined is returned.\n     *\n     * @param node a given node to visit its children\n     * @param cbNode a callback to be invoked for all child nodes\n     * @param cbNodes a callback to be invoked for embedded array\n     *\n     * @remarks `forEachChild` must visit the children of a node in the order\n     * that they appear in the source code. The language service depends on this property to locate nodes by position.\n     */\n    export function forEachChild<T>(node: Node, cbNode: (node: Node) => T | undefined, cbNodes?: (nodes: NodeArray<Node>) => T | undefined): T | undefined;\n    export function createSourceFile(fileName: string, sourceText: string, languageVersion: ScriptTarget, setParentNodes?: boolean, scriptKind?: ScriptKind): SourceFile;\n    export function parseIsolatedEntityName(text: string, languageVersion: ScriptTarget): EntityName | undefined;\n    /**\n     * Parse json text into SyntaxTree and return node and parse errors if any\n     * @param fileName\n     * @param sourceText\n     */\n    export function parseJsonText(fileName: string, sourceText: string): JsonSourceFile;\n    export function isExternalModule(file: SourceFile): boolean;\n    export function updateSourceFile(sourceFile: SourceFile, newText: string, textChangeRange: TextChangeRange, aggressiveChecks?: boolean): SourceFile;\n    export {};\n}\ndeclare namespace ts {\n    export function parseCommandLine(commandLine: readonly string[], readFile?: (path: string) => string | undefined): ParsedCommandLine;\n    export type DiagnosticReporter = (diagnostic: Diagnostic) => void;\n    /**\n     * Reports config file diagnostics\n     */\n    export interface ConfigFileDiagnosticsReporter {\n        /**\n         * Reports unrecoverable error when parsing config file\n         */\n        onUnRecoverableConfigFileDiagnostic: DiagnosticReporter;\n    }\n    /**\n     * Interface extending ParseConfigHost to support ParseConfigFile that reads config file and reports errors\n     */\n    export interface ParseConfigFileHost extends ParseConfigHost, ConfigFileDiagnosticsReporter {\n        getCurrentDirectory(): string;\n    }\n    /**\n     * Reads the config file, reports errors if any and exits if the config file cannot be found\n     */\n    export function getParsedCommandLineOfConfigFile(configFileName: string, optionsToExtend: CompilerOptions, host: ParseConfigFileHost, extendedConfigCache?: Map<ExtendedConfigCacheEntry>, watchOptionsToExtend?: WatchOptions, extraFileExtensions?: readonly FileExtensionInfo[]): ParsedCommandLine | undefined;\n    /**\n     * Read tsconfig.json file\n     * @param fileName The path to the config file\n     */\n    export function readConfigFile(fileName: string, readFile: (path: string) => string | undefined): {\n        config?: any;\n        error?: Diagnostic;\n    };\n    /**\n     * Parse the text of the tsconfig.json file\n     * @param fileName The path to the config file\n     * @param jsonText The text of the config file\n     */\n    export function parseConfigFileTextToJson(fileName: string, jsonText: string): {\n        config?: any;\n        error?: Diagnostic;\n    };\n    /**\n     * Read tsconfig.json file\n     * @param fileName The path to the config file\n     */\n    export function readJsonConfigFile(fileName: string, readFile: (path: string) => string | undefined): TsConfigSourceFile;\n    /**\n     * Convert the json syntax tree into the json value\n     */\n    export function convertToObject(sourceFile: JsonSourceFile, errors: Push<Diagnostic>): any;\n    /**\n     * Parse the contents of a config file (tsconfig.json).\n     * @param json The contents of the config file to parse\n     * @param host Instance of ParseConfigHost used to enumerate files in folder.\n     * @param basePath A root directory to resolve relative path entries in the config\n     *    file to. e.g. outDir\n     */\n    export function parseJsonConfigFileContent(json: any, host: ParseConfigHost, basePath: string, existingOptions?: CompilerOptions, configFileName?: string, resolutionStack?: Path[], extraFileExtensions?: readonly FileExtensionInfo[], extendedConfigCache?: Map<ExtendedConfigCacheEntry>, existingWatchOptions?: WatchOptions): ParsedCommandLine;\n    /**\n     * Parse the contents of a config file (tsconfig.json).\n     * @param jsonNode The contents of the config file to parse\n     * @param host Instance of ParseConfigHost used to enumerate files in folder.\n     * @param basePath A root directory to resolve relative path entries in the config\n     *    file to. e.g. outDir\n     */\n    export function parseJsonSourceFileConfigFileContent(sourceFile: TsConfigSourceFile, host: ParseConfigHost, basePath: string, existingOptions?: CompilerOptions, configFileName?: string, resolutionStack?: Path[], extraFileExtensions?: readonly FileExtensionInfo[], extendedConfigCache?: Map<ExtendedConfigCacheEntry>, existingWatchOptions?: WatchOptions): ParsedCommandLine;\n    export interface ParsedTsconfig {\n        raw: any;\n        options?: CompilerOptions;\n        watchOptions?: WatchOptions;\n        typeAcquisition?: TypeAcquisition;\n        /**\n         * Note that the case of the config path has not yet been normalized, as no files have been imported into the project yet\n         */\n        extendedConfigPath?: string;\n    }\n    export interface ExtendedConfigCacheEntry {\n        extendedResult: TsConfigSourceFile;\n        extendedConfig: ParsedTsconfig | undefined;\n    }\n    export function convertCompilerOptionsFromJson(jsonOptions: any, basePath: string, configFileName?: string): {\n        options: CompilerOptions;\n        errors: Diagnostic[];\n    };\n    export function convertTypeAcquisitionFromJson(jsonOptions: any, basePath: string, configFileName?: string): {\n        options: TypeAcquisition;\n        errors: Diagnostic[];\n    };\n    export {};\n}\ndeclare namespace ts {\n    function getEffectiveTypeRoots(options: CompilerOptions, host: GetEffectiveTypeRootsHost): string[] | undefined;\n    /**\n     * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.\n     * This is possible in case if resolution is performed for directives specified via \'types\' parameter. In this case initial path for secondary lookups\n     * is assumed to be the same as root directory of the project.\n     */\n    function resolveTypeReferenceDirective(typeReferenceDirectiveName: string, containingFile: string | undefined, options: CompilerOptions, host: ModuleResolutionHost, redirectedReference?: ResolvedProjectReference): ResolvedTypeReferenceDirectiveWithFailedLookupLocations;\n    /**\n     * Given a set of options, returns the set of type directive names\n     *   that should be included for this program automatically.\n     * This list could either come from the config file,\n     *   or from enumerating the types root + initial secondary types lookup location.\n     * More type directives might appear in the program later as a result of loading actual source files;\n     *   this list is only the set of defaults that are implicitly included.\n     */\n    function getAutomaticTypeDirectiveNames(options: CompilerOptions, host: ModuleResolutionHost): string[];\n    /**\n     * Cached module resolutions per containing directory.\n     * This assumes that any module id will have the same resolution for sibling files located in the same folder.\n     */\n    interface ModuleResolutionCache extends NonRelativeModuleNameResolutionCache {\n        getOrCreateCacheForDirectory(directoryName: string, redirectedReference?: ResolvedProjectReference): Map<ResolvedModuleWithFailedLookupLocations>;\n    }\n    /**\n     * Stored map from non-relative module name to a table: directory -> result of module lookup in this directory\n     * We support only non-relative module names because resolution of relative module names is usually more deterministic and thus less expensive.\n     */\n    interface NonRelativeModuleNameResolutionCache {\n        getOrCreateCacheForModuleName(nonRelativeModuleName: string, redirectedReference?: ResolvedProjectReference): PerModuleNameCache;\n    }\n    interface PerModuleNameCache {\n        get(directory: string): ResolvedModuleWithFailedLookupLocations | undefined;\n        set(directory: string, result: ResolvedModuleWithFailedLookupLocations): void;\n    }\n    function createModuleResolutionCache(currentDirectory: string, getCanonicalFileName: (s: string) => string, options?: CompilerOptions): ModuleResolutionCache;\n    function resolveModuleNameFromCache(moduleName: string, containingFile: string, cache: ModuleResolutionCache): ResolvedModuleWithFailedLookupLocations | undefined;\n    function resolveModuleName(moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: ModuleResolutionCache, redirectedReference?: ResolvedProjectReference): ResolvedModuleWithFailedLookupLocations;\n    function nodeModuleNameResolver(moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: ModuleResolutionCache, redirectedReference?: ResolvedProjectReference): ResolvedModuleWithFailedLookupLocations;\n    function classicNameResolver(moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: NonRelativeModuleNameResolutionCache, redirectedReference?: ResolvedProjectReference): ResolvedModuleWithFailedLookupLocations;\n}\ndeclare namespace ts {\n    function createNodeArray<T extends Node>(elements?: readonly T[], hasTrailingComma?: boolean): NodeArray<T>;\n    /** If a node is passed, creates a string literal whose source text is read from a source node during emit. */\n    function createLiteral(value: string | StringLiteral | NoSubstitutionTemplateLiteral | NumericLiteral | Identifier): StringLiteral;\n    function createLiteral(value: number | PseudoBigInt): NumericLiteral;\n    function createLiteral(value: boolean): BooleanLiteral;\n    function createLiteral(value: string | number | PseudoBigInt | boolean): PrimaryExpression;\n    function createNumericLiteral(value: string, numericLiteralFlags?: TokenFlags): NumericLiteral;\n    function createBigIntLiteral(value: string): BigIntLiteral;\n    function createStringLiteral(text: string): StringLiteral;\n    function createRegularExpressionLiteral(text: string): RegularExpressionLiteral;\n    function createIdentifier(text: string): Identifier;\n    function updateIdentifier(node: Identifier): Identifier;\n    /** Create a unique temporary variable. */\n    function createTempVariable(recordTempVariable: ((node: Identifier) => void) | undefined): Identifier;\n    /** Create a unique temporary variable for use in a loop. */\n    function createLoopVariable(): Identifier;\n    /** Create a unique name based on the supplied text. */\n    function createUniqueName(text: string): Identifier;\n    /** Create a unique name based on the supplied text. */\n    function createOptimisticUniqueName(text: string): Identifier;\n    /** Create a unique name based on the supplied text. This does not consider names injected by the transformer. */\n    function createFileLevelUniqueName(text: string): Identifier;\n    /** Create a unique name generated for a node. */\n    function getGeneratedNameForNode(node: Node | undefined): Identifier;\n    function createPrivateIdentifier(text: string): PrivateIdentifier;\n    function createToken<TKind extends SyntaxKind>(token: TKind): Token<TKind>;\n    function createSuper(): SuperExpression;\n    function createThis(): ThisExpression & Token<SyntaxKind.ThisKeyword>;\n    function createNull(): NullLiteral & Token<SyntaxKind.NullKeyword>;\n    function createTrue(): BooleanLiteral & Token<SyntaxKind.TrueKeyword>;\n    function createFalse(): BooleanLiteral & Token<SyntaxKind.FalseKeyword>;\n    function createModifier<T extends Modifier["kind"]>(kind: T): Token<T>;\n    function createModifiersFromModifierFlags(flags: ModifierFlags): Modifier[];\n    function createQualifiedName(left: EntityName, right: string | Identifier): QualifiedName;\n    function updateQualifiedName(node: QualifiedName, left: EntityName, right: Identifier): QualifiedName;\n    function createComputedPropertyName(expression: Expression): ComputedPropertyName;\n    function updateComputedPropertyName(node: ComputedPropertyName, expression: Expression): ComputedPropertyName;\n    function createTypeParameterDeclaration(name: string | Identifier, constraint?: TypeNode, defaultType?: TypeNode): TypeParameterDeclaration;\n    function updateTypeParameterDeclaration(node: TypeParameterDeclaration, name: Identifier, constraint: TypeNode | undefined, defaultType: TypeNode | undefined): TypeParameterDeclaration;\n    function createParameter(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, dotDotDotToken: DotDotDotToken | undefined, name: string | BindingName, questionToken?: QuestionToken, type?: TypeNode, initializer?: Expression): ParameterDeclaration;\n    function updateParameter(node: ParameterDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, dotDotDotToken: DotDotDotToken | undefined, name: string | BindingName, questionToken: QuestionToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): ParameterDeclaration;\n    function createDecorator(expression: Expression): Decorator;\n    function updateDecorator(node: Decorator, expression: Expression): Decorator;\n    function createPropertySignature(modifiers: readonly Modifier[] | undefined, name: PropertyName | string, questionToken: QuestionToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): PropertySignature;\n    function updatePropertySignature(node: PropertySignature, modifiers: readonly Modifier[] | undefined, name: PropertyName, questionToken: QuestionToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): PropertySignature;\n    function createProperty(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | PropertyName, questionOrExclamationToken: QuestionToken | ExclamationToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): PropertyDeclaration;\n    function updateProperty(node: PropertyDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | PropertyName, questionOrExclamationToken: QuestionToken | ExclamationToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): PropertyDeclaration;\n    function createMethodSignature(typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, name: string | PropertyName, questionToken: QuestionToken | undefined): MethodSignature;\n    function updateMethodSignature(node: MethodSignature, typeParameters: NodeArray<TypeParameterDeclaration> | undefined, parameters: NodeArray<ParameterDeclaration>, type: TypeNode | undefined, name: PropertyName, questionToken: QuestionToken | undefined): MethodSignature;\n    function createMethod(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: string | PropertyName, questionToken: QuestionToken | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): MethodDeclaration;\n    function updateMethod(node: MethodDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: PropertyName, questionToken: QuestionToken | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): MethodDeclaration;\n    function createConstructor(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, parameters: readonly ParameterDeclaration[], body: Block | undefined): ConstructorDeclaration;\n    function updateConstructor(node: ConstructorDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, parameters: readonly ParameterDeclaration[], body: Block | undefined): ConstructorDeclaration;\n    function createGetAccessor(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | PropertyName, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): GetAccessorDeclaration;\n    function updateGetAccessor(node: GetAccessorDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: PropertyName, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): GetAccessorDeclaration;\n    function createSetAccessor(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | PropertyName, parameters: readonly ParameterDeclaration[], body: Block | undefined): SetAccessorDeclaration;\n    function updateSetAccessor(node: SetAccessorDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: PropertyName, parameters: readonly ParameterDeclaration[], body: Block | undefined): SetAccessorDeclaration;\n    function createCallSignature(typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined): CallSignatureDeclaration;\n    function updateCallSignature(node: CallSignatureDeclaration, typeParameters: NodeArray<TypeParameterDeclaration> | undefined, parameters: NodeArray<ParameterDeclaration>, type: TypeNode | undefined): CallSignatureDeclaration;\n    function createConstructSignature(typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined): ConstructSignatureDeclaration;\n    function updateConstructSignature(node: ConstructSignatureDeclaration, typeParameters: NodeArray<TypeParameterDeclaration> | undefined, parameters: NodeArray<ParameterDeclaration>, type: TypeNode | undefined): ConstructSignatureDeclaration;\n    function createIndexSignature(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode): IndexSignatureDeclaration;\n    function updateIndexSignature(node: IndexSignatureDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode): IndexSignatureDeclaration;\n    function createKeywordTypeNode(kind: KeywordTypeNode["kind"]): KeywordTypeNode;\n    function createTypePredicateNode(parameterName: Identifier | ThisTypeNode | string, type: TypeNode): TypePredicateNode;\n    function createTypePredicateNodeWithModifier(assertsModifier: AssertsToken | undefined, parameterName: Identifier | ThisTypeNode | string, type: TypeNode | undefined): TypePredicateNode;\n    function updateTypePredicateNode(node: TypePredicateNode, parameterName: Identifier | ThisTypeNode, type: TypeNode): TypePredicateNode;\n    function updateTypePredicateNodeWithModifier(node: TypePredicateNode, assertsModifier: AssertsToken | undefined, parameterName: Identifier | ThisTypeNode, type: TypeNode | undefined): TypePredicateNode;\n    function createTypeReferenceNode(typeName: string | EntityName, typeArguments: readonly TypeNode[] | undefined): TypeReferenceNode;\n    function updateTypeReferenceNode(node: TypeReferenceNode, typeName: EntityName, typeArguments: NodeArray<TypeNode> | undefined): TypeReferenceNode;\n    function createFunctionTypeNode(typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined): FunctionTypeNode;\n    function updateFunctionTypeNode(node: FunctionTypeNode, typeParameters: NodeArray<TypeParameterDeclaration> | undefined, parameters: NodeArray<ParameterDeclaration>, type: TypeNode | undefined): FunctionTypeNode;\n    function createConstructorTypeNode(typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined): ConstructorTypeNode;\n    function updateConstructorTypeNode(node: ConstructorTypeNode, typeParameters: NodeArray<TypeParameterDeclaration> | undefined, parameters: NodeArray<ParameterDeclaration>, type: TypeNode | undefined): ConstructorTypeNode;\n    function createTypeQueryNode(exprName: EntityName): TypeQueryNode;\n    function updateTypeQueryNode(node: TypeQueryNode, exprName: EntityName): TypeQueryNode;\n    function createTypeLiteralNode(members: readonly TypeElement[] | undefined): TypeLiteralNode;\n    function updateTypeLiteralNode(node: TypeLiteralNode, members: NodeArray<TypeElement>): TypeLiteralNode;\n    function createArrayTypeNode(elementType: TypeNode): ArrayTypeNode;\n    function updateArrayTypeNode(node: ArrayTypeNode, elementType: TypeNode): ArrayTypeNode;\n    function createTupleTypeNode(elementTypes: readonly TypeNode[]): TupleTypeNode;\n    function updateTupleTypeNode(node: TupleTypeNode, elementTypes: readonly TypeNode[]): TupleTypeNode;\n    function createOptionalTypeNode(type: TypeNode): OptionalTypeNode;\n    function updateOptionalTypeNode(node: OptionalTypeNode, type: TypeNode): OptionalTypeNode;\n    function createRestTypeNode(type: TypeNode): RestTypeNode;\n    function updateRestTypeNode(node: RestTypeNode, type: TypeNode): RestTypeNode;\n    function createUnionTypeNode(types: readonly TypeNode[]): UnionTypeNode;\n    function updateUnionTypeNode(node: UnionTypeNode, types: NodeArray<TypeNode>): UnionTypeNode;\n    function createIntersectionTypeNode(types: readonly TypeNode[]): IntersectionTypeNode;\n    function updateIntersectionTypeNode(node: IntersectionTypeNode, types: NodeArray<TypeNode>): IntersectionTypeNode;\n    function createUnionOrIntersectionTypeNode(kind: SyntaxKind.UnionType | SyntaxKind.IntersectionType, types: readonly TypeNode[]): UnionOrIntersectionTypeNode;\n    function createConditionalTypeNode(checkType: TypeNode, extendsType: TypeNode, trueType: TypeNode, falseType: TypeNode): ConditionalTypeNode;\n    function updateConditionalTypeNode(node: ConditionalTypeNode, checkType: TypeNode, extendsType: TypeNode, trueType: TypeNode, falseType: TypeNode): ConditionalTypeNode;\n    function createInferTypeNode(typeParameter: TypeParameterDeclaration): InferTypeNode;\n    function updateInferTypeNode(node: InferTypeNode, typeParameter: TypeParameterDeclaration): InferTypeNode;\n    function createImportTypeNode(argument: TypeNode, qualifier?: EntityName, typeArguments?: readonly TypeNode[], isTypeOf?: boolean): ImportTypeNode;\n    function updateImportTypeNode(node: ImportTypeNode, argument: TypeNode, qualifier?: EntityName, typeArguments?: readonly TypeNode[], isTypeOf?: boolean): ImportTypeNode;\n    function createParenthesizedType(type: TypeNode): ParenthesizedTypeNode;\n    function updateParenthesizedType(node: ParenthesizedTypeNode, type: TypeNode): ParenthesizedTypeNode;\n    function createThisTypeNode(): ThisTypeNode;\n    function createTypeOperatorNode(type: TypeNode): TypeOperatorNode;\n    function createTypeOperatorNode(operator: SyntaxKind.KeyOfKeyword | SyntaxKind.UniqueKeyword | SyntaxKind.ReadonlyKeyword, type: TypeNode): TypeOperatorNode;\n    function updateTypeOperatorNode(node: TypeOperatorNode, type: TypeNode): TypeOperatorNode;\n    function createIndexedAccessTypeNode(objectType: TypeNode, indexType: TypeNode): IndexedAccessTypeNode;\n    function updateIndexedAccessTypeNode(node: IndexedAccessTypeNode, objectType: TypeNode, indexType: TypeNode): IndexedAccessTypeNode;\n    function createMappedTypeNode(readonlyToken: ReadonlyToken | PlusToken | MinusToken | undefined, typeParameter: TypeParameterDeclaration, questionToken: QuestionToken | PlusToken | MinusToken | undefined, type: TypeNode | undefined): MappedTypeNode;\n    function updateMappedTypeNode(node: MappedTypeNode, readonlyToken: ReadonlyToken | PlusToken | MinusToken | undefined, typeParameter: TypeParameterDeclaration, questionToken: QuestionToken | PlusToken | MinusToken | undefined, type: TypeNode | undefined): MappedTypeNode;\n    function createLiteralTypeNode(literal: LiteralTypeNode["literal"]): LiteralTypeNode;\n    function updateLiteralTypeNode(node: LiteralTypeNode, literal: LiteralTypeNode["literal"]): LiteralTypeNode;\n    function createObjectBindingPattern(elements: readonly BindingElement[]): ObjectBindingPattern;\n    function updateObjectBindingPattern(node: ObjectBindingPattern, elements: readonly BindingElement[]): ObjectBindingPattern;\n    function createArrayBindingPattern(elements: readonly ArrayBindingElement[]): ArrayBindingPattern;\n    function updateArrayBindingPattern(node: ArrayBindingPattern, elements: readonly ArrayBindingElement[]): ArrayBindingPattern;\n    function createBindingElement(dotDotDotToken: DotDotDotToken | undefined, propertyName: string | PropertyName | undefined, name: string | BindingName, initializer?: Expression): BindingElement;\n    function updateBindingElement(node: BindingElement, dotDotDotToken: DotDotDotToken | undefined, propertyName: PropertyName | undefined, name: BindingName, initializer: Expression | undefined): BindingElement;\n    function createArrayLiteral(elements?: readonly Expression[], multiLine?: boolean): ArrayLiteralExpression;\n    function updateArrayLiteral(node: ArrayLiteralExpression, elements: readonly Expression[]): ArrayLiteralExpression;\n    function createObjectLiteral(properties?: readonly ObjectLiteralElementLike[], multiLine?: boolean): ObjectLiteralExpression;\n    function updateObjectLiteral(node: ObjectLiteralExpression, properties: readonly ObjectLiteralElementLike[]): ObjectLiteralExpression;\n    function createPropertyAccess(expression: Expression, name: string | Identifier | PrivateIdentifier): PropertyAccessExpression;\n    function updatePropertyAccess(node: PropertyAccessExpression, expression: Expression, name: Identifier | PrivateIdentifier): PropertyAccessExpression;\n    function createPropertyAccessChain(expression: Expression, questionDotToken: QuestionDotToken | undefined, name: string | Identifier): PropertyAccessChain;\n    function updatePropertyAccessChain(node: PropertyAccessChain, expression: Expression, questionDotToken: QuestionDotToken | undefined, name: Identifier): PropertyAccessChain;\n    function createElementAccess(expression: Expression, index: number | Expression): ElementAccessExpression;\n    function updateElementAccess(node: ElementAccessExpression, expression: Expression, argumentExpression: Expression): ElementAccessExpression;\n    function createElementAccessChain(expression: Expression, questionDotToken: QuestionDotToken | undefined, index: number | Expression): ElementAccessChain;\n    function updateElementAccessChain(node: ElementAccessChain, expression: Expression, questionDotToken: QuestionDotToken | undefined, argumentExpression: Expression): ElementAccessChain;\n    function createCall(expression: Expression, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[] | undefined): CallExpression;\n    function updateCall(node: CallExpression, expression: Expression, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[]): CallExpression;\n    function createCallChain(expression: Expression, questionDotToken: QuestionDotToken | undefined, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[] | undefined): CallChain;\n    function updateCallChain(node: CallChain, expression: Expression, questionDotToken: QuestionDotToken | undefined, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[]): CallChain;\n    function createNew(expression: Expression, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[] | undefined): NewExpression;\n    function updateNew(node: NewExpression, expression: Expression, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[] | undefined): NewExpression;\n    /** @deprecated */ function createTaggedTemplate(tag: Expression, template: TemplateLiteral): TaggedTemplateExpression;\n    function createTaggedTemplate(tag: Expression, typeArguments: readonly TypeNode[] | undefined, template: TemplateLiteral): TaggedTemplateExpression;\n    /** @deprecated */ function updateTaggedTemplate(node: TaggedTemplateExpression, tag: Expression, template: TemplateLiteral): TaggedTemplateExpression;\n    function updateTaggedTemplate(node: TaggedTemplateExpression, tag: Expression, typeArguments: readonly TypeNode[] | undefined, template: TemplateLiteral): TaggedTemplateExpression;\n    function createTypeAssertion(type: TypeNode, expression: Expression): TypeAssertion;\n    function updateTypeAssertion(node: TypeAssertion, type: TypeNode, expression: Expression): TypeAssertion;\n    function createParen(expression: Expression): ParenthesizedExpression;\n    function updateParen(node: ParenthesizedExpression, expression: Expression): ParenthesizedExpression;\n    function createFunctionExpression(modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[] | undefined, type: TypeNode | undefined, body: Block): FunctionExpression;\n    function updateFunctionExpression(node: FunctionExpression, modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block): FunctionExpression;\n    function createArrowFunction(modifiers: readonly Modifier[] | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, equalsGreaterThanToken: EqualsGreaterThanToken | undefined, body: ConciseBody): ArrowFunction;\n    function updateArrowFunction(node: ArrowFunction, modifiers: readonly Modifier[] | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, equalsGreaterThanToken: Token<SyntaxKind.EqualsGreaterThanToken>, body: ConciseBody): ArrowFunction;\n    function createDelete(expression: Expression): DeleteExpression;\n    function updateDelete(node: DeleteExpression, expression: Expression): DeleteExpression;\n    function createTypeOf(expression: Expression): TypeOfExpression;\n    function updateTypeOf(node: TypeOfExpression, expression: Expression): TypeOfExpression;\n    function createVoid(expression: Expression): VoidExpression;\n    function updateVoid(node: VoidExpression, expression: Expression): VoidExpression;\n    function createAwait(expression: Expression): AwaitExpression;\n    function updateAwait(node: AwaitExpression, expression: Expression): AwaitExpression;\n    function createPrefix(operator: PrefixUnaryOperator, operand: Expression): PrefixUnaryExpression;\n    function updatePrefix(node: PrefixUnaryExpression, operand: Expression): PrefixUnaryExpression;\n    function createPostfix(operand: Expression, operator: PostfixUnaryOperator): PostfixUnaryExpression;\n    function updatePostfix(node: PostfixUnaryExpression, operand: Expression): PostfixUnaryExpression;\n    function createBinary(left: Expression, operator: BinaryOperator | BinaryOperatorToken, right: Expression): BinaryExpression;\n    function updateBinary(node: BinaryExpression, left: Expression, right: Expression, operator?: BinaryOperator | BinaryOperatorToken): BinaryExpression;\n    /** @deprecated */ function createConditional(condition: Expression, whenTrue: Expression, whenFalse: Expression): ConditionalExpression;\n    function createConditional(condition: Expression, questionToken: QuestionToken, whenTrue: Expression, colonToken: ColonToken, whenFalse: Expression): ConditionalExpression;\n    function updateConditional(node: ConditionalExpression, condition: Expression, questionToken: Token<SyntaxKind.QuestionToken>, whenTrue: Expression, colonToken: Token<SyntaxKind.ColonToken>, whenFalse: Expression): ConditionalExpression;\n    function createTemplateExpression(head: TemplateHead, templateSpans: readonly TemplateSpan[]): TemplateExpression;\n    function updateTemplateExpression(node: TemplateExpression, head: TemplateHead, templateSpans: readonly TemplateSpan[]): TemplateExpression;\n    function createTemplateHead(text: string, rawText?: string): TemplateHead;\n    function createTemplateMiddle(text: string, rawText?: string): TemplateMiddle;\n    function createTemplateTail(text: string, rawText?: string): TemplateTail;\n    function createNoSubstitutionTemplateLiteral(text: string, rawText?: string): NoSubstitutionTemplateLiteral;\n    function createYield(expression?: Expression): YieldExpression;\n    function createYield(asteriskToken: AsteriskToken | undefined, expression: Expression): YieldExpression;\n    function updateYield(node: YieldExpression, asteriskToken: AsteriskToken | undefined, expression: Expression): YieldExpression;\n    function createSpread(expression: Expression): SpreadElement;\n    function updateSpread(node: SpreadElement, expression: Expression): SpreadElement;\n    function createClassExpression(modifiers: readonly Modifier[] | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]): ClassExpression;\n    function updateClassExpression(node: ClassExpression, modifiers: readonly Modifier[] | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]): ClassExpression;\n    function createOmittedExpression(): OmittedExpression;\n    function createExpressionWithTypeArguments(typeArguments: readonly TypeNode[] | undefined, expression: Expression): ExpressionWithTypeArguments;\n    function updateExpressionWithTypeArguments(node: ExpressionWithTypeArguments, typeArguments: readonly TypeNode[] | undefined, expression: Expression): ExpressionWithTypeArguments;\n    function createAsExpression(expression: Expression, type: TypeNode): AsExpression;\n    function updateAsExpression(node: AsExpression, expression: Expression, type: TypeNode): AsExpression;\n    function createNonNullExpression(expression: Expression): NonNullExpression;\n    function updateNonNullExpression(node: NonNullExpression, expression: Expression): NonNullExpression;\n    function createNonNullChain(expression: Expression): NonNullChain;\n    function updateNonNullChain(node: NonNullChain, expression: Expression): NonNullChain;\n    function createMetaProperty(keywordToken: MetaProperty["keywordToken"], name: Identifier): MetaProperty;\n    function updateMetaProperty(node: MetaProperty, name: Identifier): MetaProperty;\n    function createTemplateSpan(expression: Expression, literal: TemplateMiddle | TemplateTail): TemplateSpan;\n    function updateTemplateSpan(node: TemplateSpan, expression: Expression, literal: TemplateMiddle | TemplateTail): TemplateSpan;\n    function createSemicolonClassElement(): SemicolonClassElement;\n    function createBlock(statements: readonly Statement[], multiLine?: boolean): Block;\n    function updateBlock(node: Block, statements: readonly Statement[]): Block;\n    function createVariableStatement(modifiers: readonly Modifier[] | undefined, declarationList: VariableDeclarationList | readonly VariableDeclaration[]): VariableStatement;\n    function updateVariableStatement(node: VariableStatement, modifiers: readonly Modifier[] | undefined, declarationList: VariableDeclarationList): VariableStatement;\n    function createEmptyStatement(): EmptyStatement;\n    function createExpressionStatement(expression: Expression): ExpressionStatement;\n    function updateExpressionStatement(node: ExpressionStatement, expression: Expression): ExpressionStatement;\n    /** @deprecated Use `createExpressionStatement` instead.  */\n    const createStatement: typeof createExpressionStatement;\n    /** @deprecated Use `updateExpressionStatement` instead.  */\n    const updateStatement: typeof updateExpressionStatement;\n    function createIf(expression: Expression, thenStatement: Statement, elseStatement?: Statement): IfStatement;\n    function updateIf(node: IfStatement, expression: Expression, thenStatement: Statement, elseStatement: Statement | undefined): IfStatement;\n    function createDo(statement: Statement, expression: Expression): DoStatement;\n    function updateDo(node: DoStatement, statement: Statement, expression: Expression): DoStatement;\n    function createWhile(expression: Expression, statement: Statement): WhileStatement;\n    function updateWhile(node: WhileStatement, expression: Expression, statement: Statement): WhileStatement;\n    function createFor(initializer: ForInitializer | undefined, condition: Expression | undefined, incrementor: Expression | undefined, statement: Statement): ForStatement;\n    function updateFor(node: ForStatement, initializer: ForInitializer | undefined, condition: Expression | undefined, incrementor: Expression | undefined, statement: Statement): ForStatement;\n    function createForIn(initializer: ForInitializer, expression: Expression, statement: Statement): ForInStatement;\n    function updateForIn(node: ForInStatement, initializer: ForInitializer, expression: Expression, statement: Statement): ForInStatement;\n    function createForOf(awaitModifier: AwaitKeywordToken | undefined, initializer: ForInitializer, expression: Expression, statement: Statement): ForOfStatement;\n    function updateForOf(node: ForOfStatement, awaitModifier: AwaitKeywordToken | undefined, initializer: ForInitializer, expression: Expression, statement: Statement): ForOfStatement;\n    function createContinue(label?: string | Identifier): ContinueStatement;\n    function updateContinue(node: ContinueStatement, label: Identifier | undefined): ContinueStatement;\n    function createBreak(label?: string | Identifier): BreakStatement;\n    function updateBreak(node: BreakStatement, label: Identifier | undefined): BreakStatement;\n    function createReturn(expression?: Expression): ReturnStatement;\n    function updateReturn(node: ReturnStatement, expression: Expression | undefined): ReturnStatement;\n    function createWith(expression: Expression, statement: Statement): WithStatement;\n    function updateWith(node: WithStatement, expression: Expression, statement: Statement): WithStatement;\n    function createSwitch(expression: Expression, caseBlock: CaseBlock): SwitchStatement;\n    function updateSwitch(node: SwitchStatement, expression: Expression, caseBlock: CaseBlock): SwitchStatement;\n    function createLabel(label: string | Identifier, statement: Statement): LabeledStatement;\n    function updateLabel(node: LabeledStatement, label: Identifier, statement: Statement): LabeledStatement;\n    function createThrow(expression: Expression): ThrowStatement;\n    function updateThrow(node: ThrowStatement, expression: Expression): ThrowStatement;\n    function createTry(tryBlock: Block, catchClause: CatchClause | undefined, finallyBlock: Block | undefined): TryStatement;\n    function updateTry(node: TryStatement, tryBlock: Block, catchClause: CatchClause | undefined, finallyBlock: Block | undefined): TryStatement;\n    function createDebuggerStatement(): DebuggerStatement;\n    function createVariableDeclaration(name: string | BindingName, type?: TypeNode, initializer?: Expression): VariableDeclaration;\n    function updateVariableDeclaration(node: VariableDeclaration, name: BindingName, type: TypeNode | undefined, initializer: Expression | undefined): VariableDeclaration;\n    function createVariableDeclarationList(declarations: readonly VariableDeclaration[], flags?: NodeFlags): VariableDeclarationList;\n    function updateVariableDeclarationList(node: VariableDeclarationList, declarations: readonly VariableDeclaration[]): VariableDeclarationList;\n    function createFunctionDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): FunctionDeclaration;\n    function updateFunctionDeclaration(node: FunctionDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): FunctionDeclaration;\n    function createClassDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]): ClassDeclaration;\n    function updateClassDeclaration(node: ClassDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]): ClassDeclaration;\n    function createInterfaceDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly TypeElement[]): InterfaceDeclaration;\n    function updateInterfaceDeclaration(node: InterfaceDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly TypeElement[]): InterfaceDeclaration;\n    function createTypeAliasDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, type: TypeNode): TypeAliasDeclaration;\n    function updateTypeAliasDeclaration(node: TypeAliasDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, type: TypeNode): TypeAliasDeclaration;\n    function createEnumDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | Identifier, members: readonly EnumMember[]): EnumDeclaration;\n    function updateEnumDeclaration(node: EnumDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: Identifier, members: readonly EnumMember[]): EnumDeclaration;\n    function createModuleDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: ModuleName, body: ModuleBody | undefined, flags?: NodeFlags): ModuleDeclaration;\n    function updateModuleDeclaration(node: ModuleDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: ModuleName, body: ModuleBody | undefined): ModuleDeclaration;\n    function createModuleBlock(statements: readonly Statement[]): ModuleBlock;\n    function updateModuleBlock(node: ModuleBlock, statements: readonly Statement[]): ModuleBlock;\n    function createCaseBlock(clauses: readonly CaseOrDefaultClause[]): CaseBlock;\n    function updateCaseBlock(node: CaseBlock, clauses: readonly CaseOrDefaultClause[]): CaseBlock;\n    function createNamespaceExportDeclaration(name: string | Identifier): NamespaceExportDeclaration;\n    function updateNamespaceExportDeclaration(node: NamespaceExportDeclaration, name: Identifier): NamespaceExportDeclaration;\n    function createImportEqualsDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | Identifier, moduleReference: ModuleReference): ImportEqualsDeclaration;\n    function updateImportEqualsDeclaration(node: ImportEqualsDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: Identifier, moduleReference: ModuleReference): ImportEqualsDeclaration;\n    function createImportDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, importClause: ImportClause | undefined, moduleSpecifier: Expression): ImportDeclaration;\n    function updateImportDeclaration(node: ImportDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, importClause: ImportClause | undefined, moduleSpecifier: Expression): ImportDeclaration;\n    function createImportClause(name: Identifier | undefined, namedBindings: NamedImportBindings | undefined, isTypeOnly?: boolean): ImportClause;\n    function updateImportClause(node: ImportClause, name: Identifier | undefined, namedBindings: NamedImportBindings | undefined, isTypeOnly: boolean): ImportClause;\n    function createNamespaceImport(name: Identifier): NamespaceImport;\n    function createNamespaceExport(name: Identifier): NamespaceExport;\n    function updateNamespaceImport(node: NamespaceImport, name: Identifier): NamespaceImport;\n    function updateNamespaceExport(node: NamespaceExport, name: Identifier): NamespaceExport;\n    function createNamedImports(elements: readonly ImportSpecifier[]): NamedImports;\n    function updateNamedImports(node: NamedImports, elements: readonly ImportSpecifier[]): NamedImports;\n    function createImportSpecifier(propertyName: Identifier | undefined, name: Identifier): ImportSpecifier;\n    function updateImportSpecifier(node: ImportSpecifier, propertyName: Identifier | undefined, name: Identifier): ImportSpecifier;\n    function createExportAssignment(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, isExportEquals: boolean | undefined, expression: Expression): ExportAssignment;\n    function updateExportAssignment(node: ExportAssignment, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, expression: Expression): ExportAssignment;\n    function createExportDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, exportClause: NamedExportBindings | undefined, moduleSpecifier?: Expression, isTypeOnly?: boolean): ExportDeclaration;\n    function updateExportDeclaration(node: ExportDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, exportClause: NamedExportBindings | undefined, moduleSpecifier: Expression | undefined, isTypeOnly: boolean): ExportDeclaration;\n    function createNamedExports(elements: readonly ExportSpecifier[]): NamedExports;\n    function updateNamedExports(node: NamedExports, elements: readonly ExportSpecifier[]): NamedExports;\n    function createExportSpecifier(propertyName: string | Identifier | undefined, name: string | Identifier): ExportSpecifier;\n    function updateExportSpecifier(node: ExportSpecifier, propertyName: Identifier | undefined, name: Identifier): ExportSpecifier;\n    function createExternalModuleReference(expression: Expression): ExternalModuleReference;\n    function updateExternalModuleReference(node: ExternalModuleReference, expression: Expression): ExternalModuleReference;\n    function createJsxElement(openingElement: JsxOpeningElement, children: readonly JsxChild[], closingElement: JsxClosingElement): JsxElement;\n    function updateJsxElement(node: JsxElement, openingElement: JsxOpeningElement, children: readonly JsxChild[], closingElement: JsxClosingElement): JsxElement;\n    function createJsxSelfClosingElement(tagName: JsxTagNameExpression, typeArguments: readonly TypeNode[] | undefined, attributes: JsxAttributes): JsxSelfClosingElement;\n    function updateJsxSelfClosingElement(node: JsxSelfClosingElement, tagName: JsxTagNameExpression, typeArguments: readonly TypeNode[] | undefined, attributes: JsxAttributes): JsxSelfClosingElement;\n    function createJsxOpeningElement(tagName: JsxTagNameExpression, typeArguments: readonly TypeNode[] | undefined, attributes: JsxAttributes): JsxOpeningElement;\n    function updateJsxOpeningElement(node: JsxOpeningElement, tagName: JsxTagNameExpression, typeArguments: readonly TypeNode[] | undefined, attributes: JsxAttributes): JsxOpeningElement;\n    function createJsxClosingElement(tagName: JsxTagNameExpression): JsxClosingElement;\n    function updateJsxClosingElement(node: JsxClosingElement, tagName: JsxTagNameExpression): JsxClosingElement;\n    function createJsxFragment(openingFragment: JsxOpeningFragment, children: readonly JsxChild[], closingFragment: JsxClosingFragment): JsxFragment;\n    function createJsxText(text: string, containsOnlyTriviaWhiteSpaces?: boolean): JsxText;\n    function updateJsxText(node: JsxText, text: string, containsOnlyTriviaWhiteSpaces?: boolean): JsxText;\n    function createJsxOpeningFragment(): JsxOpeningFragment;\n    function createJsxJsxClosingFragment(): JsxClosingFragment;\n    function updateJsxFragment(node: JsxFragment, openingFragment: JsxOpeningFragment, children: readonly JsxChild[], closingFragment: JsxClosingFragment): JsxFragment;\n    function createJsxAttribute(name: Identifier, initializer: StringLiteral | JsxExpression): JsxAttribute;\n    function updateJsxAttribute(node: JsxAttribute, name: Identifier, initializer: StringLiteral | JsxExpression): JsxAttribute;\n    function createJsxAttributes(properties: readonly JsxAttributeLike[]): JsxAttributes;\n    function updateJsxAttributes(node: JsxAttributes, properties: readonly JsxAttributeLike[]): JsxAttributes;\n    function createJsxSpreadAttribute(expression: Expression): JsxSpreadAttribute;\n    function updateJsxSpreadAttribute(node: JsxSpreadAttribute, expression: Expression): JsxSpreadAttribute;\n    function createJsxExpression(dotDotDotToken: DotDotDotToken | undefined, expression: Expression | undefined): JsxExpression;\n    function updateJsxExpression(node: JsxExpression, expression: Expression | undefined): JsxExpression;\n    function createCaseClause(expression: Expression, statements: readonly Statement[]): CaseClause;\n    function updateCaseClause(node: CaseClause, expression: Expression, statements: readonly Statement[]): CaseClause;\n    function createDefaultClause(statements: readonly Statement[]): DefaultClause;\n    function updateDefaultClause(node: DefaultClause, statements: readonly Statement[]): DefaultClause;\n    function createHeritageClause(token: HeritageClause["token"], types: readonly ExpressionWithTypeArguments[]): HeritageClause;\n    function updateHeritageClause(node: HeritageClause, types: readonly ExpressionWithTypeArguments[]): HeritageClause;\n    function createCatchClause(variableDeclaration: string | VariableDeclaration | undefined, block: Block): CatchClause;\n    function updateCatchClause(node: CatchClause, variableDeclaration: VariableDeclaration | undefined, block: Block): CatchClause;\n    function createPropertyAssignment(name: string | PropertyName, initializer: Expression): PropertyAssignment;\n    function updatePropertyAssignment(node: PropertyAssignment, name: PropertyName, initializer: Expression): PropertyAssignment;\n    function createShorthandPropertyAssignment(name: string | Identifier, objectAssignmentInitializer?: Expression): ShorthandPropertyAssignment;\n    function updateShorthandPropertyAssignment(node: ShorthandPropertyAssignment, name: Identifier, objectAssignmentInitializer: Expression | undefined): ShorthandPropertyAssignment;\n    function createSpreadAssignment(expression: Expression): SpreadAssignment;\n    function updateSpreadAssignment(node: SpreadAssignment, expression: Expression): SpreadAssignment;\n    function createEnumMember(name: string | PropertyName, initializer?: Expression): EnumMember;\n    function updateEnumMember(node: EnumMember, name: PropertyName, initializer: Expression | undefined): EnumMember;\n    function updateSourceFileNode(node: SourceFile, statements: readonly Statement[], isDeclarationFile?: boolean, referencedFiles?: SourceFile["referencedFiles"], typeReferences?: SourceFile["typeReferenceDirectives"], hasNoDefaultLib?: boolean, libReferences?: SourceFile["libReferenceDirectives"]): SourceFile;\n    /**\n     * Creates a shallow, memberwise clone of a node for mutation.\n     */\n    function getMutableClone<T extends Node>(node: T): T;\n    /**\n     * Creates a synthetic statement to act as a placeholder for a not-emitted statement in\n     * order to preserve comments.\n     *\n     * @param original The original statement.\n     */\n    function createNotEmittedStatement(original: Node): NotEmittedStatement;\n    /**\n     * Creates a synthetic expression to act as a placeholder for a not-emitted expression in\n     * order to preserve comments or sourcemap positions.\n     *\n     * @param expression The inner expression to emit.\n     * @param original The original outer expression.\n     * @param location The location for the expression. Defaults to the positions from "original" if provided.\n     */\n    function createPartiallyEmittedExpression(expression: Expression, original?: Node): PartiallyEmittedExpression;\n    function updatePartiallyEmittedExpression(node: PartiallyEmittedExpression, expression: Expression): PartiallyEmittedExpression;\n    function createCommaList(elements: readonly Expression[]): CommaListExpression;\n    function updateCommaList(node: CommaListExpression, elements: readonly Expression[]): CommaListExpression;\n    function createBundle(sourceFiles: readonly SourceFile[], prepends?: readonly (UnparsedSource | InputFiles)[]): Bundle;\n    function createUnparsedSourceFile(text: string): UnparsedSource;\n    function createUnparsedSourceFile(inputFile: InputFiles, type: "js" | "dts", stripInternal?: boolean): UnparsedSource;\n    function createUnparsedSourceFile(text: string, mapPath: string | undefined, map: string | undefined): UnparsedSource;\n    function createInputFiles(javascriptText: string, declarationText: string): InputFiles;\n    function createInputFiles(readFileText: (path: string) => string | undefined, javascriptPath: string, javascriptMapPath: string | undefined, declarationPath: string, declarationMapPath: string | undefined, buildInfoPath: string | undefined): InputFiles;\n    function createInputFiles(javascriptText: string, declarationText: string, javascriptMapPath: string | undefined, javascriptMapText: string | undefined, declarationMapPath: string | undefined, declarationMapText: string | undefined): InputFiles;\n    function updateBundle(node: Bundle, sourceFiles: readonly SourceFile[], prepends?: readonly (UnparsedSource | InputFiles)[]): Bundle;\n    function createImmediatelyInvokedFunctionExpression(statements: readonly Statement[]): CallExpression;\n    function createImmediatelyInvokedFunctionExpression(statements: readonly Statement[], param: ParameterDeclaration, paramValue: Expression): CallExpression;\n    function createImmediatelyInvokedArrowFunction(statements: readonly Statement[]): CallExpression;\n    function createImmediatelyInvokedArrowFunction(statements: readonly Statement[], param: ParameterDeclaration, paramValue: Expression): CallExpression;\n    function createComma(left: Expression, right: Expression): Expression;\n    function createLessThan(left: Expression, right: Expression): Expression;\n    function createAssignment(left: ObjectLiteralExpression | ArrayLiteralExpression, right: Expression): DestructuringAssignment;\n    function createAssignment(left: Expression, right: Expression): BinaryExpression;\n    function createStrictEquality(left: Expression, right: Expression): BinaryExpression;\n    function createStrictInequality(left: Expression, right: Expression): BinaryExpression;\n    function createAdd(left: Expression, right: Expression): BinaryExpression;\n    function createSubtract(left: Expression, right: Expression): BinaryExpression;\n    function createPostfixIncrement(operand: Expression): PostfixUnaryExpression;\n    function createLogicalAnd(left: Expression, right: Expression): BinaryExpression;\n    function createLogicalOr(left: Expression, right: Expression): BinaryExpression;\n    function createNullishCoalesce(left: Expression, right: Expression): BinaryExpression;\n    function createLogicalNot(operand: Expression): PrefixUnaryExpression;\n    function createVoidZero(): VoidExpression;\n    function createExportDefault(expression: Expression): ExportAssignment;\n    function createExternalModuleExport(exportName: Identifier): ExportDeclaration;\n    /**\n     * Clears any EmitNode entries from parse-tree nodes.\n     * @param sourceFile A source file.\n     */\n    function disposeEmitNodes(sourceFile: SourceFile): void;\n    function setTextRange<T extends TextRange>(range: T, location: TextRange | undefined): T;\n    /**\n     * Sets flags that control emit behavior of a node.\n     */\n    function setEmitFlags<T extends Node>(node: T, emitFlags: EmitFlags): T;\n    /**\n     * Gets a custom text range to use when emitting source maps.\n     */\n    function getSourceMapRange(node: Node): SourceMapRange;\n    /**\n     * Sets a custom text range to use when emitting source maps.\n     */\n    function setSourceMapRange<T extends Node>(node: T, range: SourceMapRange | undefined): T;\n    /**\n     * Create an external source map source file reference\n     */\n    function createSourceMapSource(fileName: string, text: string, skipTrivia?: (pos: number) => number): SourceMapSource;\n    /**\n     * Gets the TextRange to use for source maps for a token of a node.\n     */\n    function getTokenSourceMapRange(node: Node, token: SyntaxKind): SourceMapRange | undefined;\n    /**\n     * Sets the TextRange to use for source maps for a token of a node.\n     */\n    function setTokenSourceMapRange<T extends Node>(node: T, token: SyntaxKind, range: SourceMapRange | undefined): T;\n    /**\n     * Gets a custom text range to use when emitting comments.\n     */\n    function getCommentRange(node: Node): TextRange;\n    /**\n     * Sets a custom text range to use when emitting comments.\n     */\n    function setCommentRange<T extends Node>(node: T, range: TextRange): T;\n    function getSyntheticLeadingComments(node: Node): SynthesizedComment[] | undefined;\n    function setSyntheticLeadingComments<T extends Node>(node: T, comments: SynthesizedComment[] | undefined): T;\n    function addSyntheticLeadingComment<T extends Node>(node: T, kind: SyntaxKind.SingleLineCommentTrivia | SyntaxKind.MultiLineCommentTrivia, text: string, hasTrailingNewLine?: boolean): T;\n    function getSyntheticTrailingComments(node: Node): SynthesizedComment[] | undefined;\n    function setSyntheticTrailingComments<T extends Node>(node: T, comments: SynthesizedComment[] | undefined): T;\n    function addSyntheticTrailingComment<T extends Node>(node: T, kind: SyntaxKind.SingleLineCommentTrivia | SyntaxKind.MultiLineCommentTrivia, text: string, hasTrailingNewLine?: boolean): T;\n    function moveSyntheticComments<T extends Node>(node: T, original: Node): T;\n    /**\n     * Gets the constant value to emit for an expression.\n     */\n    function getConstantValue(node: PropertyAccessExpression | ElementAccessExpression): string | number | undefined;\n    /**\n     * Sets the constant value to emit for an expression.\n     */\n    function setConstantValue(node: PropertyAccessExpression | ElementAccessExpression, value: string | number): PropertyAccessExpression | ElementAccessExpression;\n    /**\n     * Adds an EmitHelper to a node.\n     */\n    function addEmitHelper<T extends Node>(node: T, helper: EmitHelper): T;\n    /**\n     * Add EmitHelpers to a node.\n     */\n    function addEmitHelpers<T extends Node>(node: T, helpers: EmitHelper[] | undefined): T;\n    /**\n     * Removes an EmitHelper from a node.\n     */\n    function removeEmitHelper(node: Node, helper: EmitHelper): boolean;\n    /**\n     * Gets the EmitHelpers of a node.\n     */\n    function getEmitHelpers(node: Node): EmitHelper[] | undefined;\n    /**\n     * Moves matching emit helpers from a source node to a target node.\n     */\n    function moveEmitHelpers(source: Node, target: Node, predicate: (helper: EmitHelper) => boolean): void;\n    function setOriginalNode<T extends Node>(node: T, original: Node | undefined): T;\n}\ndeclare namespace ts {\n    /**\n     * Visits a Node using the supplied visitor, possibly returning a new Node in its place.\n     *\n     * @param node The Node to visit.\n     * @param visitor The callback used to visit the Node.\n     * @param test A callback to execute to verify the Node is valid.\n     * @param lift An optional callback to execute to lift a NodeArray into a valid Node.\n     */\n    function visitNode<T extends Node>(node: T | undefined, visitor: Visitor | undefined, test?: (node: Node) => boolean, lift?: (node: NodeArray<Node>) => T): T;\n    /**\n     * Visits a Node using the supplied visitor, possibly returning a new Node in its place.\n     *\n     * @param node The Node to visit.\n     * @param visitor The callback used to visit the Node.\n     * @param test A callback to execute to verify the Node is valid.\n     * @param lift An optional callback to execute to lift a NodeArray into a valid Node.\n     */\n    function visitNode<T extends Node>(node: T | undefined, visitor: Visitor | undefined, test?: (node: Node) => boolean, lift?: (node: NodeArray<Node>) => T): T | undefined;\n    /**\n     * Visits a NodeArray using the supplied visitor, possibly returning a new NodeArray in its place.\n     *\n     * @param nodes The NodeArray to visit.\n     * @param visitor The callback used to visit a Node.\n     * @param test A node test to execute for each node.\n     * @param start An optional value indicating the starting offset at which to start visiting.\n     * @param count An optional value indicating the maximum number of nodes to visit.\n     */\n    function visitNodes<T extends Node>(nodes: NodeArray<T> | undefined, visitor: Visitor, test?: (node: Node) => boolean, start?: number, count?: number): NodeArray<T>;\n    /**\n     * Visits a NodeArray using the supplied visitor, possibly returning a new NodeArray in its place.\n     *\n     * @param nodes The NodeArray to visit.\n     * @param visitor The callback used to visit a Node.\n     * @param test A node test to execute for each node.\n     * @param start An optional value indicating the starting offset at which to start visiting.\n     * @param count An optional value indicating the maximum number of nodes to visit.\n     */\n    function visitNodes<T extends Node>(nodes: NodeArray<T> | undefined, visitor: Visitor, test?: (node: Node) => boolean, start?: number, count?: number): NodeArray<T> | undefined;\n    /**\n     * Starts a new lexical environment and visits a statement list, ending the lexical environment\n     * and merging hoisted declarations upon completion.\n     */\n    function visitLexicalEnvironment(statements: NodeArray<Statement>, visitor: Visitor, context: TransformationContext, start?: number, ensureUseStrict?: boolean): NodeArray<Statement>;\n    /**\n     * Starts a new lexical environment and visits a parameter list, suspending the lexical\n     * environment upon completion.\n     */\n    function visitParameterList(nodes: NodeArray<ParameterDeclaration>, visitor: Visitor, context: TransformationContext, nodesVisitor?: <T extends Node>(nodes: NodeArray<T>, visitor: Visitor, test?: (node: Node) => boolean, start?: number, count?: number) => NodeArray<T>): NodeArray<ParameterDeclaration>;\n    function visitParameterList(nodes: NodeArray<ParameterDeclaration> | undefined, visitor: Visitor, context: TransformationContext, nodesVisitor?: <T extends Node>(nodes: NodeArray<T> | undefined, visitor: Visitor, test?: (node: Node) => boolean, start?: number, count?: number) => NodeArray<T> | undefined): NodeArray<ParameterDeclaration> | undefined;\n    /**\n     * Resumes a suspended lexical environment and visits a function body, ending the lexical\n     * environment and merging hoisted declarations upon completion.\n     */\n    function visitFunctionBody(node: FunctionBody, visitor: Visitor, context: TransformationContext): FunctionBody;\n    /**\n     * Resumes a suspended lexical environment and visits a function body, ending the lexical\n     * environment and merging hoisted declarations upon completion.\n     */\n    function visitFunctionBody(node: FunctionBody | undefined, visitor: Visitor, context: TransformationContext): FunctionBody | undefined;\n    /**\n     * Resumes a suspended lexical environment and visits a concise body, ending the lexical\n     * environment and merging hoisted declarations upon completion.\n     */\n    function visitFunctionBody(node: ConciseBody, visitor: Visitor, context: TransformationContext): ConciseBody;\n    /**\n     * Visits each child of a Node using the supplied visitor, possibly returning a new Node of the same kind in its place.\n     *\n     * @param node The Node whose children will be visited.\n     * @param visitor The callback used to visit each child.\n     * @param context A lexical environment context for the visitor.\n     */\n    function visitEachChild<T extends Node>(node: T, visitor: Visitor, context: TransformationContext): T;\n    /**\n     * Visits each child of a Node using the supplied visitor, possibly returning a new Node of the same kind in its place.\n     *\n     * @param node The Node whose children will be visited.\n     * @param visitor The callback used to visit each child.\n     * @param context A lexical environment context for the visitor.\n     */\n    function visitEachChild<T extends Node>(node: T | undefined, visitor: Visitor, context: TransformationContext, nodesVisitor?: typeof visitNodes, tokenVisitor?: Visitor): T | undefined;\n}\ndeclare namespace ts {\n    function getTsBuildInfoEmitOutputFilePath(options: CompilerOptions): string | undefined;\n    function getOutputFileNames(commandLine: ParsedCommandLine, inputFileName: string, ignoreCase: boolean): readonly string[];\n    function createPrinter(printerOptions?: PrinterOptions, handlers?: PrintHandlers): Printer;\n}\ndeclare namespace ts {\n    export function findConfigFile(searchPath: string, fileExists: (fileName: string) => boolean, configName?: string): string | undefined;\n    export function resolveTripleslashReference(moduleName: string, containingFile: string): string;\n    export function createCompilerHost(options: CompilerOptions, setParentNodes?: boolean): CompilerHost;\n    export function getPreEmitDiagnostics(program: Program, sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly Diagnostic[];\n    export interface FormatDiagnosticsHost {\n        getCurrentDirectory(): string;\n        getCanonicalFileName(fileName: string): string;\n        getNewLine(): string;\n    }\n    export function formatDiagnostics(diagnostics: readonly Diagnostic[], host: FormatDiagnosticsHost): string;\n    export function formatDiagnostic(diagnostic: Diagnostic, host: FormatDiagnosticsHost): string;\n    export function formatDiagnosticsWithColorAndContext(diagnostics: readonly Diagnostic[], host: FormatDiagnosticsHost): string;\n    export function flattenDiagnosticMessageText(diag: string | DiagnosticMessageChain | undefined, newLine: string, indent?: number): string;\n    export function getConfigFileParsingDiagnostics(configFileParseResult: ParsedCommandLine): readonly Diagnostic[];\n    /**\n     * Create a new \'Program\' instance. A Program is an immutable collection of \'SourceFile\'s and a \'CompilerOptions\'\n     * that represent a compilation unit.\n     *\n     * Creating a program proceeds from a set of root files, expanding the set of inputs by following imports and\n     * triple-slash-reference-path directives transitively. \'@types\' and triple-slash-reference-types are also pulled in.\n     *\n     * @param createProgramOptions - The options for creating a program.\n     * @returns A \'Program\' object.\n     */\n    export function createProgram(createProgramOptions: CreateProgramOptions): Program;\n    /**\n     * Create a new \'Program\' instance. A Program is an immutable collection of \'SourceFile\'s and a \'CompilerOptions\'\n     * that represent a compilation unit.\n     *\n     * Creating a program proceeds from a set of root files, expanding the set of inputs by following imports and\n     * triple-slash-reference-path directives transitively. \'@types\' and triple-slash-reference-types are also pulled in.\n     *\n     * @param rootNames - A set of root files.\n     * @param options - The compiler options which should be used.\n     * @param host - The host interacts with the underlying file system.\n     * @param oldProgram - Reuses an old program structure.\n     * @param configFileParsingDiagnostics - error during config file parsing\n     * @returns A \'Program\' object.\n     */\n    export function createProgram(rootNames: readonly string[], options: CompilerOptions, host?: CompilerHost, oldProgram?: Program, configFileParsingDiagnostics?: readonly Diagnostic[]): Program;\n    /** @deprecated */ export interface ResolveProjectReferencePathHost {\n        fileExists(fileName: string): boolean;\n    }\n    /**\n     * Returns the target config filename of a project reference.\n     * Note: The file might not exist.\n     */\n    export function resolveProjectReferencePath(ref: ProjectReference): ResolvedConfigFileName;\n    /** @deprecated */ export function resolveProjectReferencePath(host: ResolveProjectReferencePathHost, ref: ProjectReference): ResolvedConfigFileName;\n    export {};\n}\ndeclare namespace ts {\n    interface EmitOutput {\n        outputFiles: OutputFile[];\n        emitSkipped: boolean;\n    }\n    interface OutputFile {\n        name: string;\n        writeByteOrderMark: boolean;\n        text: string;\n    }\n}\ndeclare namespace ts {\n    type AffectedFileResult<T> = {\n        result: T;\n        affected: SourceFile | Program;\n    } | undefined;\n    interface BuilderProgramHost {\n        /**\n         * return true if file names are treated with case sensitivity\n         */\n        useCaseSensitiveFileNames(): boolean;\n        /**\n         * If provided this would be used this hash instead of actual file shape text for detecting changes\n         */\n        createHash?: (data: string) => string;\n        /**\n         * When emit or emitNextAffectedFile are called without writeFile,\n         * this callback if present would be used to write files\n         */\n        writeFile?: WriteFileCallback;\n    }\n    /**\n     * Builder to manage the program state changes\n     */\n    interface BuilderProgram {\n        /**\n         * Returns current program\n         */\n        getProgram(): Program;\n        /**\n         * Get compiler options of the program\n         */\n        getCompilerOptions(): CompilerOptions;\n        /**\n         * Get the source file in the program with file name\n         */\n        getSourceFile(fileName: string): SourceFile | undefined;\n        /**\n         * Get a list of files in the program\n         */\n        getSourceFiles(): readonly SourceFile[];\n        /**\n         * Get the diagnostics for compiler options\n         */\n        getOptionsDiagnostics(cancellationToken?: CancellationToken): readonly Diagnostic[];\n        /**\n         * Get the diagnostics that dont belong to any file\n         */\n        getGlobalDiagnostics(cancellationToken?: CancellationToken): readonly Diagnostic[];\n        /**\n         * Get the diagnostics from config file parsing\n         */\n        getConfigFileParsingDiagnostics(): readonly Diagnostic[];\n        /**\n         * Get the syntax diagnostics, for all source files if source file is not supplied\n         */\n        getSyntacticDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly Diagnostic[];\n        /**\n         * Get the declaration diagnostics, for all source files if source file is not supplied\n         */\n        getDeclarationDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly DiagnosticWithLocation[];\n        /**\n         * Get all the dependencies of the file\n         */\n        getAllDependencies(sourceFile: SourceFile): readonly string[];\n        /**\n         * Gets the semantic diagnostics from the program corresponding to this state of file (if provided) or whole program\n         * The semantic diagnostics are cached and managed here\n         * Note that it is assumed that when asked about semantic diagnostics through this API,\n         * the file has been taken out of affected files so it is safe to use cache or get from program and cache the diagnostics\n         * In case of SemanticDiagnosticsBuilderProgram if the source file is not provided,\n         * it will iterate through all the affected files, to ensure that cache stays valid and yet provide a way to get all semantic diagnostics\n         */\n        getSemanticDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly Diagnostic[];\n        /**\n         * Emits the JavaScript and declaration files.\n         * When targetSource file is specified, emits the files corresponding to that source file,\n         * otherwise for the whole program.\n         * In case of EmitAndSemanticDiagnosticsBuilderProgram, when targetSourceFile is specified,\n         * it is assumed that that file is handled from affected file list. If targetSourceFile is not specified,\n         * it will only emit all the affected files instead of whole program\n         *\n         * The first of writeFile if provided, writeFile of BuilderProgramHost if provided, writeFile of compiler host\n         * in that order would be used to write the files\n         */\n        emit(targetSourceFile?: SourceFile, writeFile?: WriteFileCallback, cancellationToken?: CancellationToken, emitOnlyDtsFiles?: boolean, customTransformers?: CustomTransformers): EmitResult;\n        /**\n         * Get the current directory of the program\n         */\n        getCurrentDirectory(): string;\n    }\n    /**\n     * The builder that caches the semantic diagnostics for the program and handles the changed files and affected files\n     */\n    interface SemanticDiagnosticsBuilderProgram extends BuilderProgram {\n        /**\n         * Gets the semantic diagnostics from the program for the next affected file and caches it\n         * Returns undefined if the iteration is complete\n         */\n        getSemanticDiagnosticsOfNextAffectedFile(cancellationToken?: CancellationToken, ignoreSourceFile?: (sourceFile: SourceFile) => boolean): AffectedFileResult<readonly Diagnostic[]>;\n    }\n    /**\n     * The builder that can handle the changes in program and iterate through changed file to emit the files\n     * The semantic diagnostics are cached per file and managed by clearing for the changed/affected files\n     */\n    interface EmitAndSemanticDiagnosticsBuilderProgram extends SemanticDiagnosticsBuilderProgram {\n        /**\n         * Emits the next affected file\'s emit result (EmitResult and sourceFiles emitted) or returns undefined if iteration is complete\n         * The first of writeFile if provided, writeFile of BuilderProgramHost if provided, writeFile of compiler host\n         * in that order would be used to write the files\n         */\n        emitNextAffectedFile(writeFile?: WriteFileCallback, cancellationToken?: CancellationToken, emitOnlyDtsFiles?: boolean, customTransformers?: CustomTransformers): AffectedFileResult<EmitResult>;\n    }\n    /**\n     * Create the builder to manage semantic diagnostics and cache them\n     */\n    function createSemanticDiagnosticsBuilderProgram(newProgram: Program, host: BuilderProgramHost, oldProgram?: SemanticDiagnosticsBuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[]): SemanticDiagnosticsBuilderProgram;\n    function createSemanticDiagnosticsBuilderProgram(rootNames: readonly string[] | undefined, options: CompilerOptions | undefined, host?: CompilerHost, oldProgram?: SemanticDiagnosticsBuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[], projectReferences?: readonly ProjectReference[]): SemanticDiagnosticsBuilderProgram;\n    /**\n     * Create the builder that can handle the changes in program and iterate through changed files\n     * to emit the those files and manage semantic diagnostics cache as well\n     */\n    function createEmitAndSemanticDiagnosticsBuilderProgram(newProgram: Program, host: BuilderProgramHost, oldProgram?: EmitAndSemanticDiagnosticsBuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[]): EmitAndSemanticDiagnosticsBuilderProgram;\n    function createEmitAndSemanticDiagnosticsBuilderProgram(rootNames: readonly string[] | undefined, options: CompilerOptions | undefined, host?: CompilerHost, oldProgram?: EmitAndSemanticDiagnosticsBuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[], projectReferences?: readonly ProjectReference[]): EmitAndSemanticDiagnosticsBuilderProgram;\n    /**\n     * Creates a builder thats just abstraction over program and can be used with watch\n     */\n    function createAbstractBuilder(newProgram: Program, host: BuilderProgramHost, oldProgram?: BuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[]): BuilderProgram;\n    function createAbstractBuilder(rootNames: readonly string[] | undefined, options: CompilerOptions | undefined, host?: CompilerHost, oldProgram?: BuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[], projectReferences?: readonly ProjectReference[]): BuilderProgram;\n}\ndeclare namespace ts {\n    interface ReadBuildProgramHost {\n        useCaseSensitiveFileNames(): boolean;\n        getCurrentDirectory(): string;\n        readFile(fileName: string): string | undefined;\n    }\n    function readBuilderProgram(compilerOptions: CompilerOptions, host: ReadBuildProgramHost): EmitAndSemanticDiagnosticsBuilderProgram | undefined;\n    function createIncrementalCompilerHost(options: CompilerOptions, system?: System): CompilerHost;\n    interface IncrementalProgramOptions<T extends BuilderProgram> {\n        rootNames: readonly string[];\n        options: CompilerOptions;\n        configFileParsingDiagnostics?: readonly Diagnostic[];\n        projectReferences?: readonly ProjectReference[];\n        host?: CompilerHost;\n        createProgram?: CreateProgram<T>;\n    }\n    function createIncrementalProgram<T extends BuilderProgram = EmitAndSemanticDiagnosticsBuilderProgram>({ rootNames, options, configFileParsingDiagnostics, projectReferences, host, createProgram }: IncrementalProgramOptions<T>): T;\n    type WatchStatusReporter = (diagnostic: Diagnostic, newLine: string, options: CompilerOptions, errorCount?: number) => void;\n    /** Create the program with rootNames and options, if they are undefined, oldProgram and new configFile diagnostics create new program */\n    type CreateProgram<T extends BuilderProgram> = (rootNames: readonly string[] | undefined, options: CompilerOptions | undefined, host?: CompilerHost, oldProgram?: T, configFileParsingDiagnostics?: readonly Diagnostic[], projectReferences?: readonly ProjectReference[] | undefined) => T;\n    /** Host that has watch functionality used in --watch mode */\n    interface WatchHost {\n        /** If provided, called with Diagnostic message that informs about change in watch status */\n        onWatchStatusChange?(diagnostic: Diagnostic, newLine: string, options: CompilerOptions, errorCount?: number): void;\n        /** Used to watch changes in source files, missing files needed to update the program or config file */\n        watchFile(path: string, callback: FileWatcherCallback, pollingInterval?: number, options?: CompilerOptions): FileWatcher;\n        /** Used to watch resolved module\'s failed lookup locations, config file specs, type roots where auto type reference directives are added */\n        watchDirectory(path: string, callback: DirectoryWatcherCallback, recursive?: boolean, options?: CompilerOptions): FileWatcher;\n        /** If provided, will be used to set delayed compilation, so that multiple changes in short span are compiled together */\n        setTimeout?(callback: (...args: any[]) => void, ms: number, ...args: any[]): any;\n        /** If provided, will be used to reset existing delayed compilation */\n        clearTimeout?(timeoutId: any): void;\n    }\n    interface ProgramHost<T extends BuilderProgram> {\n        /**\n         * Used to create the program when need for program creation or recreation detected\n         */\n        createProgram: CreateProgram<T>;\n        useCaseSensitiveFileNames(): boolean;\n        getNewLine(): string;\n        getCurrentDirectory(): string;\n        getDefaultLibFileName(options: CompilerOptions): string;\n        getDefaultLibLocation?(): string;\n        createHash?(data: string): string;\n        /**\n         * Use to check file presence for source files and\n         * if resolveModuleNames is not provided (complier is in charge of module resolution) then module files as well\n         */\n        fileExists(path: string): boolean;\n        /**\n         * Use to read file text for source files and\n         * if resolveModuleNames is not provided (complier is in charge of module resolution) then module files as well\n         */\n        readFile(path: string, encoding?: string): string | undefined;\n        /** If provided, used for module resolution as well as to handle directory structure */\n        directoryExists?(path: string): boolean;\n        /** If provided, used in resolutions as well as handling directory structure */\n        getDirectories?(path: string): string[];\n        /** If provided, used to cache and handle directory structure modifications */\n        readDirectory?(path: string, extensions?: readonly string[], exclude?: readonly string[], include?: readonly string[], depth?: number): string[];\n        /** Symbol links resolution */\n        realpath?(path: string): string;\n        /** If provided would be used to write log about compilation */\n        trace?(s: string): void;\n        /** If provided is used to get the environment variable */\n        getEnvironmentVariable?(name: string): string | undefined;\n        /** If provided, used to resolve the module names, otherwise typescript\'s default module resolution */\n        resolveModuleNames?(moduleNames: string[], containingFile: string, reusedNames: string[] | undefined, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions): (ResolvedModule | undefined)[];\n        /** If provided, used to resolve type reference directives, otherwise typescript\'s default resolution */\n        resolveTypeReferenceDirectives?(typeReferenceDirectiveNames: string[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions): (ResolvedTypeReferenceDirective | undefined)[];\n    }\n    interface WatchCompilerHost<T extends BuilderProgram> extends ProgramHost<T>, WatchHost {\n        /** Instead of using output d.ts file from project reference, use its source file */\n        useSourceOfProjectReferenceRedirect?(): boolean;\n        /** If provided, callback to invoke after every new program creation */\n        afterProgramCreate?(program: T): void;\n    }\n    /**\n     * Host to create watch with root files and options\n     */\n    interface WatchCompilerHostOfFilesAndCompilerOptions<T extends BuilderProgram> extends WatchCompilerHost<T> {\n        /** root files to use to generate program */\n        rootFiles: string[];\n        /** Compiler options */\n        options: CompilerOptions;\n        watchOptions?: WatchOptions;\n        /** Project References */\n        projectReferences?: readonly ProjectReference[];\n    }\n    /**\n     * Host to create watch with config file\n     */\n    interface WatchCompilerHostOfConfigFile<T extends BuilderProgram> extends WatchCompilerHost<T>, ConfigFileDiagnosticsReporter {\n        /** Name of the config file to compile */\n        configFileName: string;\n        /** Options to extend */\n        optionsToExtend?: CompilerOptions;\n        watchOptionsToExtend?: WatchOptions;\n        extraFileExtensions?: readonly FileExtensionInfo[];\n        /**\n         * Used to generate source file names from the config file and its include, exclude, files rules\n         * and also to cache the directory stucture\n         */\n        readDirectory(path: string, extensions?: readonly string[], exclude?: readonly string[], include?: readonly string[], depth?: number): string[];\n    }\n    interface Watch<T> {\n        /** Synchronize with host and get updated program */\n        getProgram(): T;\n        /** Closes the watch */\n        close(): void;\n    }\n    /**\n     * Creates the watch what generates program using the config file\n     */\n    interface WatchOfConfigFile<T> extends Watch<T> {\n    }\n    /**\n     * Creates the watch that generates program using the root files and compiler options\n     */\n    interface WatchOfFilesAndCompilerOptions<T> extends Watch<T> {\n        /** Updates the root files in the program, only if this is not config file compilation */\n        updateRootFileNames(fileNames: string[]): void;\n    }\n    /**\n     * Create the watch compiler host for either configFile or fileNames and its options\n     */\n    function createWatchCompilerHost<T extends BuilderProgram>(configFileName: string, optionsToExtend: CompilerOptions | undefined, system: System, createProgram?: CreateProgram<T>, reportDiagnostic?: DiagnosticReporter, reportWatchStatus?: WatchStatusReporter, watchOptionsToExtend?: WatchOptions, extraFileExtensions?: readonly FileExtensionInfo[]): WatchCompilerHostOfConfigFile<T>;\n    function createWatchCompilerHost<T extends BuilderProgram>(rootFiles: string[], options: CompilerOptions, system: System, createProgram?: CreateProgram<T>, reportDiagnostic?: DiagnosticReporter, reportWatchStatus?: WatchStatusReporter, projectReferences?: readonly ProjectReference[], watchOptions?: WatchOptions): WatchCompilerHostOfFilesAndCompilerOptions<T>;\n    /**\n     * Creates the watch from the host for root files and compiler options\n     */\n    function createWatchProgram<T extends BuilderProgram>(host: WatchCompilerHostOfFilesAndCompilerOptions<T>): WatchOfFilesAndCompilerOptions<T>;\n    /**\n     * Creates the watch from the host for config file\n     */\n    function createWatchProgram<T extends BuilderProgram>(host: WatchCompilerHostOfConfigFile<T>): WatchOfConfigFile<T>;\n}\ndeclare namespace ts {\n    interface BuildOptions {\n        dry?: boolean;\n        force?: boolean;\n        verbose?: boolean;\n        incremental?: boolean;\n        assumeChangesOnlyAffectDirectDependencies?: boolean;\n        traceResolution?: boolean;\n        [option: string]: CompilerOptionsValue | undefined;\n    }\n    type ReportEmitErrorSummary = (errorCount: number) => void;\n    interface SolutionBuilderHostBase<T extends BuilderProgram> extends ProgramHost<T> {\n        createDirectory?(path: string): void;\n        /**\n         * Should provide create directory and writeFile if done of invalidatedProjects is not invoked with\n         * writeFileCallback\n         */\n        writeFile?(path: string, data: string, writeByteOrderMark?: boolean): void;\n        getModifiedTime(fileName: string): Date | undefined;\n        setModifiedTime(fileName: string, date: Date): void;\n        deleteFile(fileName: string): void;\n        getParsedCommandLine?(fileName: string): ParsedCommandLine | undefined;\n        reportDiagnostic: DiagnosticReporter;\n        reportSolutionBuilderStatus: DiagnosticReporter;\n        afterProgramEmitAndDiagnostics?(program: T): void;\n    }\n    interface SolutionBuilderHost<T extends BuilderProgram> extends SolutionBuilderHostBase<T> {\n        reportErrorSummary?: ReportEmitErrorSummary;\n    }\n    interface SolutionBuilderWithWatchHost<T extends BuilderProgram> extends SolutionBuilderHostBase<T>, WatchHost {\n    }\n    interface SolutionBuilder<T extends BuilderProgram> {\n        build(project?: string, cancellationToken?: CancellationToken): ExitStatus;\n        clean(project?: string): ExitStatus;\n        buildReferences(project: string, cancellationToken?: CancellationToken): ExitStatus;\n        cleanReferences(project?: string): ExitStatus;\n        getNextInvalidatedProject(cancellationToken?: CancellationToken): InvalidatedProject<T> | undefined;\n    }\n    /**\n     * Create a function that reports watch status by writing to the system and handles the formating of the diagnostic\n     */\n    function createBuilderStatusReporter(system: System, pretty?: boolean): DiagnosticReporter;\n    function createSolutionBuilderHost<T extends BuilderProgram = EmitAndSemanticDiagnosticsBuilderProgram>(system?: System, createProgram?: CreateProgram<T>, reportDiagnostic?: DiagnosticReporter, reportSolutionBuilderStatus?: DiagnosticReporter, reportErrorSummary?: ReportEmitErrorSummary): SolutionBuilderHost<T>;\n    function createSolutionBuilderWithWatchHost<T extends BuilderProgram = EmitAndSemanticDiagnosticsBuilderProgram>(system?: System, createProgram?: CreateProgram<T>, reportDiagnostic?: DiagnosticReporter, reportSolutionBuilderStatus?: DiagnosticReporter, reportWatchStatus?: WatchStatusReporter): SolutionBuilderWithWatchHost<T>;\n    function createSolutionBuilder<T extends BuilderProgram>(host: SolutionBuilderHost<T>, rootNames: readonly string[], defaultOptions: BuildOptions): SolutionBuilder<T>;\n    function createSolutionBuilderWithWatch<T extends BuilderProgram>(host: SolutionBuilderWithWatchHost<T>, rootNames: readonly string[], defaultOptions: BuildOptions, baseWatchOptions?: WatchOptions): SolutionBuilder<T>;\n    enum InvalidatedProjectKind {\n        Build = 0,\n        UpdateBundle = 1,\n        UpdateOutputFileStamps = 2\n    }\n    interface InvalidatedProjectBase {\n        readonly kind: InvalidatedProjectKind;\n        readonly project: ResolvedConfigFileName;\n        /**\n         *  To dispose this project and ensure that all the necessary actions are taken and state is updated accordingly\n         */\n        done(cancellationToken?: CancellationToken, writeFile?: WriteFileCallback, customTransformers?: CustomTransformers): ExitStatus;\n        getCompilerOptions(): CompilerOptions;\n        getCurrentDirectory(): string;\n    }\n    interface UpdateOutputFileStampsProject extends InvalidatedProjectBase {\n        readonly kind: InvalidatedProjectKind.UpdateOutputFileStamps;\n        updateOutputFileStatmps(): void;\n    }\n    interface BuildInvalidedProject<T extends BuilderProgram> extends InvalidatedProjectBase {\n        readonly kind: InvalidatedProjectKind.Build;\n        getBuilderProgram(): T | undefined;\n        getProgram(): Program | undefined;\n        getSourceFile(fileName: string): SourceFile | undefined;\n        getSourceFiles(): readonly SourceFile[];\n        getOptionsDiagnostics(cancellationToken?: CancellationToken): readonly Diagnostic[];\n        getGlobalDiagnostics(cancellationToken?: CancellationToken): readonly Diagnostic[];\n        getConfigFileParsingDiagnostics(): readonly Diagnostic[];\n        getSyntacticDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly Diagnostic[];\n        getAllDependencies(sourceFile: SourceFile): readonly string[];\n        getSemanticDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly Diagnostic[];\n        getSemanticDiagnosticsOfNextAffectedFile(cancellationToken?: CancellationToken, ignoreSourceFile?: (sourceFile: SourceFile) => boolean): AffectedFileResult<readonly Diagnostic[]>;\n        emit(targetSourceFile?: SourceFile, writeFile?: WriteFileCallback, cancellationToken?: CancellationToken, emitOnlyDtsFiles?: boolean, customTransformers?: CustomTransformers): EmitResult | undefined;\n    }\n    interface UpdateBundleProject<T extends BuilderProgram> extends InvalidatedProjectBase {\n        readonly kind: InvalidatedProjectKind.UpdateBundle;\n        emit(writeFile?: WriteFileCallback, customTransformers?: CustomTransformers): EmitResult | BuildInvalidedProject<T> | undefined;\n    }\n    type InvalidatedProject<T extends BuilderProgram> = UpdateOutputFileStampsProject | BuildInvalidedProject<T> | UpdateBundleProject<T>;\n}\ndeclare namespace ts.server {\n    type ActionSet = "action::set";\n    type ActionInvalidate = "action::invalidate";\n    type ActionPackageInstalled = "action::packageInstalled";\n    type EventTypesRegistry = "event::typesRegistry";\n    type EventBeginInstallTypes = "event::beginInstallTypes";\n    type EventEndInstallTypes = "event::endInstallTypes";\n    type EventInitializationFailed = "event::initializationFailed";\n}\ndeclare namespace ts.server {\n    interface TypingInstallerResponse {\n        readonly kind: ActionSet | ActionInvalidate | EventTypesRegistry | ActionPackageInstalled | EventBeginInstallTypes | EventEndInstallTypes | EventInitializationFailed;\n    }\n    interface TypingInstallerRequestWithProjectName {\n        readonly projectName: string;\n    }\n    interface DiscoverTypings extends TypingInstallerRequestWithProjectName {\n        readonly fileNames: string[];\n        readonly projectRootPath: Path;\n        readonly compilerOptions: CompilerOptions;\n        readonly watchOptions?: WatchOptions;\n        readonly typeAcquisition: TypeAcquisition;\n        readonly unresolvedImports: SortedReadonlyArray<string>;\n        readonly cachePath?: string;\n        readonly kind: "discover";\n    }\n    interface CloseProject extends TypingInstallerRequestWithProjectName {\n        readonly kind: "closeProject";\n    }\n    interface TypesRegistryRequest {\n        readonly kind: "typesRegistry";\n    }\n    interface InstallPackageRequest extends TypingInstallerRequestWithProjectName {\n        readonly kind: "installPackage";\n        readonly fileName: Path;\n        readonly packageName: string;\n        readonly projectRootPath: Path;\n    }\n    interface PackageInstalledResponse extends ProjectResponse {\n        readonly kind: ActionPackageInstalled;\n        readonly success: boolean;\n        readonly message: string;\n    }\n    interface InitializationFailedResponse extends TypingInstallerResponse {\n        readonly kind: EventInitializationFailed;\n        readonly message: string;\n    }\n    interface ProjectResponse extends TypingInstallerResponse {\n        readonly projectName: string;\n    }\n    interface InvalidateCachedTypings extends ProjectResponse {\n        readonly kind: ActionInvalidate;\n    }\n    interface InstallTypes extends ProjectResponse {\n        readonly kind: EventBeginInstallTypes | EventEndInstallTypes;\n        readonly eventId: number;\n        readonly typingsInstallerVersion: string;\n        readonly packagesToInstall: readonly string[];\n    }\n    interface BeginInstallTypes extends InstallTypes {\n        readonly kind: EventBeginInstallTypes;\n    }\n    interface EndInstallTypes extends InstallTypes {\n        readonly kind: EventEndInstallTypes;\n        readonly installSuccess: boolean;\n    }\n    interface SetTypings extends ProjectResponse {\n        readonly typeAcquisition: TypeAcquisition;\n        readonly compilerOptions: CompilerOptions;\n        readonly typings: string[];\n        readonly unresolvedImports: SortedReadonlyArray<string>;\n        readonly kind: ActionSet;\n    }\n}\ndeclare namespace ts {\n    interface Node {\n        getSourceFile(): SourceFile;\n        getChildCount(sourceFile?: SourceFile): number;\n        getChildAt(index: number, sourceFile?: SourceFile): Node;\n        getChildren(sourceFile?: SourceFile): Node[];\n        getStart(sourceFile?: SourceFile, includeJsDocComment?: boolean): number;\n        getFullStart(): number;\n        getEnd(): number;\n        getWidth(sourceFile?: SourceFileLike): number;\n        getFullWidth(): number;\n        getLeadingTriviaWidth(sourceFile?: SourceFile): number;\n        getFullText(sourceFile?: SourceFile): string;\n        getText(sourceFile?: SourceFile): string;\n        getFirstToken(sourceFile?: SourceFile): Node | undefined;\n        getLastToken(sourceFile?: SourceFile): Node | undefined;\n        forEachChild<T>(cbNode: (node: Node) => T | undefined, cbNodeArray?: (nodes: NodeArray<Node>) => T | undefined): T | undefined;\n    }\n    interface Identifier {\n        readonly text: string;\n    }\n    interface PrivateIdentifier {\n        readonly text: string;\n    }\n    interface Symbol {\n        readonly name: string;\n        getFlags(): SymbolFlags;\n        getEscapedName(): __String;\n        getName(): string;\n        getDeclarations(): Declaration[] | undefined;\n        getDocumentationComment(typeChecker: TypeChecker | undefined): SymbolDisplayPart[];\n        getJsDocTags(): JSDocTagInfo[];\n    }\n    interface Type {\n        getFlags(): TypeFlags;\n        getSymbol(): Symbol | undefined;\n        getProperties(): Symbol[];\n        getProperty(propertyName: string): Symbol | undefined;\n        getApparentProperties(): Symbol[];\n        getCallSignatures(): readonly Signature[];\n        getConstructSignatures(): readonly Signature[];\n        getStringIndexType(): Type | undefined;\n        getNumberIndexType(): Type | undefined;\n        getBaseTypes(): BaseType[] | undefined;\n        getNonNullableType(): Type;\n        getConstraint(): Type | undefined;\n        getDefault(): Type | undefined;\n        isUnion(): this is UnionType;\n        isIntersection(): this is IntersectionType;\n        isUnionOrIntersection(): this is UnionOrIntersectionType;\n        isLiteral(): this is LiteralType;\n        isStringLiteral(): this is StringLiteralType;\n        isNumberLiteral(): this is NumberLiteralType;\n        isTypeParameter(): this is TypeParameter;\n        isClassOrInterface(): this is InterfaceType;\n        isClass(): this is InterfaceType;\n    }\n    interface TypeReference {\n        typeArguments?: readonly Type[];\n    }\n    interface Signature {\n        getDeclaration(): SignatureDeclaration;\n        getTypeParameters(): TypeParameter[] | undefined;\n        getParameters(): Symbol[];\n        getReturnType(): Type;\n        getDocumentationComment(typeChecker: TypeChecker | undefined): SymbolDisplayPart[];\n        getJsDocTags(): JSDocTagInfo[];\n    }\n    interface SourceFile {\n        getLineAndCharacterOfPosition(pos: number): LineAndCharacter;\n        getLineEndOfPosition(pos: number): number;\n        getLineStarts(): readonly number[];\n        getPositionOfLineAndCharacter(line: number, character: number): number;\n        update(newText: string, textChangeRange: TextChangeRange): SourceFile;\n    }\n    interface SourceFileLike {\n        getLineAndCharacterOfPosition(pos: number): LineAndCharacter;\n    }\n    interface SourceMapSource {\n        getLineAndCharacterOfPosition(pos: number): LineAndCharacter;\n    }\n    /**\n     * Represents an immutable snapshot of a script at a specified time.Once acquired, the\n     * snapshot is observably immutable. i.e. the same calls with the same parameters will return\n     * the same values.\n     */\n    interface IScriptSnapshot {\n        /** Gets a portion of the script snapshot specified by [start, end). */\n        getText(start: number, end: number): string;\n        /** Gets the length of this script snapshot. */\n        getLength(): number;\n        /**\n         * Gets the TextChangeRange that describe how the text changed between this text and\n         * an older version.  This information is used by the incremental parser to determine\n         * what sections of the script need to be re-parsed.  \'undefined\' can be returned if the\n         * change range cannot be determined.  However, in that case, incremental parsing will\n         * not happen and the entire document will be re - parsed.\n         */\n        getChangeRange(oldSnapshot: IScriptSnapshot): TextChangeRange | undefined;\n        /** Releases all resources held by this script snapshot */\n        dispose?(): void;\n    }\n    namespace ScriptSnapshot {\n        function fromString(text: string): IScriptSnapshot;\n    }\n    interface PreProcessedFileInfo {\n        referencedFiles: FileReference[];\n        typeReferenceDirectives: FileReference[];\n        libReferenceDirectives: FileReference[];\n        importedFiles: FileReference[];\n        ambientExternalModules?: string[];\n        isLibFile: boolean;\n    }\n    interface HostCancellationToken {\n        isCancellationRequested(): boolean;\n    }\n    interface InstallPackageOptions {\n        fileName: Path;\n        packageName: string;\n    }\n    interface LanguageServiceHost extends GetEffectiveTypeRootsHost {\n        getCompilationSettings(): CompilerOptions;\n        getNewLine?(): string;\n        getProjectVersion?(): string;\n        getScriptFileNames(): string[];\n        getScriptKind?(fileName: string): ScriptKind;\n        getScriptVersion(fileName: string): string;\n        getScriptSnapshot(fileName: string): IScriptSnapshot | undefined;\n        getProjectReferences?(): readonly ProjectReference[] | undefined;\n        getLocalizedDiagnosticMessages?(): any;\n        getCancellationToken?(): HostCancellationToken;\n        getCurrentDirectory(): string;\n        getDefaultLibFileName(options: CompilerOptions): string;\n        log?(s: string): void;\n        trace?(s: string): void;\n        error?(s: string): void;\n        useCaseSensitiveFileNames?(): boolean;\n        readDirectory?(path: string, extensions?: readonly string[], exclude?: readonly string[], include?: readonly string[], depth?: number): string[];\n        readFile?(path: string, encoding?: string): string | undefined;\n        realpath?(path: string): string;\n        fileExists?(path: string): boolean;\n        getTypeRootsVersion?(): number;\n        resolveModuleNames?(moduleNames: string[], containingFile: string, reusedNames: string[] | undefined, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions): (ResolvedModule | undefined)[];\n        getResolvedModuleWithFailedLookupLocationsFromCache?(modulename: string, containingFile: string): ResolvedModuleWithFailedLookupLocations | undefined;\n        resolveTypeReferenceDirectives?(typeDirectiveNames: string[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions): (ResolvedTypeReferenceDirective | undefined)[];\n        getDirectories?(directoryName: string): string[];\n        /**\n         * Gets a set of custom transformers to use during emit.\n         */\n        getCustomTransformers?(): CustomTransformers | undefined;\n        isKnownTypesPackageName?(name: string): boolean;\n        installPackage?(options: InstallPackageOptions): Promise<ApplyCodeActionCommandResult>;\n        writeFile?(fileName: string, content: string): void;\n    }\n    type WithMetadata<T> = T & {\n        metadata?: unknown;\n    };\n    interface LanguageService {\n        /** This is used as a part of restarting the language service. */\n        cleanupSemanticCache(): void;\n        /**\n         * Gets errors indicating invalid syntax in a file.\n         *\n         * In English, "this cdeo have, erorrs" is syntactically invalid because it has typos,\n         * grammatical errors, and misplaced punctuation. Likewise, examples of syntax\n         * errors in TypeScript are missing parentheses in an `if` statement, mismatched\n         * curly braces, and using a reserved keyword as a variable name.\n         *\n         * These diagnostics are inexpensive to compute and don\'t require knowledge of\n         * other files. Note that a non-empty result increases the likelihood of false positives\n         * from `getSemanticDiagnostics`.\n         *\n         * While these represent the majority of syntax-related diagnostics, there are some\n         * that require the type system, which will be present in `getSemanticDiagnostics`.\n         *\n         * @param fileName A path to the file you want syntactic diagnostics for\n         */\n        getSyntacticDiagnostics(fileName: string): DiagnosticWithLocation[];\n        /**\n         * Gets warnings or errors indicating type system issues in a given file.\n         * Requesting semantic diagnostics may start up the type system and\n         * run deferred work, so the first call may take longer than subsequent calls.\n         *\n         * Unlike the other get*Diagnostics functions, these diagnostics can potentially not\n         * include a reference to a source file. Specifically, the first time this is called,\n         * it will return global diagnostics with no associated location.\n         *\n         * To contrast the differences between semantic and syntactic diagnostics, consider the\n         * sentence: "The sun is green." is syntactically correct; those are real English words with\n         * correct sentence structure. However, it is semantically invalid, because it is not true.\n         *\n         * @param fileName A path to the file you want semantic diagnostics for\n         */\n        getSemanticDiagnostics(fileName: string): Diagnostic[];\n        /**\n         * Gets suggestion diagnostics for a specific file. These diagnostics tend to\n         * proactively suggest refactors, as opposed to diagnostics that indicate\n         * potentially incorrect runtime behavior.\n         *\n         * @param fileName A path to the file you want semantic diagnostics for\n         */\n        getSuggestionDiagnostics(fileName: string): DiagnosticWithLocation[];\n        /**\n         * Gets global diagnostics related to the program configuration and compiler options.\n         */\n        getCompilerOptionsDiagnostics(): Diagnostic[];\n        /** @deprecated Use getEncodedSyntacticClassifications instead. */\n        getSyntacticClassifications(fileName: string, span: TextSpan): ClassifiedSpan[];\n        /** @deprecated Use getEncodedSemanticClassifications instead. */\n        getSemanticClassifications(fileName: string, span: TextSpan): ClassifiedSpan[];\n        getEncodedSyntacticClassifications(fileName: string, span: TextSpan): Classifications;\n        getEncodedSemanticClassifications(fileName: string, span: TextSpan): Classifications;\n        /**\n         * Gets completion entries at a particular position in a file.\n         *\n         * @param fileName The path to the file\n         * @param position A zero-based index of the character where you want the entries\n         * @param options An object describing how the request was triggered and what kinds\n         * of code actions can be returned with the completions.\n         */\n        getCompletionsAtPosition(fileName: string, position: number, options: GetCompletionsAtPositionOptions | undefined): WithMetadata<CompletionInfo> | undefined;\n        /**\n         * Gets the extended details for a completion entry retrieved from `getCompletionsAtPosition`.\n         *\n         * @param fileName The path to the file\n         * @param position A zero based index of the character where you want the entries\n         * @param entryName The name from an existing completion which came from `getCompletionsAtPosition`\n         * @param formatOptions How should code samples in the completions be formatted, can be undefined for backwards compatibility\n         * @param source Source code for the current file, can be undefined for backwards compatibility\n         * @param preferences User settings, can be undefined for backwards compatibility\n         */\n        getCompletionEntryDetails(fileName: string, position: number, entryName: string, formatOptions: FormatCodeOptions | FormatCodeSettings | undefined, source: string | undefined, preferences: UserPreferences | undefined): CompletionEntryDetails | undefined;\n        getCompletionEntrySymbol(fileName: string, position: number, name: string, source: string | undefined): Symbol | undefined;\n        /**\n         * Gets semantic information about the identifier at a particular position in a\n         * file. Quick info is what you typically see when you hover in an editor.\n         *\n         * @param fileName The path to the file\n         * @param position A zero-based index of the character where you want the quick info\n         */\n        getQuickInfoAtPosition(fileName: string, position: number): QuickInfo | undefined;\n        getNameOrDottedNameSpan(fileName: string, startPos: number, endPos: number): TextSpan | undefined;\n        getBreakpointStatementAtPosition(fileName: string, position: number): TextSpan | undefined;\n        getSignatureHelpItems(fileName: string, position: number, options: SignatureHelpItemsOptions | undefined): SignatureHelpItems | undefined;\n        getRenameInfo(fileName: string, position: number, options?: RenameInfoOptions): RenameInfo;\n        findRenameLocations(fileName: string, position: number, findInStrings: boolean, findInComments: boolean, providePrefixAndSuffixTextForRename?: boolean): readonly RenameLocation[] | undefined;\n        getSmartSelectionRange(fileName: string, position: number): SelectionRange;\n        getDefinitionAtPosition(fileName: string, position: number): readonly DefinitionInfo[] | undefined;\n        getDefinitionAndBoundSpan(fileName: string, position: number): DefinitionInfoAndBoundSpan | undefined;\n        getTypeDefinitionAtPosition(fileName: string, position: number): readonly DefinitionInfo[] | undefined;\n        getImplementationAtPosition(fileName: string, position: number): readonly ImplementationLocation[] | undefined;\n        getReferencesAtPosition(fileName: string, position: number): ReferenceEntry[] | undefined;\n        findReferences(fileName: string, position: number): ReferencedSymbol[] | undefined;\n        getDocumentHighlights(fileName: string, position: number, filesToSearch: string[]): DocumentHighlights[] | undefined;\n        /** @deprecated */\n        getOccurrencesAtPosition(fileName: string, position: number): readonly ReferenceEntry[] | undefined;\n        getNavigateToItems(searchValue: string, maxResultCount?: number, fileName?: string, excludeDtsFiles?: boolean): NavigateToItem[];\n        getNavigationBarItems(fileName: string): NavigationBarItem[];\n        getNavigationTree(fileName: string): NavigationTree;\n        prepareCallHierarchy(fileName: string, position: number): CallHierarchyItem | CallHierarchyItem[] | undefined;\n        provideCallHierarchyIncomingCalls(fileName: string, position: number): CallHierarchyIncomingCall[];\n        provideCallHierarchyOutgoingCalls(fileName: string, position: number): CallHierarchyOutgoingCall[];\n        getOutliningSpans(fileName: string): OutliningSpan[];\n        getTodoComments(fileName: string, descriptors: TodoCommentDescriptor[]): TodoComment[];\n        getBraceMatchingAtPosition(fileName: string, position: number): TextSpan[];\n        getIndentationAtPosition(fileName: string, position: number, options: EditorOptions | EditorSettings): number;\n        getFormattingEditsForRange(fileName: string, start: number, end: number, options: FormatCodeOptions | FormatCodeSettings): TextChange[];\n        getFormattingEditsForDocument(fileName: string, options: FormatCodeOptions | FormatCodeSettings): TextChange[];\n        getFormattingEditsAfterKeystroke(fileName: string, position: number, key: string, options: FormatCodeOptions | FormatCodeSettings): TextChange[];\n        getDocCommentTemplateAtPosition(fileName: string, position: number): TextInsertion | undefined;\n        isValidBraceCompletionAtPosition(fileName: string, position: number, openingBrace: number): boolean;\n        /**\n         * This will return a defined result if the position is after the `>` of the opening tag, or somewhere in the text, of a JSXElement with no closing tag.\n         * Editors should call this after `>` is typed.\n         */\n        getJsxClosingTagAtPosition(fileName: string, position: number): JsxClosingTagInfo | undefined;\n        getSpanOfEnclosingComment(fileName: string, position: number, onlyMultiLine: boolean): TextSpan | undefined;\n        toLineColumnOffset?(fileName: string, position: number): LineAndCharacter;\n        getCodeFixesAtPosition(fileName: string, start: number, end: number, errorCodes: readonly number[], formatOptions: FormatCodeSettings, preferences: UserPreferences): readonly CodeFixAction[];\n        getCombinedCodeFix(scope: CombinedCodeFixScope, fixId: {}, formatOptions: FormatCodeSettings, preferences: UserPreferences): CombinedCodeActions;\n        applyCodeActionCommand(action: CodeActionCommand, formatSettings?: FormatCodeSettings): Promise<ApplyCodeActionCommandResult>;\n        applyCodeActionCommand(action: CodeActionCommand[], formatSettings?: FormatCodeSettings): Promise<ApplyCodeActionCommandResult[]>;\n        applyCodeActionCommand(action: CodeActionCommand | CodeActionCommand[], formatSettings?: FormatCodeSettings): Promise<ApplyCodeActionCommandResult | ApplyCodeActionCommandResult[]>;\n        /** @deprecated `fileName` will be ignored */\n        applyCodeActionCommand(fileName: string, action: CodeActionCommand): Promise<ApplyCodeActionCommandResult>;\n        /** @deprecated `fileName` will be ignored */\n        applyCodeActionCommand(fileName: string, action: CodeActionCommand[]): Promise<ApplyCodeActionCommandResult[]>;\n        /** @deprecated `fileName` will be ignored */\n        applyCodeActionCommand(fileName: string, action: CodeActionCommand | CodeActionCommand[]): Promise<ApplyCodeActionCommandResult | ApplyCodeActionCommandResult[]>;\n        getApplicableRefactors(fileName: string, positionOrRange: number | TextRange, preferences: UserPreferences | undefined): ApplicableRefactorInfo[];\n        getEditsForRefactor(fileName: string, formatOptions: FormatCodeSettings, positionOrRange: number | TextRange, refactorName: string, actionName: string, preferences: UserPreferences | undefined): RefactorEditInfo | undefined;\n        organizeImports(scope: OrganizeImportsScope, formatOptions: FormatCodeSettings, preferences: UserPreferences | undefined): readonly FileTextChanges[];\n        getEditsForFileRename(oldFilePath: string, newFilePath: string, formatOptions: FormatCodeSettings, preferences: UserPreferences | undefined): readonly FileTextChanges[];\n        getEmitOutput(fileName: string, emitOnlyDtsFiles?: boolean, forceDtsEmit?: boolean): EmitOutput;\n        getProgram(): Program | undefined;\n        dispose(): void;\n    }\n    interface JsxClosingTagInfo {\n        readonly newText: string;\n    }\n    interface CombinedCodeFixScope {\n        type: "file";\n        fileName: string;\n    }\n    type OrganizeImportsScope = CombinedCodeFixScope;\n    type CompletionsTriggerCharacter = "." | \'"\' | "\'" | "`" | "/" | "@" | "<" | "#";\n    interface GetCompletionsAtPositionOptions extends UserPreferences {\n        /**\n         * If the editor is asking for completions because a certain character was typed\n         * (as opposed to when the user explicitly requested them) this should be set.\n         */\n        triggerCharacter?: CompletionsTriggerCharacter;\n        /** @deprecated Use includeCompletionsForModuleExports */\n        includeExternalModuleExports?: boolean;\n        /** @deprecated Use includeCompletionsWithInsertText */\n        includeInsertTextCompletions?: boolean;\n    }\n    type SignatureHelpTriggerCharacter = "," | "(" | "<";\n    type SignatureHelpRetriggerCharacter = SignatureHelpTriggerCharacter | ")";\n    interface SignatureHelpItemsOptions {\n        triggerReason?: SignatureHelpTriggerReason;\n    }\n    type SignatureHelpTriggerReason = SignatureHelpInvokedReason | SignatureHelpCharacterTypedReason | SignatureHelpRetriggeredReason;\n    /**\n     * Signals that the user manually requested signature help.\n     * The language service will unconditionally attempt to provide a result.\n     */\n    interface SignatureHelpInvokedReason {\n        kind: "invoked";\n        triggerCharacter?: undefined;\n    }\n    /**\n     * Signals that the signature help request came from a user typing a character.\n     * Depending on the character and the syntactic context, the request may or may not be served a result.\n     */\n    interface SignatureHelpCharacterTypedReason {\n        kind: "characterTyped";\n        /**\n         * Character that was responsible for triggering signature help.\n         */\n        triggerCharacter: SignatureHelpTriggerCharacter;\n    }\n    /**\n     * Signals that this signature help request came from typing a character or moving the cursor.\n     * This should only occur if a signature help session was already active and the editor needs to see if it should adjust.\n     * The language service will unconditionally attempt to provide a result.\n     * `triggerCharacter` can be `undefined` for a retrigger caused by a cursor move.\n     */\n    interface SignatureHelpRetriggeredReason {\n        kind: "retrigger";\n        /**\n         * Character that was responsible for triggering signature help.\n         */\n        triggerCharacter?: SignatureHelpRetriggerCharacter;\n    }\n    interface ApplyCodeActionCommandResult {\n        successMessage: string;\n    }\n    interface Classifications {\n        spans: number[];\n        endOfLineState: EndOfLineState;\n    }\n    interface ClassifiedSpan {\n        textSpan: TextSpan;\n        classificationType: ClassificationTypeNames;\n    }\n    /**\n     * Navigation bar interface designed for visual studio\'s dual-column layout.\n     * This does not form a proper tree.\n     * The navbar is returned as a list of top-level items, each of which has a list of child items.\n     * Child items always have an empty array for their `childItems`.\n     */\n    interface NavigationBarItem {\n        text: string;\n        kind: ScriptElementKind;\n        kindModifiers: string;\n        spans: TextSpan[];\n        childItems: NavigationBarItem[];\n        indent: number;\n        bolded: boolean;\n        grayed: boolean;\n    }\n    /**\n     * Node in a tree of nested declarations in a file.\n     * The top node is always a script or module node.\n     */\n    interface NavigationTree {\n        /** Name of the declaration, or a short description, e.g. "<class>". */\n        text: string;\n        kind: ScriptElementKind;\n        /** ScriptElementKindModifier separated by commas, e.g. "public,abstract" */\n        kindModifiers: string;\n        /**\n         * Spans of the nodes that generated this declaration.\n         * There will be more than one if this is the result of merging.\n         */\n        spans: TextSpan[];\n        nameSpan: TextSpan | undefined;\n        /** Present if non-empty */\n        childItems?: NavigationTree[];\n    }\n    interface CallHierarchyItem {\n        name: string;\n        kind: ScriptElementKind;\n        file: string;\n        span: TextSpan;\n        selectionSpan: TextSpan;\n    }\n    interface CallHierarchyIncomingCall {\n        from: CallHierarchyItem;\n        fromSpans: TextSpan[];\n    }\n    interface CallHierarchyOutgoingCall {\n        to: CallHierarchyItem;\n        fromSpans: TextSpan[];\n    }\n    interface TodoCommentDescriptor {\n        text: string;\n        priority: number;\n    }\n    interface TodoComment {\n        descriptor: TodoCommentDescriptor;\n        message: string;\n        position: number;\n    }\n    interface TextChange {\n        span: TextSpan;\n        newText: string;\n    }\n    interface FileTextChanges {\n        fileName: string;\n        textChanges: readonly TextChange[];\n        isNewFile?: boolean;\n    }\n    interface CodeAction {\n        /** Description of the code action to display in the UI of the editor */\n        description: string;\n        /** Text changes to apply to each file as part of the code action */\n        changes: FileTextChanges[];\n        /**\n         * If the user accepts the code fix, the editor should send the action back in a `applyAction` request.\n         * This allows the language service to have side effects (e.g. installing dependencies) upon a code fix.\n         */\n        commands?: CodeActionCommand[];\n    }\n    interface CodeFixAction extends CodeAction {\n        /** Short name to identify the fix, for use by telemetry. */\n        fixName: string;\n        /**\n         * If present, one may call \'getCombinedCodeFix\' with this fixId.\n         * This may be omitted to indicate that the code fix can\'t be applied in a group.\n         */\n        fixId?: {};\n        fixAllDescription?: string;\n    }\n    interface CombinedCodeActions {\n        changes: readonly FileTextChanges[];\n        commands?: readonly CodeActionCommand[];\n    }\n    type CodeActionCommand = InstallPackageAction;\n    interface InstallPackageAction {\n    }\n    /**\n     * A set of one or more available refactoring actions, grouped under a parent refactoring.\n     */\n    interface ApplicableRefactorInfo {\n        /**\n         * The programmatic name of the refactoring\n         */\n        name: string;\n        /**\n         * A description of this refactoring category to show to the user.\n         * If the refactoring gets inlined (see below), this text will not be visible.\n         */\n        description: string;\n        /**\n         * Inlineable refactorings can have their actions hoisted out to the top level\n         * of a context menu. Non-inlineanable refactorings should always be shown inside\n         * their parent grouping.\n         *\n         * If not specified, this value is assumed to be \'true\'\n         */\n        inlineable?: boolean;\n        actions: RefactorActionInfo[];\n    }\n    /**\n     * Represents a single refactoring action - for example, the "Extract Method..." refactor might\n     * offer several actions, each corresponding to a surround class or closure to extract into.\n     */\n    interface RefactorActionInfo {\n        /**\n         * The programmatic name of the refactoring action\n         */\n        name: string;\n        /**\n         * A description of this refactoring action to show to the user.\n         * If the parent refactoring is inlined away, this will be the only text shown,\n         * so this description should make sense by itself if the parent is inlineable=true\n         */\n        description: string;\n    }\n    /**\n     * A set of edits to make in response to a refactor action, plus an optional\n     * location where renaming should be invoked from\n     */\n    interface RefactorEditInfo {\n        edits: FileTextChanges[];\n        renameFilename?: string;\n        renameLocation?: number;\n        commands?: CodeActionCommand[];\n    }\n    interface TextInsertion {\n        newText: string;\n        /** The position in newText the caret should point to after the insertion. */\n        caretOffset: number;\n    }\n    interface DocumentSpan {\n        textSpan: TextSpan;\n        fileName: string;\n        /**\n         * If the span represents a location that was remapped (e.g. via a .d.ts.map file),\n         * then the original filename and span will be specified here\n         */\n        originalTextSpan?: TextSpan;\n        originalFileName?: string;\n        /**\n         * If DocumentSpan.textSpan is the span for name of the declaration,\n         * then this is the span for relevant declaration\n         */\n        contextSpan?: TextSpan;\n        originalContextSpan?: TextSpan;\n    }\n    interface RenameLocation extends DocumentSpan {\n        readonly prefixText?: string;\n        readonly suffixText?: string;\n    }\n    interface ReferenceEntry extends DocumentSpan {\n        isWriteAccess: boolean;\n        isDefinition: boolean;\n        isInString?: true;\n    }\n    interface ImplementationLocation extends DocumentSpan {\n        kind: ScriptElementKind;\n        displayParts: SymbolDisplayPart[];\n    }\n    enum HighlightSpanKind {\n        none = "none",\n        definition = "definition",\n        reference = "reference",\n        writtenReference = "writtenReference"\n    }\n    interface HighlightSpan {\n        fileName?: string;\n        isInString?: true;\n        textSpan: TextSpan;\n        contextSpan?: TextSpan;\n        kind: HighlightSpanKind;\n    }\n    interface NavigateToItem {\n        name: string;\n        kind: ScriptElementKind;\n        kindModifiers: string;\n        matchKind: "exact" | "prefix" | "substring" | "camelCase";\n        isCaseSensitive: boolean;\n        fileName: string;\n        textSpan: TextSpan;\n        containerName: string;\n        containerKind: ScriptElementKind;\n    }\n    enum IndentStyle {\n        None = 0,\n        Block = 1,\n        Smart = 2\n    }\n    enum SemicolonPreference {\n        Ignore = "ignore",\n        Insert = "insert",\n        Remove = "remove"\n    }\n    interface EditorOptions {\n        BaseIndentSize?: number;\n        IndentSize: number;\n        TabSize: number;\n        NewLineCharacter: string;\n        ConvertTabsToSpaces: boolean;\n        IndentStyle: IndentStyle;\n    }\n    interface EditorSettings {\n        baseIndentSize?: number;\n        indentSize?: number;\n        tabSize?: number;\n        newLineCharacter?: string;\n        convertTabsToSpaces?: boolean;\n        indentStyle?: IndentStyle;\n        trimTrailingWhitespace?: boolean;\n    }\n    interface FormatCodeOptions extends EditorOptions {\n        InsertSpaceAfterCommaDelimiter: boolean;\n        InsertSpaceAfterSemicolonInForStatements: boolean;\n        InsertSpaceBeforeAndAfterBinaryOperators: boolean;\n        InsertSpaceAfterConstructor?: boolean;\n        InsertSpaceAfterKeywordsInControlFlowStatements: boolean;\n        InsertSpaceAfterFunctionKeywordForAnonymousFunctions: boolean;\n        InsertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis: boolean;\n        InsertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets: boolean;\n        InsertSpaceAfterOpeningAndBeforeClosingNonemptyBraces?: boolean;\n        InsertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces: boolean;\n        InsertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces?: boolean;\n        InsertSpaceAfterTypeAssertion?: boolean;\n        InsertSpaceBeforeFunctionParenthesis?: boolean;\n        PlaceOpenBraceOnNewLineForFunctions: boolean;\n        PlaceOpenBraceOnNewLineForControlBlocks: boolean;\n        insertSpaceBeforeTypeAnnotation?: boolean;\n    }\n    interface FormatCodeSettings extends EditorSettings {\n        readonly insertSpaceAfterCommaDelimiter?: boolean;\n        readonly insertSpaceAfterSemicolonInForStatements?: boolean;\n        readonly insertSpaceBeforeAndAfterBinaryOperators?: boolean;\n        readonly insertSpaceAfterConstructor?: boolean;\n        readonly insertSpaceAfterKeywordsInControlFlowStatements?: boolean;\n        readonly insertSpaceAfterFunctionKeywordForAnonymousFunctions?: boolean;\n        readonly insertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis?: boolean;\n        readonly insertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets?: boolean;\n        readonly insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces?: boolean;\n        readonly insertSpaceAfterOpeningAndBeforeClosingEmptyBraces?: boolean;\n        readonly insertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces?: boolean;\n        readonly insertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces?: boolean;\n        readonly insertSpaceAfterTypeAssertion?: boolean;\n        readonly insertSpaceBeforeFunctionParenthesis?: boolean;\n        readonly placeOpenBraceOnNewLineForFunctions?: boolean;\n        readonly placeOpenBraceOnNewLineForControlBlocks?: boolean;\n        readonly insertSpaceBeforeTypeAnnotation?: boolean;\n        readonly indentMultiLineObjectLiteralBeginningOnBlankLine?: boolean;\n        readonly semicolons?: SemicolonPreference;\n    }\n    function getDefaultFormatCodeSettings(newLineCharacter?: string): FormatCodeSettings;\n    interface DefinitionInfo extends DocumentSpan {\n        kind: ScriptElementKind;\n        name: string;\n        containerKind: ScriptElementKind;\n        containerName: string;\n    }\n    interface DefinitionInfoAndBoundSpan {\n        definitions?: readonly DefinitionInfo[];\n        textSpan: TextSpan;\n    }\n    interface ReferencedSymbolDefinitionInfo extends DefinitionInfo {\n        displayParts: SymbolDisplayPart[];\n    }\n    interface ReferencedSymbol {\n        definition: ReferencedSymbolDefinitionInfo;\n        references: ReferenceEntry[];\n    }\n    enum SymbolDisplayPartKind {\n        aliasName = 0,\n        className = 1,\n        enumName = 2,\n        fieldName = 3,\n        interfaceName = 4,\n        keyword = 5,\n        lineBreak = 6,\n        numericLiteral = 7,\n        stringLiteral = 8,\n        localName = 9,\n        methodName = 10,\n        moduleName = 11,\n        operator = 12,\n        parameterName = 13,\n        propertyName = 14,\n        punctuation = 15,\n        space = 16,\n        text = 17,\n        typeParameterName = 18,\n        enumMemberName = 19,\n        functionName = 20,\n        regularExpressionLiteral = 21\n    }\n    interface SymbolDisplayPart {\n        text: string;\n        kind: string;\n    }\n    interface JSDocTagInfo {\n        name: string;\n        text?: string;\n    }\n    interface QuickInfo {\n        kind: ScriptElementKind;\n        kindModifiers: string;\n        textSpan: TextSpan;\n        displayParts?: SymbolDisplayPart[];\n        documentation?: SymbolDisplayPart[];\n        tags?: JSDocTagInfo[];\n    }\n    type RenameInfo = RenameInfoSuccess | RenameInfoFailure;\n    interface RenameInfoSuccess {\n        canRename: true;\n        /**\n         * File or directory to rename.\n         * If set, `getEditsForFileRename` should be called instead of `findRenameLocations`.\n         */\n        fileToRename?: string;\n        displayName: string;\n        fullDisplayName: string;\n        kind: ScriptElementKind;\n        kindModifiers: string;\n        triggerSpan: TextSpan;\n    }\n    interface RenameInfoFailure {\n        canRename: false;\n        localizedErrorMessage: string;\n    }\n    interface RenameInfoOptions {\n        readonly allowRenameOfImportPath?: boolean;\n    }\n    interface SignatureHelpParameter {\n        name: string;\n        documentation: SymbolDisplayPart[];\n        displayParts: SymbolDisplayPart[];\n        isOptional: boolean;\n    }\n    interface SelectionRange {\n        textSpan: TextSpan;\n        parent?: SelectionRange;\n    }\n    /**\n     * Represents a single signature to show in signature help.\n     * The id is used for subsequent calls into the language service to ask questions about the\n     * signature help item in the context of any documents that have been updated.  i.e. after\n     * an edit has happened, while signature help is still active, the host can ask important\n     * questions like \'what parameter is the user currently contained within?\'.\n     */\n    interface SignatureHelpItem {\n        isVariadic: boolean;\n        prefixDisplayParts: SymbolDisplayPart[];\n        suffixDisplayParts: SymbolDisplayPart[];\n        separatorDisplayParts: SymbolDisplayPart[];\n        parameters: SignatureHelpParameter[];\n        documentation: SymbolDisplayPart[];\n        tags: JSDocTagInfo[];\n    }\n    /**\n     * Represents a set of signature help items, and the preferred item that should be selected.\n     */\n    interface SignatureHelpItems {\n        items: SignatureHelpItem[];\n        applicableSpan: TextSpan;\n        selectedItemIndex: number;\n        argumentIndex: number;\n        argumentCount: number;\n    }\n    interface CompletionInfo {\n        /** Not true for all global completions. This will be true if the enclosing scope matches a few syntax kinds. See `isSnippetScope`. */\n        isGlobalCompletion: boolean;\n        isMemberCompletion: boolean;\n        /**\n         * true when the current location also allows for a new identifier\n         */\n        isNewIdentifierLocation: boolean;\n        entries: CompletionEntry[];\n    }\n    interface CompletionEntry {\n        name: string;\n        kind: ScriptElementKind;\n        kindModifiers?: string;\n        sortText: string;\n        insertText?: string;\n        /**\n         * An optional span that indicates the text to be replaced by this completion item.\n         * If present, this span should be used instead of the default one.\n         * It will be set if the required span differs from the one generated by the default replacement behavior.\n         */\n        replacementSpan?: TextSpan;\n        hasAction?: true;\n        source?: string;\n        isRecommended?: true;\n        isFromUncheckedFile?: true;\n    }\n    interface CompletionEntryDetails {\n        name: string;\n        kind: ScriptElementKind;\n        kindModifiers: string;\n        displayParts: SymbolDisplayPart[];\n        documentation?: SymbolDisplayPart[];\n        tags?: JSDocTagInfo[];\n        codeActions?: CodeAction[];\n        source?: SymbolDisplayPart[];\n    }\n    interface OutliningSpan {\n        /** The span of the document to actually collapse. */\n        textSpan: TextSpan;\n        /** The span of the document to display when the user hovers over the collapsed span. */\n        hintSpan: TextSpan;\n        /** The text to display in the editor for the collapsed region. */\n        bannerText: string;\n        /**\n         * Whether or not this region should be automatically collapsed when\n         * the \'Collapse to Definitions\' command is invoked.\n         */\n        autoCollapse: boolean;\n        /**\n         * Classification of the contents of the span\n         */\n        kind: OutliningSpanKind;\n    }\n    enum OutliningSpanKind {\n        /** Single or multi-line comments */\n        Comment = "comment",\n        /** Sections marked by \'// #region\' and \'// #endregion\' comments */\n        Region = "region",\n        /** Declarations and expressions */\n        Code = "code",\n        /** Contiguous blocks of import declarations */\n        Imports = "imports"\n    }\n    enum OutputFileType {\n        JavaScript = 0,\n        SourceMap = 1,\n        Declaration = 2\n    }\n    enum EndOfLineState {\n        None = 0,\n        InMultiLineCommentTrivia = 1,\n        InSingleQuoteStringLiteral = 2,\n        InDoubleQuoteStringLiteral = 3,\n        InTemplateHeadOrNoSubstitutionTemplate = 4,\n        InTemplateMiddleOrTail = 5,\n        InTemplateSubstitutionPosition = 6\n    }\n    enum TokenClass {\n        Punctuation = 0,\n        Keyword = 1,\n        Operator = 2,\n        Comment = 3,\n        Whitespace = 4,\n        Identifier = 5,\n        NumberLiteral = 6,\n        BigIntLiteral = 7,\n        StringLiteral = 8,\n        RegExpLiteral = 9\n    }\n    interface ClassificationResult {\n        finalLexState: EndOfLineState;\n        entries: ClassificationInfo[];\n    }\n    interface ClassificationInfo {\n        length: number;\n        classification: TokenClass;\n    }\n    interface Classifier {\n        /**\n         * Gives lexical classifications of tokens on a line without any syntactic context.\n         * For instance, a token consisting of the text \'string\' can be either an identifier\n         * named \'string\' or the keyword \'string\', however, because this classifier is not aware,\n         * it relies on certain heuristics to give acceptable results. For classifications where\n         * speed trumps accuracy, this function is preferable; however, for true accuracy, the\n         * syntactic classifier is ideal. In fact, in certain editing scenarios, combining the\n         * lexical, syntactic, and semantic classifiers may issue the best user experience.\n         *\n         * @param text                      The text of a line to classify.\n         * @param lexState                  The state of the lexical classifier at the end of the previous line.\n         * @param syntacticClassifierAbsent Whether the client is *not* using a syntactic classifier.\n         *                                  If there is no syntactic classifier (syntacticClassifierAbsent=true),\n         *                                  certain heuristics may be used in its place; however, if there is a\n         *                                  syntactic classifier (syntacticClassifierAbsent=false), certain\n         *                                  classifications which may be incorrectly categorized will be given\n         *                                  back as Identifiers in order to allow the syntactic classifier to\n         *                                  subsume the classification.\n         * @deprecated Use getLexicalClassifications instead.\n         */\n        getClassificationsForLine(text: string, lexState: EndOfLineState, syntacticClassifierAbsent: boolean): ClassificationResult;\n        getEncodedLexicalClassifications(text: string, endOfLineState: EndOfLineState, syntacticClassifierAbsent: boolean): Classifications;\n    }\n    enum ScriptElementKind {\n        unknown = "",\n        warning = "warning",\n        /** predefined type (void) or keyword (class) */\n        keyword = "keyword",\n        /** top level script node */\n        scriptElement = "script",\n        /** module foo {} */\n        moduleElement = "module",\n        /** class X {} */\n        classElement = "class",\n        /** var x = class X {} */\n        localClassElement = "local class",\n        /** interface Y {} */\n        interfaceElement = "interface",\n        /** type T = ... */\n        typeElement = "type",\n        /** enum E */\n        enumElement = "enum",\n        enumMemberElement = "enum member",\n        /**\n         * Inside module and script only\n         * const v = ..\n         */\n        variableElement = "var",\n        /** Inside function */\n        localVariableElement = "local var",\n        /**\n         * Inside module and script only\n         * function f() { }\n         */\n        functionElement = "function",\n        /** Inside function */\n        localFunctionElement = "local function",\n        /** class X { [public|private]* foo() {} } */\n        memberFunctionElement = "method",\n        /** class X { [public|private]* [get|set] foo:number; } */\n        memberGetAccessorElement = "getter",\n        memberSetAccessorElement = "setter",\n        /**\n         * class X { [public|private]* foo:number; }\n         * interface Y { foo:number; }\n         */\n        memberVariableElement = "property",\n        /** class X { constructor() { } } */\n        constructorImplementationElement = "constructor",\n        /** interface Y { ():number; } */\n        callSignatureElement = "call",\n        /** interface Y { []:number; } */\n        indexSignatureElement = "index",\n        /** interface Y { new():Y; } */\n        constructSignatureElement = "construct",\n        /** function foo(*Y*: string) */\n        parameterElement = "parameter",\n        typeParameterElement = "type parameter",\n        primitiveType = "primitive type",\n        label = "label",\n        alias = "alias",\n        constElement = "const",\n        letElement = "let",\n        directory = "directory",\n        externalModuleName = "external module name",\n        /**\n         * <JsxTagName attribute1 attribute2={0} />\n         */\n        jsxAttribute = "JSX attribute",\n        /** String literal */\n        string = "string"\n    }\n    enum ScriptElementKindModifier {\n        none = "",\n        publicMemberModifier = "public",\n        privateMemberModifier = "private",\n        protectedMemberModifier = "protected",\n        exportedModifier = "export",\n        ambientModifier = "declare",\n        staticModifier = "static",\n        abstractModifier = "abstract",\n        optionalModifier = "optional",\n        dtsModifier = ".d.ts",\n        tsModifier = ".ts",\n        tsxModifier = ".tsx",\n        jsModifier = ".js",\n        jsxModifier = ".jsx",\n        jsonModifier = ".json"\n    }\n    enum ClassificationTypeNames {\n        comment = "comment",\n        identifier = "identifier",\n        keyword = "keyword",\n        numericLiteral = "number",\n        bigintLiteral = "bigint",\n        operator = "operator",\n        stringLiteral = "string",\n        whiteSpace = "whitespace",\n        text = "text",\n        punctuation = "punctuation",\n        className = "class name",\n        enumName = "enum name",\n        interfaceName = "interface name",\n        moduleName = "module name",\n        typeParameterName = "type parameter name",\n        typeAliasName = "type alias name",\n        parameterName = "parameter name",\n        docCommentTagName = "doc comment tag name",\n        jsxOpenTagName = "jsx open tag name",\n        jsxCloseTagName = "jsx close tag name",\n        jsxSelfClosingTagName = "jsx self closing tag name",\n        jsxAttribute = "jsx attribute",\n        jsxText = "jsx text",\n        jsxAttributeStringLiteralValue = "jsx attribute string literal value"\n    }\n    enum ClassificationType {\n        comment = 1,\n        identifier = 2,\n        keyword = 3,\n        numericLiteral = 4,\n        operator = 5,\n        stringLiteral = 6,\n        regularExpressionLiteral = 7,\n        whiteSpace = 8,\n        text = 9,\n        punctuation = 10,\n        className = 11,\n        enumName = 12,\n        interfaceName = 13,\n        moduleName = 14,\n        typeParameterName = 15,\n        typeAliasName = 16,\n        parameterName = 17,\n        docCommentTagName = 18,\n        jsxOpenTagName = 19,\n        jsxCloseTagName = 20,\n        jsxSelfClosingTagName = 21,\n        jsxAttribute = 22,\n        jsxText = 23,\n        jsxAttributeStringLiteralValue = 24,\n        bigintLiteral = 25\n    }\n}\ndeclare namespace ts {\n    /** The classifier is used for syntactic highlighting in editors via the TSServer */\n    function createClassifier(): Classifier;\n}\ndeclare namespace ts {\n    interface DocumentHighlights {\n        fileName: string;\n        highlightSpans: HighlightSpan[];\n    }\n}\ndeclare namespace ts {\n    /**\n     * The document registry represents a store of SourceFile objects that can be shared between\n     * multiple LanguageService instances. A LanguageService instance holds on the SourceFile (AST)\n     * of files in the context.\n     * SourceFile objects account for most of the memory usage by the language service. Sharing\n     * the same DocumentRegistry instance between different instances of LanguageService allow\n     * for more efficient memory utilization since all projects will share at least the library\n     * file (lib.d.ts).\n     *\n     * A more advanced use of the document registry is to serialize sourceFile objects to disk\n     * and re-hydrate them when needed.\n     *\n     * To create a default DocumentRegistry, use createDocumentRegistry to create one, and pass it\n     * to all subsequent createLanguageService calls.\n     */\n    interface DocumentRegistry {\n        /**\n         * Request a stored SourceFile with a given fileName and compilationSettings.\n         * The first call to acquire will call createLanguageServiceSourceFile to generate\n         * the SourceFile if was not found in the registry.\n         *\n         * @param fileName The name of the file requested\n         * @param compilationSettings Some compilation settings like target affects the\n         * shape of a the resulting SourceFile. This allows the DocumentRegistry to store\n         * multiple copies of the same file for different compilation settings.\n         * @param scriptSnapshot Text of the file. Only used if the file was not found\n         * in the registry and a new one was created.\n         * @param version Current version of the file. Only used if the file was not found\n         * in the registry and a new one was created.\n         */\n        acquireDocument(fileName: string, compilationSettings: CompilerOptions, scriptSnapshot: IScriptSnapshot, version: string, scriptKind?: ScriptKind): SourceFile;\n        acquireDocumentWithKey(fileName: string, path: Path, compilationSettings: CompilerOptions, key: DocumentRegistryBucketKey, scriptSnapshot: IScriptSnapshot, version: string, scriptKind?: ScriptKind): SourceFile;\n        /**\n         * Request an updated version of an already existing SourceFile with a given fileName\n         * and compilationSettings. The update will in-turn call updateLanguageServiceSourceFile\n         * to get an updated SourceFile.\n         *\n         * @param fileName The name of the file requested\n         * @param compilationSettings Some compilation settings like target affects the\n         * shape of a the resulting SourceFile. This allows the DocumentRegistry to store\n         * multiple copies of the same file for different compilation settings.\n         * @param scriptSnapshot Text of the file.\n         * @param version Current version of the file.\n         */\n        updateDocument(fileName: string, compilationSettings: CompilerOptions, scriptSnapshot: IScriptSnapshot, version: string, scriptKind?: ScriptKind): SourceFile;\n        updateDocumentWithKey(fileName: string, path: Path, compilationSettings: CompilerOptions, key: DocumentRegistryBucketKey, scriptSnapshot: IScriptSnapshot, version: string, scriptKind?: ScriptKind): SourceFile;\n        getKeyForCompilationSettings(settings: CompilerOptions): DocumentRegistryBucketKey;\n        /**\n         * Informs the DocumentRegistry that a file is not needed any longer.\n         *\n         * Note: It is not allowed to call release on a SourceFile that was not acquired from\n         * this registry originally.\n         *\n         * @param fileName The name of the file to be released\n         * @param compilationSettings The compilation settings used to acquire the file\n         */\n        releaseDocument(fileName: string, compilationSettings: CompilerOptions): void;\n        releaseDocumentWithKey(path: Path, key: DocumentRegistryBucketKey): void;\n        reportStats(): string;\n    }\n    type DocumentRegistryBucketKey = string & {\n        __bucketKey: any;\n    };\n    function createDocumentRegistry(useCaseSensitiveFileNames?: boolean, currentDirectory?: string): DocumentRegistry;\n}\ndeclare namespace ts {\n    function preProcessFile(sourceText: string, readImportFiles?: boolean, detectJavaScriptImports?: boolean): PreProcessedFileInfo;\n}\ndeclare namespace ts {\n    interface TranspileOptions {\n        compilerOptions?: CompilerOptions;\n        fileName?: string;\n        reportDiagnostics?: boolean;\n        moduleName?: string;\n        renamedDependencies?: MapLike<string>;\n        transformers?: CustomTransformers;\n    }\n    interface TranspileOutput {\n        outputText: string;\n        diagnostics?: Diagnostic[];\n        sourceMapText?: string;\n    }\n    function transpileModule(input: string, transpileOptions: TranspileOptions): TranspileOutput;\n    function transpile(input: string, compilerOptions?: CompilerOptions, fileName?: string, diagnostics?: Diagnostic[], moduleName?: string): string;\n}\ndeclare namespace ts {\n    /** The version of the language service API */\n    const servicesVersion = "0.8";\n    function toEditorSettings(options: EditorOptions | EditorSettings): EditorSettings;\n    function displayPartsToString(displayParts: SymbolDisplayPart[] | undefined): string;\n    function getDefaultCompilerOptions(): CompilerOptions;\n    function getSupportedCodeFixes(): string[];\n    function createLanguageServiceSourceFile(fileName: string, scriptSnapshot: IScriptSnapshot, scriptTarget: ScriptTarget, version: string, setNodeParents: boolean, scriptKind?: ScriptKind): SourceFile;\n    function updateLanguageServiceSourceFile(sourceFile: SourceFile, scriptSnapshot: IScriptSnapshot, version: string, textChangeRange: TextChangeRange | undefined, aggressiveChecks?: boolean): SourceFile;\n    function createLanguageService(host: LanguageServiceHost, documentRegistry?: DocumentRegistry, syntaxOnly?: boolean): LanguageService;\n    /**\n     * Get the path of the default library files (lib.d.ts) as distributed with the typescript\n     * node package.\n     * The functionality is not supported if the ts module is consumed outside of a node module.\n     */\n    function getDefaultLibFilePath(options: CompilerOptions): string;\n}\ndeclare namespace ts {\n    /**\n     * Transform one or more nodes using the supplied transformers.\n     * @param source A single `Node` or an array of `Node` objects.\n     * @param transformers An array of `TransformerFactory` callbacks used to process the transformation.\n     * @param compilerOptions Optional compiler options.\n     */\n    function transform<T extends Node>(source: T | T[], transformers: TransformerFactory<T>[], compilerOptions?: CompilerOptions): TransformationResult<T>;\n}\ndeclare namespace ts.server {\n    interface CompressedData {\n        length: number;\n        compressionKind: string;\n        data: any;\n    }\n    type RequireResult = {\n        module: {};\n        error: undefined;\n    } | {\n        module: undefined;\n        error: {\n            stack?: string;\n            message?: string;\n        };\n    };\n    interface ServerHost extends System {\n        watchFile(path: string, callback: FileWatcherCallback, pollingInterval?: number, options?: WatchOptions): FileWatcher;\n        watchDirectory(path: string, callback: DirectoryWatcherCallback, recursive?: boolean, options?: WatchOptions): FileWatcher;\n        setTimeout(callback: (...args: any[]) => void, ms: number, ...args: any[]): any;\n        clearTimeout(timeoutId: any): void;\n        setImmediate(callback: (...args: any[]) => void, ...args: any[]): any;\n        clearImmediate(timeoutId: any): void;\n        gc?(): void;\n        trace?(s: string): void;\n        require?(initialPath: string, moduleName: string): RequireResult;\n    }\n}\ndeclare namespace ts.server {\n    enum LogLevel {\n        terse = 0,\n        normal = 1,\n        requestTime = 2,\n        verbose = 3\n    }\n    const emptyArray: SortedReadonlyArray<never>;\n    interface Logger {\n        close(): void;\n        hasLevel(level: LogLevel): boolean;\n        loggingEnabled(): boolean;\n        perftrc(s: string): void;\n        info(s: string): void;\n        startGroup(): void;\n        endGroup(): void;\n        msg(s: string, type?: Msg): void;\n        getLogFileName(): string | undefined;\n    }\n    enum Msg {\n        Err = "Err",\n        Info = "Info",\n        Perf = "Perf"\n    }\n    namespace Msg {\n        /** @deprecated Only here for backwards-compatibility. Prefer just `Msg`. */\n        type Types = Msg;\n    }\n    function createInstallTypingsRequest(project: Project, typeAcquisition: TypeAcquisition, unresolvedImports: SortedReadonlyArray<string>, cachePath?: string): DiscoverTypings;\n    namespace Errors {\n        function ThrowNoProject(): never;\n        function ThrowProjectLanguageServiceDisabled(): never;\n        function ThrowProjectDoesNotContainDocument(fileName: string, project: Project): never;\n    }\n    type NormalizedPath = string & {\n        __normalizedPathTag: any;\n    };\n    function toNormalizedPath(fileName: string): NormalizedPath;\n    function normalizedPathToPath(normalizedPath: NormalizedPath, currentDirectory: string, getCanonicalFileName: (f: string) => string): Path;\n    function asNormalizedPath(fileName: string): NormalizedPath;\n    interface NormalizedPathMap<T> {\n        get(path: NormalizedPath): T | undefined;\n        set(path: NormalizedPath, value: T): void;\n        contains(path: NormalizedPath): boolean;\n        remove(path: NormalizedPath): void;\n    }\n    function createNormalizedPathMap<T>(): NormalizedPathMap<T>;\n    function isInferredProjectName(name: string): boolean;\n    function makeInferredProjectName(counter: number): string;\n    function createSortedArray<T>(): SortedArray<T>;\n}\n/**\n * Declaration module describing the TypeScript Server protocol\n */\ndeclare namespace ts.server.protocol {\n    enum CommandTypes {\n        JsxClosingTag = "jsxClosingTag",\n        Brace = "brace",\n        BraceCompletion = "braceCompletion",\n        GetSpanOfEnclosingComment = "getSpanOfEnclosingComment",\n        Change = "change",\n        Close = "close",\n        /** @deprecated Prefer CompletionInfo -- see comment on CompletionsResponse */\n        Completions = "completions",\n        CompletionInfo = "completionInfo",\n        CompletionDetails = "completionEntryDetails",\n        CompileOnSaveAffectedFileList = "compileOnSaveAffectedFileList",\n        CompileOnSaveEmitFile = "compileOnSaveEmitFile",\n        Configure = "configure",\n        Definition = "definition",\n        DefinitionAndBoundSpan = "definitionAndBoundSpan",\n        Implementation = "implementation",\n        Exit = "exit",\n        Format = "format",\n        Formatonkey = "formatonkey",\n        Geterr = "geterr",\n        GeterrForProject = "geterrForProject",\n        SemanticDiagnosticsSync = "semanticDiagnosticsSync",\n        SyntacticDiagnosticsSync = "syntacticDiagnosticsSync",\n        SuggestionDiagnosticsSync = "suggestionDiagnosticsSync",\n        NavBar = "navbar",\n        Navto = "navto",\n        NavTree = "navtree",\n        NavTreeFull = "navtree-full",\n        /** @deprecated */\n        Occurrences = "occurrences",\n        DocumentHighlights = "documentHighlights",\n        Open = "open",\n        Quickinfo = "quickinfo",\n        References = "references",\n        Reload = "reload",\n        Rename = "rename",\n        Saveto = "saveto",\n        SignatureHelp = "signatureHelp",\n        Status = "status",\n        TypeDefinition = "typeDefinition",\n        ProjectInfo = "projectInfo",\n        ReloadProjects = "reloadProjects",\n        Unknown = "unknown",\n        OpenExternalProject = "openExternalProject",\n        OpenExternalProjects = "openExternalProjects",\n        CloseExternalProject = "closeExternalProject",\n        UpdateOpen = "updateOpen",\n        GetOutliningSpans = "getOutliningSpans",\n        TodoComments = "todoComments",\n        Indentation = "indentation",\n        DocCommentTemplate = "docCommentTemplate",\n        CompilerOptionsForInferredProjects = "compilerOptionsForInferredProjects",\n        GetCodeFixes = "getCodeFixes",\n        GetCombinedCodeFix = "getCombinedCodeFix",\n        ApplyCodeActionCommand = "applyCodeActionCommand",\n        GetSupportedCodeFixes = "getSupportedCodeFixes",\n        GetApplicableRefactors = "getApplicableRefactors",\n        GetEditsForRefactor = "getEditsForRefactor",\n        OrganizeImports = "organizeImports",\n        GetEditsForFileRename = "getEditsForFileRename",\n        ConfigurePlugin = "configurePlugin",\n        SelectionRange = "selectionRange",\n        PrepareCallHierarchy = "prepareCallHierarchy",\n        ProvideCallHierarchyIncomingCalls = "provideCallHierarchyIncomingCalls",\n        ProvideCallHierarchyOutgoingCalls = "provideCallHierarchyOutgoingCalls"\n    }\n    /**\n     * A TypeScript Server message\n     */\n    interface Message {\n        /**\n         * Sequence number of the message\n         */\n        seq: number;\n        /**\n         * One of "request", "response", or "event"\n         */\n        type: "request" | "response" | "event";\n    }\n    /**\n     * Client-initiated request message\n     */\n    interface Request extends Message {\n        type: "request";\n        /**\n         * The command to execute\n         */\n        command: string;\n        /**\n         * Object containing arguments for the command\n         */\n        arguments?: any;\n    }\n    /**\n     * Request to reload the project structure for all the opened files\n     */\n    interface ReloadProjectsRequest extends Message {\n        command: CommandTypes.ReloadProjects;\n    }\n    /**\n     * Server-initiated event message\n     */\n    interface Event extends Message {\n        type: "event";\n        /**\n         * Name of event\n         */\n        event: string;\n        /**\n         * Event-specific information\n         */\n        body?: any;\n    }\n    /**\n     * Response by server to client request message.\n     */\n    interface Response extends Message {\n        type: "response";\n        /**\n         * Sequence number of the request message.\n         */\n        request_seq: number;\n        /**\n         * Outcome of the request.\n         */\n        success: boolean;\n        /**\n         * The command requested.\n         */\n        command: string;\n        /**\n         * If success === false, this should always be provided.\n         * Otherwise, may (or may not) contain a success message.\n         */\n        message?: string;\n        /**\n         * Contains message body if success === true.\n         */\n        body?: any;\n        /**\n         * Contains extra information that plugin can include to be passed on\n         */\n        metadata?: unknown;\n        /**\n         * Exposes information about the performance of this request-response pair.\n         */\n        performanceData?: PerformanceData;\n    }\n    interface PerformanceData {\n        /**\n         * Time spent updating the program graph, in milliseconds.\n         */\n        updateGraphDurationMs?: number;\n    }\n    /**\n     * Arguments for FileRequest messages.\n     */\n    interface FileRequestArgs {\n        /**\n         * The file for the request (absolute pathname required).\n         */\n        file: string;\n        projectFileName?: string;\n    }\n    interface StatusRequest extends Request {\n        command: CommandTypes.Status;\n    }\n    interface StatusResponseBody {\n        /**\n         * The TypeScript version (`ts.version`).\n         */\n        version: string;\n    }\n    /**\n     * Response to StatusRequest\n     */\n    interface StatusResponse extends Response {\n        body: StatusResponseBody;\n    }\n    /**\n     * Requests a JS Doc comment template for a given position\n     */\n    interface DocCommentTemplateRequest extends FileLocationRequest {\n        command: CommandTypes.DocCommentTemplate;\n    }\n    /**\n     * Response to DocCommentTemplateRequest\n     */\n    interface DocCommandTemplateResponse extends Response {\n        body?: TextInsertion;\n    }\n    /**\n     * A request to get TODO comments from the file\n     */\n    interface TodoCommentRequest extends FileRequest {\n        command: CommandTypes.TodoComments;\n        arguments: TodoCommentRequestArgs;\n    }\n    /**\n     * Arguments for TodoCommentRequest request.\n     */\n    interface TodoCommentRequestArgs extends FileRequestArgs {\n        /**\n         * Array of target TodoCommentDescriptors that describes TODO comments to be found\n         */\n        descriptors: TodoCommentDescriptor[];\n    }\n    /**\n     * Response for TodoCommentRequest request.\n     */\n    interface TodoCommentsResponse extends Response {\n        body?: TodoComment[];\n    }\n    /**\n     * A request to determine if the caret is inside a comment.\n     */\n    interface SpanOfEnclosingCommentRequest extends FileLocationRequest {\n        command: CommandTypes.GetSpanOfEnclosingComment;\n        arguments: SpanOfEnclosingCommentRequestArgs;\n    }\n    interface SpanOfEnclosingCommentRequestArgs extends FileLocationRequestArgs {\n        /**\n         * Requires that the enclosing span be a multi-line comment, or else the request returns undefined.\n         */\n        onlyMultiLine: boolean;\n    }\n    /**\n     * Request to obtain outlining spans in file.\n     */\n    interface OutliningSpansRequest extends FileRequest {\n        command: CommandTypes.GetOutliningSpans;\n    }\n    interface OutliningSpan {\n        /** The span of the document to actually collapse. */\n        textSpan: TextSpan;\n        /** The span of the document to display when the user hovers over the collapsed span. */\n        hintSpan: TextSpan;\n        /** The text to display in the editor for the collapsed region. */\n        bannerText: string;\n        /**\n         * Whether or not this region should be automatically collapsed when\n         * the \'Collapse to Definitions\' command is invoked.\n         */\n        autoCollapse: boolean;\n        /**\n         * Classification of the contents of the span\n         */\n        kind: OutliningSpanKind;\n    }\n    /**\n     * Response to OutliningSpansRequest request.\n     */\n    interface OutliningSpansResponse extends Response {\n        body?: OutliningSpan[];\n    }\n    /**\n     * A request to get indentation for a location in file\n     */\n    interface IndentationRequest extends FileLocationRequest {\n        command: CommandTypes.Indentation;\n        arguments: IndentationRequestArgs;\n    }\n    /**\n     * Response for IndentationRequest request.\n     */\n    interface IndentationResponse extends Response {\n        body?: IndentationResult;\n    }\n    /**\n     * Indentation result representing where indentation should be placed\n     */\n    interface IndentationResult {\n        /**\n         * The base position in the document that the indent should be relative to\n         */\n        position: number;\n        /**\n         * The number of columns the indent should be at relative to the position\'s column.\n         */\n        indentation: number;\n    }\n    /**\n     * Arguments for IndentationRequest request.\n     */\n    interface IndentationRequestArgs extends FileLocationRequestArgs {\n        /**\n         * An optional set of settings to be used when computing indentation.\n         * If argument is omitted - then it will use settings for file that were previously set via \'configure\' request or global settings.\n         */\n        options?: EditorSettings;\n    }\n    /**\n     * Arguments for ProjectInfoRequest request.\n     */\n    interface ProjectInfoRequestArgs extends FileRequestArgs {\n        /**\n         * Indicate if the file name list of the project is needed\n         */\n        needFileNameList: boolean;\n    }\n    /**\n     * A request to get the project information of the current file.\n     */\n    interface ProjectInfoRequest extends Request {\n        command: CommandTypes.ProjectInfo;\n        arguments: ProjectInfoRequestArgs;\n    }\n    /**\n     * A request to retrieve compiler options diagnostics for a project\n     */\n    interface CompilerOptionsDiagnosticsRequest extends Request {\n        arguments: CompilerOptionsDiagnosticsRequestArgs;\n    }\n    /**\n     * Arguments for CompilerOptionsDiagnosticsRequest request.\n     */\n    interface CompilerOptionsDiagnosticsRequestArgs {\n        /**\n         * Name of the project to retrieve compiler options diagnostics.\n         */\n        projectFileName: string;\n    }\n    /**\n     * Response message body for "projectInfo" request\n     */\n    interface ProjectInfo {\n        /**\n         * For configured project, this is the normalized path of the \'tsconfig.json\' file\n         * For inferred project, this is undefined\n         */\n        configFileName: string;\n        /**\n         * The list of normalized file name in the project, including \'lib.d.ts\'\n         */\n        fileNames?: string[];\n        /**\n         * Indicates if the project has a active language service instance\n         */\n        languageServiceDisabled?: boolean;\n    }\n    /**\n     * Represents diagnostic info that includes location of diagnostic in two forms\n     * - start position and length of the error span\n     * - startLocation and endLocation - a pair of Location objects that store start/end line and offset of the error span.\n     */\n    interface DiagnosticWithLinePosition {\n        message: string;\n        start: number;\n        length: number;\n        startLocation: Location;\n        endLocation: Location;\n        category: string;\n        code: number;\n        /** May store more in future. For now, this will simply be `true` to indicate when a diagnostic is an unused-identifier diagnostic. */\n        reportsUnnecessary?: {};\n        relatedInformation?: DiagnosticRelatedInformation[];\n    }\n    /**\n     * Response message for "projectInfo" request\n     */\n    interface ProjectInfoResponse extends Response {\n        body?: ProjectInfo;\n    }\n    /**\n     * Request whose sole parameter is a file name.\n     */\n    interface FileRequest extends Request {\n        arguments: FileRequestArgs;\n    }\n    /**\n     * Instances of this interface specify a location in a source file:\n     * (file, line, character offset), where line and character offset are 1-based.\n     */\n    interface FileLocationRequestArgs extends FileRequestArgs {\n        /**\n         * The line number for the request (1-based).\n         */\n        line: number;\n        /**\n         * The character offset (on the line) for the request (1-based).\n         */\n        offset: number;\n    }\n    type FileLocationOrRangeRequestArgs = FileLocationRequestArgs | FileRangeRequestArgs;\n    /**\n     * Request refactorings at a given position or selection area.\n     */\n    interface GetApplicableRefactorsRequest extends Request {\n        command: CommandTypes.GetApplicableRefactors;\n        arguments: GetApplicableRefactorsRequestArgs;\n    }\n    type GetApplicableRefactorsRequestArgs = FileLocationOrRangeRequestArgs;\n    /**\n     * Response is a list of available refactorings.\n     * Each refactoring exposes one or more "Actions"; a user selects one action to invoke a refactoring\n     */\n    interface GetApplicableRefactorsResponse extends Response {\n        body?: ApplicableRefactorInfo[];\n    }\n    /**\n     * A set of one or more available refactoring actions, grouped under a parent refactoring.\n     */\n    interface ApplicableRefactorInfo {\n        /**\n         * The programmatic name of the refactoring\n         */\n        name: string;\n        /**\n         * A description of this refactoring category to show to the user.\n         * If the refactoring gets inlined (see below), this text will not be visible.\n         */\n        description: string;\n        /**\n         * Inlineable refactorings can have their actions hoisted out to the top level\n         * of a context menu. Non-inlineanable refactorings should always be shown inside\n         * their parent grouping.\n         *\n         * If not specified, this value is assumed to be \'true\'\n         */\n        inlineable?: boolean;\n        actions: RefactorActionInfo[];\n    }\n    /**\n     * Represents a single refactoring action - for example, the "Extract Method..." refactor might\n     * offer several actions, each corresponding to a surround class or closure to extract into.\n     */\n    interface RefactorActionInfo {\n        /**\n         * The programmatic name of the refactoring action\n         */\n        name: string;\n        /**\n         * A description of this refactoring action to show to the user.\n         * If the parent refactoring is inlined away, this will be the only text shown,\n         * so this description should make sense by itself if the parent is inlineable=true\n         */\n        description: string;\n    }\n    interface GetEditsForRefactorRequest extends Request {\n        command: CommandTypes.GetEditsForRefactor;\n        arguments: GetEditsForRefactorRequestArgs;\n    }\n    /**\n     * Request the edits that a particular refactoring action produces.\n     * Callers must specify the name of the refactor and the name of the action.\n     */\n    type GetEditsForRefactorRequestArgs = FileLocationOrRangeRequestArgs & {\n        refactor: string;\n        action: string;\n    };\n    interface GetEditsForRefactorResponse extends Response {\n        body?: RefactorEditInfo;\n    }\n    interface RefactorEditInfo {\n        edits: FileCodeEdits[];\n        /**\n         * An optional location where the editor should start a rename operation once\n         * the refactoring edits have been applied\n         */\n        renameLocation?: Location;\n        renameFilename?: string;\n    }\n    /**\n     * Organize imports by:\n     *   1) Removing unused imports\n     *   2) Coalescing imports from the same module\n     *   3) Sorting imports\n     */\n    interface OrganizeImportsRequest extends Request {\n        command: CommandTypes.OrganizeImports;\n        arguments: OrganizeImportsRequestArgs;\n    }\n    type OrganizeImportsScope = GetCombinedCodeFixScope;\n    interface OrganizeImportsRequestArgs {\n        scope: OrganizeImportsScope;\n    }\n    interface OrganizeImportsResponse extends Response {\n        body: readonly FileCodeEdits[];\n    }\n    interface GetEditsForFileRenameRequest extends Request {\n        command: CommandTypes.GetEditsForFileRename;\n        arguments: GetEditsForFileRenameRequestArgs;\n    }\n    /** Note: Paths may also be directories. */\n    interface GetEditsForFileRenameRequestArgs {\n        readonly oldFilePath: string;\n        readonly newFilePath: string;\n    }\n    interface GetEditsForFileRenameResponse extends Response {\n        body: readonly FileCodeEdits[];\n    }\n    /**\n     * Request for the available codefixes at a specific position.\n     */\n    interface CodeFixRequest extends Request {\n        command: CommandTypes.GetCodeFixes;\n        arguments: CodeFixRequestArgs;\n    }\n    interface GetCombinedCodeFixRequest extends Request {\n        command: CommandTypes.GetCombinedCodeFix;\n        arguments: GetCombinedCodeFixRequestArgs;\n    }\n    interface GetCombinedCodeFixResponse extends Response {\n        body: CombinedCodeActions;\n    }\n    interface ApplyCodeActionCommandRequest extends Request {\n        command: CommandTypes.ApplyCodeActionCommand;\n        arguments: ApplyCodeActionCommandRequestArgs;\n    }\n    interface ApplyCodeActionCommandResponse extends Response {\n    }\n    interface FileRangeRequestArgs extends FileRequestArgs {\n        /**\n         * The line number for the request (1-based).\n         */\n        startLine: number;\n        /**\n         * The character offset (on the line) for the request (1-based).\n         */\n        startOffset: number;\n        /**\n         * The line number for the request (1-based).\n         */\n        endLine: number;\n        /**\n         * The character offset (on the line) for the request (1-based).\n         */\n        endOffset: number;\n    }\n    /**\n     * Instances of this interface specify errorcodes on a specific location in a sourcefile.\n     */\n    interface CodeFixRequestArgs extends FileRangeRequestArgs {\n        /**\n         * Errorcodes we want to get the fixes for.\n         */\n        errorCodes: readonly number[];\n    }\n    interface GetCombinedCodeFixRequestArgs {\n        scope: GetCombinedCodeFixScope;\n        fixId: {};\n    }\n    interface GetCombinedCodeFixScope {\n        type: "file";\n        args: FileRequestArgs;\n    }\n    interface ApplyCodeActionCommandRequestArgs {\n        /** May also be an array of commands. */\n        command: {};\n    }\n    /**\n     * Response for GetCodeFixes request.\n     */\n    interface GetCodeFixesResponse extends Response {\n        body?: CodeAction[];\n    }\n    /**\n     * A request whose arguments specify a file location (file, line, col).\n     */\n    interface FileLocationRequest extends FileRequest {\n        arguments: FileLocationRequestArgs;\n    }\n    /**\n     * A request to get codes of supported code fixes.\n     */\n    interface GetSupportedCodeFixesRequest extends Request {\n        command: CommandTypes.GetSupportedCodeFixes;\n    }\n    /**\n     * A response for GetSupportedCodeFixesRequest request.\n     */\n    interface GetSupportedCodeFixesResponse extends Response {\n        /**\n         * List of error codes supported by the server.\n         */\n        body?: string[];\n    }\n    /**\n     * Arguments in document highlight request; include: filesToSearch, file,\n     * line, offset.\n     */\n    interface DocumentHighlightsRequestArgs extends FileLocationRequestArgs {\n        /**\n         * List of files to search for document highlights.\n         */\n        filesToSearch: string[];\n    }\n    /**\n     * Go to definition request; value of command field is\n     * "definition". Return response giving the file locations that\n     * define the symbol found in file at location line, col.\n     */\n    interface DefinitionRequest extends FileLocationRequest {\n        command: CommandTypes.Definition;\n    }\n    interface DefinitionAndBoundSpanRequest extends FileLocationRequest {\n        readonly command: CommandTypes.DefinitionAndBoundSpan;\n    }\n    interface DefinitionAndBoundSpanResponse extends Response {\n        readonly body: DefinitionInfoAndBoundSpan;\n    }\n    /**\n     * Go to type request; value of command field is\n     * "typeDefinition". Return response giving the file locations that\n     * define the type for the symbol found in file at location line, col.\n     */\n    interface TypeDefinitionRequest extends FileLocationRequest {\n        command: CommandTypes.TypeDefinition;\n    }\n    /**\n     * Go to implementation request; value of command field is\n     * "implementation". Return response giving the file locations that\n     * implement the symbol found in file at location line, col.\n     */\n    interface ImplementationRequest extends FileLocationRequest {\n        command: CommandTypes.Implementation;\n    }\n    /**\n     * Location in source code expressed as (one-based) line and (one-based) column offset.\n     */\n    interface Location {\n        line: number;\n        offset: number;\n    }\n    /**\n     * Object found in response messages defining a span of text in source code.\n     */\n    interface TextSpan {\n        /**\n         * First character of the definition.\n         */\n        start: Location;\n        /**\n         * One character past last character of the definition.\n         */\n        end: Location;\n    }\n    /**\n     * Object found in response messages defining a span of text in a specific source file.\n     */\n    interface FileSpan extends TextSpan {\n        /**\n         * File containing text span.\n         */\n        file: string;\n    }\n    interface TextSpanWithContext extends TextSpan {\n        contextStart?: Location;\n        contextEnd?: Location;\n    }\n    interface FileSpanWithContext extends FileSpan, TextSpanWithContext {\n    }\n    interface DefinitionInfoAndBoundSpan {\n        definitions: readonly FileSpanWithContext[];\n        textSpan: TextSpan;\n    }\n    /**\n     * Definition response message.  Gives text range for definition.\n     */\n    interface DefinitionResponse extends Response {\n        body?: FileSpanWithContext[];\n    }\n    interface DefinitionInfoAndBoundSpanResponse extends Response {\n        body?: DefinitionInfoAndBoundSpan;\n    }\n    /** @deprecated Use `DefinitionInfoAndBoundSpanResponse` instead. */\n    type DefinitionInfoAndBoundSpanReponse = DefinitionInfoAndBoundSpanResponse;\n    /**\n     * Definition response message.  Gives text range for definition.\n     */\n    interface TypeDefinitionResponse extends Response {\n        body?: FileSpanWithContext[];\n    }\n    /**\n     * Implementation response message.  Gives text range for implementations.\n     */\n    interface ImplementationResponse extends Response {\n        body?: FileSpanWithContext[];\n    }\n    /**\n     * Request to get brace completion for a location in the file.\n     */\n    interface BraceCompletionRequest extends FileLocationRequest {\n        command: CommandTypes.BraceCompletion;\n        arguments: BraceCompletionRequestArgs;\n    }\n    /**\n     * Argument for BraceCompletionRequest request.\n     */\n    interface BraceCompletionRequestArgs extends FileLocationRequestArgs {\n        /**\n         * Kind of opening brace\n         */\n        openingBrace: string;\n    }\n    interface JsxClosingTagRequest extends FileLocationRequest {\n        readonly command: CommandTypes.JsxClosingTag;\n        readonly arguments: JsxClosingTagRequestArgs;\n    }\n    interface JsxClosingTagRequestArgs extends FileLocationRequestArgs {\n    }\n    interface JsxClosingTagResponse extends Response {\n        readonly body: TextInsertion;\n    }\n    /**\n     * @deprecated\n     * Get occurrences request; value of command field is\n     * "occurrences". Return response giving spans that are relevant\n     * in the file at a given line and column.\n     */\n    interface OccurrencesRequest extends FileLocationRequest {\n        command: CommandTypes.Occurrences;\n    }\n    /** @deprecated */\n    interface OccurrencesResponseItem extends FileSpanWithContext {\n        /**\n         * True if the occurrence is a write location, false otherwise.\n         */\n        isWriteAccess: boolean;\n        /**\n         * True if the occurrence is in a string, undefined otherwise;\n         */\n        isInString?: true;\n    }\n    /** @deprecated */\n    interface OccurrencesResponse extends Response {\n        body?: OccurrencesResponseItem[];\n    }\n    /**\n     * Get document highlights request; value of command field is\n     * "documentHighlights". Return response giving spans that are relevant\n     * in the file at a given line and column.\n     */\n    interface DocumentHighlightsRequest extends FileLocationRequest {\n        command: CommandTypes.DocumentHighlights;\n        arguments: DocumentHighlightsRequestArgs;\n    }\n    /**\n     * Span augmented with extra information that denotes the kind of the highlighting to be used for span.\n     */\n    interface HighlightSpan extends TextSpanWithContext {\n        kind: HighlightSpanKind;\n    }\n    /**\n     * Represents a set of highligh spans for a give name\n     */\n    interface DocumentHighlightsItem {\n        /**\n         * File containing highlight spans.\n         */\n        file: string;\n        /**\n         * Spans to highlight in file.\n         */\n        highlightSpans: HighlightSpan[];\n    }\n    /**\n     * Response for a DocumentHighlightsRequest request.\n     */\n    interface DocumentHighlightsResponse extends Response {\n        body?: DocumentHighlightsItem[];\n    }\n    /**\n     * Find references request; value of command field is\n     * "references". Return response giving the file locations that\n     * reference the symbol found in file at location line, col.\n     */\n    interface ReferencesRequest extends FileLocationRequest {\n        command: CommandTypes.References;\n    }\n    interface ReferencesResponseItem extends FileSpanWithContext {\n        /** Text of line containing the reference.  Including this\n         *  with the response avoids latency of editor loading files\n         * to show text of reference line (the server already has\n         * loaded the referencing files).\n         */\n        lineText: string;\n        /**\n         * True if reference is a write location, false otherwise.\n         */\n        isWriteAccess: boolean;\n        /**\n         * True if reference is a definition, false otherwise.\n         */\n        isDefinition: boolean;\n    }\n    /**\n     * The body of a "references" response message.\n     */\n    interface ReferencesResponseBody {\n        /**\n         * The file locations referencing the symbol.\n         */\n        refs: readonly ReferencesResponseItem[];\n        /**\n         * The name of the symbol.\n         */\n        symbolName: string;\n        /**\n         * The start character offset of the symbol (on the line provided by the references request).\n         */\n        symbolStartOffset: number;\n        /**\n         * The full display name of the symbol.\n         */\n        symbolDisplayString: string;\n    }\n    /**\n     * Response to "references" request.\n     */\n    interface ReferencesResponse extends Response {\n        body?: ReferencesResponseBody;\n    }\n    /**\n     * Argument for RenameRequest request.\n     */\n    interface RenameRequestArgs extends FileLocationRequestArgs {\n        /**\n         * Should text at specified location be found/changed in comments?\n         */\n        findInComments?: boolean;\n        /**\n         * Should text at specified location be found/changed in strings?\n         */\n        findInStrings?: boolean;\n    }\n    /**\n     * Rename request; value of command field is "rename". Return\n     * response giving the file locations that reference the symbol\n     * found in file at location line, col. Also return full display\n     * name of the symbol so that client can print it unambiguously.\n     */\n    interface RenameRequest extends FileLocationRequest {\n        command: CommandTypes.Rename;\n        arguments: RenameRequestArgs;\n    }\n    /**\n     * Information about the item to be renamed.\n     */\n    type RenameInfo = RenameInfoSuccess | RenameInfoFailure;\n    interface RenameInfoSuccess {\n        /**\n         * True if item can be renamed.\n         */\n        canRename: true;\n        /**\n         * File or directory to rename.\n         * If set, `getEditsForFileRename` should be called instead of `findRenameLocations`.\n         */\n        fileToRename?: string;\n        /**\n         * Display name of the item to be renamed.\n         */\n        displayName: string;\n        /**\n         * Full display name of item to be renamed.\n         */\n        fullDisplayName: string;\n        /**\n         * The items\'s kind (such as \'className\' or \'parameterName\' or plain \'text\').\n         */\n        kind: ScriptElementKind;\n        /**\n         * Optional modifiers for the kind (such as \'public\').\n         */\n        kindModifiers: string;\n        /** Span of text to rename. */\n        triggerSpan: TextSpan;\n    }\n    interface RenameInfoFailure {\n        canRename: false;\n        /**\n         * Error message if item can not be renamed.\n         */\n        localizedErrorMessage: string;\n    }\n    /**\n     *  A group of text spans, all in \'file\'.\n     */\n    interface SpanGroup {\n        /** The file to which the spans apply */\n        file: string;\n        /** The text spans in this group */\n        locs: RenameTextSpan[];\n    }\n    interface RenameTextSpan extends TextSpanWithContext {\n        readonly prefixText?: string;\n        readonly suffixText?: string;\n    }\n    interface RenameResponseBody {\n        /**\n         * Information about the item to be renamed.\n         */\n        info: RenameInfo;\n        /**\n         * An array of span groups (one per file) that refer to the item to be renamed.\n         */\n        locs: readonly SpanGroup[];\n    }\n    /**\n     * Rename response message.\n     */\n    interface RenameResponse extends Response {\n        body?: RenameResponseBody;\n    }\n    /**\n     * Represents a file in external project.\n     * External project is project whose set of files, compilation options and open\\close state\n     * is maintained by the client (i.e. if all this data come from .csproj file in Visual Studio).\n     * External project will exist even if all files in it are closed and should be closed explicitly.\n     * If external project includes one or more tsconfig.json/jsconfig.json files then tsserver will\n     * create configured project for every config file but will maintain a link that these projects were created\n     * as a result of opening external project so they should be removed once external project is closed.\n     */\n    interface ExternalFile {\n        /**\n         * Name of file file\n         */\n        fileName: string;\n        /**\n         * Script kind of the file\n         */\n        scriptKind?: ScriptKindName | ts.ScriptKind;\n        /**\n         * Whether file has mixed content (i.e. .cshtml file that combines html markup with C#/JavaScript)\n         */\n        hasMixedContent?: boolean;\n        /**\n         * Content of the file\n         */\n        content?: string;\n    }\n    /**\n     * Represent an external project\n     */\n    interface ExternalProject {\n        /**\n         * Project name\n         */\n        projectFileName: string;\n        /**\n         * List of root files in project\n         */\n        rootFiles: ExternalFile[];\n        /**\n         * Compiler options for the project\n         */\n        options: ExternalProjectCompilerOptions;\n        /**\n         * @deprecated typingOptions. Use typeAcquisition instead\n         */\n        typingOptions?: TypeAcquisition;\n        /**\n         * Explicitly specified type acquisition for the project\n         */\n        typeAcquisition?: TypeAcquisition;\n    }\n    interface CompileOnSaveMixin {\n        /**\n         * If compile on save is enabled for the project\n         */\n        compileOnSave?: boolean;\n    }\n    /**\n     * For external projects, some of the project settings are sent together with\n     * compiler settings.\n     */\n    type ExternalProjectCompilerOptions = CompilerOptions & CompileOnSaveMixin & WatchOptions;\n    interface FileWithProjectReferenceRedirectInfo {\n        /**\n         * Name of file\n         */\n        fileName: string;\n        /**\n         * True if the file is primarily included in a referenced project\n         */\n        isSourceOfProjectReferenceRedirect: boolean;\n    }\n    /**\n     * Represents a set of changes that happen in project\n     */\n    interface ProjectChanges {\n        /**\n         * List of added files\n         */\n        added: string[] | FileWithProjectReferenceRedirectInfo[];\n        /**\n         * List of removed files\n         */\n        removed: string[] | FileWithProjectReferenceRedirectInfo[];\n        /**\n         * List of updated files\n         */\n        updated: string[] | FileWithProjectReferenceRedirectInfo[];\n        /**\n         * List of files that have had their project reference redirect status updated\n         * Only provided when the synchronizeProjectList request has includeProjectReferenceRedirectInfo set to true\n         */\n        updatedRedirects?: FileWithProjectReferenceRedirectInfo[];\n    }\n    /**\n     * Information found in a configure request.\n     */\n    interface ConfigureRequestArguments {\n        /**\n         * Information about the host, for example \'Emacs 24.4\' or\n         * \'Sublime Text version 3075\'\n         */\n        hostInfo?: string;\n        /**\n         * If present, tab settings apply only to this file.\n         */\n        file?: string;\n        /**\n         * The format options to use during formatting and other code editing features.\n         */\n        formatOptions?: FormatCodeSettings;\n        preferences?: UserPreferences;\n        /**\n         * The host\'s additional supported .js file extensions\n         */\n        extraFileExtensions?: FileExtensionInfo[];\n        watchOptions?: WatchOptions;\n    }\n    enum WatchFileKind {\n        FixedPollingInterval = "FixedPollingInterval",\n        PriorityPollingInterval = "PriorityPollingInterval",\n        DynamicPriorityPolling = "DynamicPriorityPolling",\n        UseFsEvents = "UseFsEvents",\n        UseFsEventsOnParentDirectory = "UseFsEventsOnParentDirectory"\n    }\n    enum WatchDirectoryKind {\n        UseFsEvents = "UseFsEvents",\n        FixedPollingInterval = "FixedPollingInterval",\n        DynamicPriorityPolling = "DynamicPriorityPolling"\n    }\n    enum PollingWatchKind {\n        FixedInterval = "FixedInterval",\n        PriorityInterval = "PriorityInterval",\n        DynamicPriority = "DynamicPriority"\n    }\n    interface WatchOptions {\n        watchFile?: WatchFileKind | ts.WatchFileKind;\n        watchDirectory?: WatchDirectoryKind | ts.WatchDirectoryKind;\n        fallbackPolling?: PollingWatchKind | ts.PollingWatchKind;\n        synchronousWatchDirectory?: boolean;\n        [option: string]: CompilerOptionsValue | undefined;\n    }\n    /**\n     *  Configure request; value of command field is "configure".  Specifies\n     *  host information, such as host type, tab size, and indent size.\n     */\n    interface ConfigureRequest extends Request {\n        command: CommandTypes.Configure;\n        arguments: ConfigureRequestArguments;\n    }\n    /**\n     * Response to "configure" request.  This is just an acknowledgement, so\n     * no body field is required.\n     */\n    interface ConfigureResponse extends Response {\n    }\n    interface ConfigurePluginRequestArguments {\n        pluginName: string;\n        configuration: any;\n    }\n    interface ConfigurePluginRequest extends Request {\n        command: CommandTypes.ConfigurePlugin;\n        arguments: ConfigurePluginRequestArguments;\n    }\n    interface ConfigurePluginResponse extends Response {\n    }\n    interface SelectionRangeRequest extends FileRequest {\n        command: CommandTypes.SelectionRange;\n        arguments: SelectionRangeRequestArgs;\n    }\n    interface SelectionRangeRequestArgs extends FileRequestArgs {\n        locations: Location[];\n    }\n    interface SelectionRangeResponse extends Response {\n        body?: SelectionRange[];\n    }\n    interface SelectionRange {\n        textSpan: TextSpan;\n        parent?: SelectionRange;\n    }\n    /**\n     *  Information found in an "open" request.\n     */\n    interface OpenRequestArgs extends FileRequestArgs {\n        /**\n         * Used when a version of the file content is known to be more up to date than the one on disk.\n         * Then the known content will be used upon opening instead of the disk copy\n         */\n        fileContent?: string;\n        /**\n         * Used to specify the script kind of the file explicitly. It could be one of the following:\n         *      "TS", "JS", "TSX", "JSX"\n         */\n        scriptKindName?: ScriptKindName;\n        /**\n         * Used to limit the searching for project config file. If given the searching will stop at this\n         * root path; otherwise it will go all the way up to the dist root path.\n         */\n        projectRootPath?: string;\n    }\n    type ScriptKindName = "TS" | "JS" | "TSX" | "JSX";\n    /**\n     * Open request; value of command field is "open". Notify the\n     * server that the client has file open.  The server will not\n     * monitor the filesystem for changes in this file and will assume\n     * that the client is updating the server (using the change and/or\n     * reload messages) when the file changes. Server does not currently\n     * send a response to an open request.\n     */\n    interface OpenRequest extends Request {\n        command: CommandTypes.Open;\n        arguments: OpenRequestArgs;\n    }\n    /**\n     * Request to open or update external project\n     */\n    interface OpenExternalProjectRequest extends Request {\n        command: CommandTypes.OpenExternalProject;\n        arguments: OpenExternalProjectArgs;\n    }\n    /**\n     * Arguments to OpenExternalProjectRequest request\n     */\n    type OpenExternalProjectArgs = ExternalProject;\n    /**\n     * Request to open multiple external projects\n     */\n    interface OpenExternalProjectsRequest extends Request {\n        command: CommandTypes.OpenExternalProjects;\n        arguments: OpenExternalProjectsArgs;\n    }\n    /**\n     * Arguments to OpenExternalProjectsRequest\n     */\n    interface OpenExternalProjectsArgs {\n        /**\n         * List of external projects to open or update\n         */\n        projects: ExternalProject[];\n    }\n    /**\n     * Response to OpenExternalProjectRequest request. This is just an acknowledgement, so\n     * no body field is required.\n     */\n    interface OpenExternalProjectResponse extends Response {\n    }\n    /**\n     * Response to OpenExternalProjectsRequest request. This is just an acknowledgement, so\n     * no body field is required.\n     */\n    interface OpenExternalProjectsResponse extends Response {\n    }\n    /**\n     * Request to close external project.\n     */\n    interface CloseExternalProjectRequest extends Request {\n        command: CommandTypes.CloseExternalProject;\n        arguments: CloseExternalProjectRequestArgs;\n    }\n    /**\n     * Arguments to CloseExternalProjectRequest request\n     */\n    interface CloseExternalProjectRequestArgs {\n        /**\n         * Name of the project to close\n         */\n        projectFileName: string;\n    }\n    /**\n     * Response to CloseExternalProjectRequest request. This is just an acknowledgement, so\n     * no body field is required.\n     */\n    interface CloseExternalProjectResponse extends Response {\n    }\n    /**\n     * Request to synchronize list of open files with the client\n     */\n    interface UpdateOpenRequest extends Request {\n        command: CommandTypes.UpdateOpen;\n        arguments: UpdateOpenRequestArgs;\n    }\n    /**\n     * Arguments to UpdateOpenRequest\n     */\n    interface UpdateOpenRequestArgs {\n        /**\n         * List of newly open files\n         */\n        openFiles?: OpenRequestArgs[];\n        /**\n         * List of open files files that were changes\n         */\n        changedFiles?: FileCodeEdits[];\n        /**\n         * List of files that were closed\n         */\n        closedFiles?: string[];\n    }\n    /**\n     * Request to set compiler options for inferred projects.\n     * External projects are opened / closed explicitly.\n     * Configured projects are opened when user opens loose file that has \'tsconfig.json\' or \'jsconfig.json\' anywhere in one of containing folders.\n     * This configuration file will be used to obtain a list of files and configuration settings for the project.\n     * Inferred projects are created when user opens a loose file that is not the part of external project\n     * or configured project and will contain only open file and transitive closure of referenced files if \'useOneInferredProject\' is false,\n     * or all open loose files and its transitive closure of referenced files if \'useOneInferredProject\' is true.\n     */\n    interface SetCompilerOptionsForInferredProjectsRequest extends Request {\n        command: CommandTypes.CompilerOptionsForInferredProjects;\n        arguments: SetCompilerOptionsForInferredProjectsArgs;\n    }\n    /**\n     * Argument for SetCompilerOptionsForInferredProjectsRequest request.\n     */\n    interface SetCompilerOptionsForInferredProjectsArgs {\n        /**\n         * Compiler options to be used with inferred projects.\n         */\n        options: ExternalProjectCompilerOptions;\n        /**\n         * Specifies the project root path used to scope compiler options.\n         * It is an error to provide this property if the server has not been started with\n         * `useInferredProjectPerProjectRoot` enabled.\n         */\n        projectRootPath?: string;\n    }\n    /**\n     * Response to SetCompilerOptionsForInferredProjectsResponse request. This is just an acknowledgement, so\n     * no body field is required.\n     */\n    interface SetCompilerOptionsForInferredProjectsResponse extends Response {\n    }\n    /**\n     *  Exit request; value of command field is "exit".  Ask the server process\n     *  to exit.\n     */\n    interface ExitRequest extends Request {\n        command: CommandTypes.Exit;\n    }\n    /**\n     * Close request; value of command field is "close". Notify the\n     * server that the client has closed a previously open file.  If\n     * file is still referenced by open files, the server will resume\n     * monitoring the filesystem for changes to file.  Server does not\n     * currently send a response to a close request.\n     */\n    interface CloseRequest extends FileRequest {\n        command: CommandTypes.Close;\n    }\n    /**\n     * Request to obtain the list of files that should be regenerated if target file is recompiled.\n     * NOTE: this us query-only operation and does not generate any output on disk.\n     */\n    interface CompileOnSaveAffectedFileListRequest extends FileRequest {\n        command: CommandTypes.CompileOnSaveAffectedFileList;\n    }\n    /**\n     * Contains a list of files that should be regenerated in a project\n     */\n    interface CompileOnSaveAffectedFileListSingleProject {\n        /**\n         * Project name\n         */\n        projectFileName: string;\n        /**\n         * List of files names that should be recompiled\n         */\n        fileNames: string[];\n        /**\n         * true if project uses outFile or out compiler option\n         */\n        projectUsesOutFile: boolean;\n    }\n    /**\n     * Response for CompileOnSaveAffectedFileListRequest request;\n     */\n    interface CompileOnSaveAffectedFileListResponse extends Response {\n        body: CompileOnSaveAffectedFileListSingleProject[];\n    }\n    /**\n     * Request to recompile the file. All generated outputs (.js, .d.ts or .js.map files) is written on disk.\n     */\n    interface CompileOnSaveEmitFileRequest extends FileRequest {\n        command: CommandTypes.CompileOnSaveEmitFile;\n        arguments: CompileOnSaveEmitFileRequestArgs;\n    }\n    /**\n     * Arguments for CompileOnSaveEmitFileRequest\n     */\n    interface CompileOnSaveEmitFileRequestArgs extends FileRequestArgs {\n        /**\n         * if true - then file should be recompiled even if it does not have any changes.\n         */\n        forced?: boolean;\n        includeLinePosition?: boolean;\n        /** if true - return response as object with emitSkipped and diagnostics */\n        richResponse?: boolean;\n    }\n    interface CompileOnSaveEmitFileResponse extends Response {\n        body: boolean | EmitResult;\n    }\n    interface EmitResult {\n        emitSkipped: boolean;\n        diagnostics: Diagnostic[] | DiagnosticWithLinePosition[];\n    }\n    /**\n     * Quickinfo request; value of command field is\n     * "quickinfo". Return response giving a quick type and\n     * documentation string for the symbol found in file at location\n     * line, col.\n     */\n    interface QuickInfoRequest extends FileLocationRequest {\n        command: CommandTypes.Quickinfo;\n    }\n    /**\n     * Body of QuickInfoResponse.\n     */\n    interface QuickInfoResponseBody {\n        /**\n         * The symbol\'s kind (such as \'className\' or \'parameterName\' or plain \'text\').\n         */\n        kind: ScriptElementKind;\n        /**\n         * Optional modifiers for the kind (such as \'public\').\n         */\n        kindModifiers: string;\n        /**\n         * Starting file location of symbol.\n         */\n        start: Location;\n        /**\n         * One past last character of symbol.\n         */\n        end: Location;\n        /**\n         * Type and kind of symbol.\n         */\n        displayString: string;\n        /**\n         * Documentation associated with symbol.\n         */\n        documentation: string;\n        /**\n         * JSDoc tags associated with symbol.\n         */\n        tags: JSDocTagInfo[];\n    }\n    /**\n     * Quickinfo response message.\n     */\n    interface QuickInfoResponse extends Response {\n        body?: QuickInfoResponseBody;\n    }\n    /**\n     * Arguments for format messages.\n     */\n    interface FormatRequestArgs extends FileLocationRequestArgs {\n        /**\n         * Last line of range for which to format text in file.\n         */\n        endLine: number;\n        /**\n         * Character offset on last line of range for which to format text in file.\n         */\n        endOffset: number;\n        /**\n         * Format options to be used.\n         */\n        options?: FormatCodeSettings;\n    }\n    /**\n     * Format request; value of command field is "format".  Return\n     * response giving zero or more edit instructions.  The edit\n     * instructions will be sorted in file order.  Applying the edit\n     * instructions in reverse to file will result in correctly\n     * reformatted text.\n     */\n    interface FormatRequest extends FileLocationRequest {\n        command: CommandTypes.Format;\n        arguments: FormatRequestArgs;\n    }\n    /**\n     * Object found in response messages defining an editing\n     * instruction for a span of text in source code.  The effect of\n     * this instruction is to replace the text starting at start and\n     * ending one character before end with newText. For an insertion,\n     * the text span is empty.  For a deletion, newText is empty.\n     */\n    interface CodeEdit {\n        /**\n         * First character of the text span to edit.\n         */\n        start: Location;\n        /**\n         * One character past last character of the text span to edit.\n         */\n        end: Location;\n        /**\n         * Replace the span defined above with this string (may be\n         * the empty string).\n         */\n        newText: string;\n    }\n    interface FileCodeEdits {\n        fileName: string;\n        textChanges: CodeEdit[];\n    }\n    interface CodeFixResponse extends Response {\n        /** The code actions that are available */\n        body?: CodeFixAction[];\n    }\n    interface CodeAction {\n        /** Description of the code action to display in the UI of the editor */\n        description: string;\n        /** Text changes to apply to each file as part of the code action */\n        changes: FileCodeEdits[];\n        /** A command is an opaque object that should be passed to `ApplyCodeActionCommandRequestArgs` without modification.  */\n        commands?: {}[];\n    }\n    interface CombinedCodeActions {\n        changes: readonly FileCodeEdits[];\n        commands?: readonly {}[];\n    }\n    interface CodeFixAction extends CodeAction {\n        /** Short name to identify the fix, for use by telemetry. */\n        fixName: string;\n        /**\n         * If present, one may call \'getCombinedCodeFix\' with this fixId.\n         * This may be omitted to indicate that the code fix can\'t be applied in a group.\n         */\n        fixId?: {};\n        /** Should be present if and only if \'fixId\' is. */\n        fixAllDescription?: string;\n    }\n    /**\n     * Format and format on key response message.\n     */\n    interface FormatResponse extends Response {\n        body?: CodeEdit[];\n    }\n    /**\n     * Arguments for format on key messages.\n     */\n    interface FormatOnKeyRequestArgs extends FileLocationRequestArgs {\n        /**\n         * Key pressed (\';\', \'\\n\', or \'}\').\n         */\n        key: string;\n        options?: FormatCodeSettings;\n    }\n    /**\n     * Format on key request; value of command field is\n     * "formatonkey". Given file location and key typed (as string),\n     * return response giving zero or more edit instructions.  The\n     * edit instructions will be sorted in file order.  Applying the\n     * edit instructions in reverse to file will result in correctly\n     * reformatted text.\n     */\n    interface FormatOnKeyRequest extends FileLocationRequest {\n        command: CommandTypes.Formatonkey;\n        arguments: FormatOnKeyRequestArgs;\n    }\n    type CompletionsTriggerCharacter = "." | \'"\' | "\'" | "`" | "/" | "@" | "<" | "#";\n    /**\n     * Arguments for completions messages.\n     */\n    interface CompletionsRequestArgs extends FileLocationRequestArgs {\n        /**\n         * Optional prefix to apply to possible completions.\n         */\n        prefix?: string;\n        /**\n         * Character that was responsible for triggering completion.\n         * Should be `undefined` if a user manually requested completion.\n         */\n        triggerCharacter?: CompletionsTriggerCharacter;\n        /**\n         * @deprecated Use UserPreferences.includeCompletionsForModuleExports\n         */\n        includeExternalModuleExports?: boolean;\n        /**\n         * @deprecated Use UserPreferences.includeCompletionsWithInsertText\n         */\n        includeInsertTextCompletions?: boolean;\n    }\n    /**\n     * Completions request; value of command field is "completions".\n     * Given a file location (file, line, col) and a prefix (which may\n     * be the empty string), return the possible completions that\n     * begin with prefix.\n     */\n    interface CompletionsRequest extends FileLocationRequest {\n        command: CommandTypes.Completions | CommandTypes.CompletionInfo;\n        arguments: CompletionsRequestArgs;\n    }\n    /**\n     * Arguments for completion details request.\n     */\n    interface CompletionDetailsRequestArgs extends FileLocationRequestArgs {\n        /**\n         * Names of one or more entries for which to obtain details.\n         */\n        entryNames: (string | CompletionEntryIdentifier)[];\n    }\n    interface CompletionEntryIdentifier {\n        name: string;\n        source?: string;\n    }\n    /**\n     * Completion entry details request; value of command field is\n     * "completionEntryDetails".  Given a file location (file, line,\n     * col) and an array of completion entry names return more\n     * detailed information for each completion entry.\n     */\n    interface CompletionDetailsRequest extends FileLocationRequest {\n        command: CommandTypes.CompletionDetails;\n        arguments: CompletionDetailsRequestArgs;\n    }\n    /**\n     * Part of a symbol description.\n     */\n    interface SymbolDisplayPart {\n        /**\n         * Text of an item describing the symbol.\n         */\n        text: string;\n        /**\n         * The symbol\'s kind (such as \'className\' or \'parameterName\' or plain \'text\').\n         */\n        kind: string;\n    }\n    /**\n     * An item found in a completion response.\n     */\n    interface CompletionEntry {\n        /**\n         * The symbol\'s name.\n         */\n        name: string;\n        /**\n         * The symbol\'s kind (such as \'className\' or \'parameterName\').\n         */\n        kind: ScriptElementKind;\n        /**\n         * Optional modifiers for the kind (such as \'public\').\n         */\n        kindModifiers?: string;\n        /**\n         * A string that is used for comparing completion items so that they can be ordered.  This\n         * is often the same as the name but may be different in certain circumstances.\n         */\n        sortText: string;\n        /**\n         * Text to insert instead of `name`.\n         * This is used to support bracketed completions; If `name` might be "a-b" but `insertText` would be `["a-b"]`,\n         * coupled with `replacementSpan` to replace a dotted access with a bracket access.\n         */\n        insertText?: string;\n        /**\n         * An optional span that indicates the text to be replaced by this completion item.\n         * If present, this span should be used instead of the default one.\n         * It will be set if the required span differs from the one generated by the default replacement behavior.\n         */\n        replacementSpan?: TextSpan;\n        /**\n         * Indicates whether commiting this completion entry will require additional code actions to be\n         * made to avoid errors. The CompletionEntryDetails will have these actions.\n         */\n        hasAction?: true;\n        /**\n         * Identifier (not necessarily human-readable) identifying where this completion came from.\n         */\n        source?: string;\n        /**\n         * If true, this completion should be highlighted as recommended. There will only be one of these.\n         * This will be set when we know the user should write an expression with a certain type and that type is an enum or constructable class.\n         * Then either that enum/class or a namespace containing it will be the recommended symbol.\n         */\n        isRecommended?: true;\n        /**\n         * If true, this completion was generated from traversing the name table of an unchecked JS file,\n         * and therefore may not be accurate.\n         */\n        isFromUncheckedFile?: true;\n    }\n    /**\n     * Additional completion entry details, available on demand\n     */\n    interface CompletionEntryDetails {\n        /**\n         * The symbol\'s name.\n         */\n        name: string;\n        /**\n         * The symbol\'s kind (such as \'className\' or \'parameterName\').\n         */\n        kind: ScriptElementKind;\n        /**\n         * Optional modifiers for the kind (such as \'public\').\n         */\n        kindModifiers: string;\n        /**\n         * Display parts of the symbol (similar to quick info).\n         */\n        displayParts: SymbolDisplayPart[];\n        /**\n         * Documentation strings for the symbol.\n         */\n        documentation?: SymbolDisplayPart[];\n        /**\n         * JSDoc tags for the symbol.\n         */\n        tags?: JSDocTagInfo[];\n        /**\n         * The associated code actions for this entry\n         */\n        codeActions?: CodeAction[];\n        /**\n         * Human-readable description of the `source` from the CompletionEntry.\n         */\n        source?: SymbolDisplayPart[];\n    }\n    /** @deprecated Prefer CompletionInfoResponse, which supports several top-level fields in addition to the array of entries. */\n    interface CompletionsResponse extends Response {\n        body?: CompletionEntry[];\n    }\n    interface CompletionInfoResponse extends Response {\n        body?: CompletionInfo;\n    }\n    interface CompletionInfo {\n        readonly isGlobalCompletion: boolean;\n        readonly isMemberCompletion: boolean;\n        readonly isNewIdentifierLocation: boolean;\n        readonly entries: readonly CompletionEntry[];\n    }\n    interface CompletionDetailsResponse extends Response {\n        body?: CompletionEntryDetails[];\n    }\n    /**\n     * Signature help information for a single parameter\n     */\n    interface SignatureHelpParameter {\n        /**\n         * The parameter\'s name\n         */\n        name: string;\n        /**\n         * Documentation of the parameter.\n         */\n        documentation: SymbolDisplayPart[];\n        /**\n         * Display parts of the parameter.\n         */\n        displayParts: SymbolDisplayPart[];\n        /**\n         * Whether the parameter is optional or not.\n         */\n        isOptional: boolean;\n    }\n    /**\n     * Represents a single signature to show in signature help.\n     */\n    interface SignatureHelpItem {\n        /**\n         * Whether the signature accepts a variable number of arguments.\n         */\n        isVariadic: boolean;\n        /**\n         * The prefix display parts.\n         */\n        prefixDisplayParts: SymbolDisplayPart[];\n        /**\n         * The suffix display parts.\n         */\n        suffixDisplayParts: SymbolDisplayPart[];\n        /**\n         * The separator display parts.\n         */\n        separatorDisplayParts: SymbolDisplayPart[];\n        /**\n         * The signature helps items for the parameters.\n         */\n        parameters: SignatureHelpParameter[];\n        /**\n         * The signature\'s documentation\n         */\n        documentation: SymbolDisplayPart[];\n        /**\n         * The signature\'s JSDoc tags\n         */\n        tags: JSDocTagInfo[];\n    }\n    /**\n     * Signature help items found in the response of a signature help request.\n     */\n    interface SignatureHelpItems {\n        /**\n         * The signature help items.\n         */\n        items: SignatureHelpItem[];\n        /**\n         * The span for which signature help should appear on a signature\n         */\n        applicableSpan: TextSpan;\n        /**\n         * The item selected in the set of available help items.\n         */\n        selectedItemIndex: number;\n        /**\n         * The argument selected in the set of parameters.\n         */\n        argumentIndex: number;\n        /**\n         * The argument count\n         */\n        argumentCount: number;\n    }\n    type SignatureHelpTriggerCharacter = "," | "(" | "<";\n    type SignatureHelpRetriggerCharacter = SignatureHelpTriggerCharacter | ")";\n    /**\n     * Arguments of a signature help request.\n     */\n    interface SignatureHelpRequestArgs extends FileLocationRequestArgs {\n        /**\n         * Reason why signature help was invoked.\n         * See each individual possible\n         */\n        triggerReason?: SignatureHelpTriggerReason;\n    }\n    type SignatureHelpTriggerReason = SignatureHelpInvokedReason | SignatureHelpCharacterTypedReason | SignatureHelpRetriggeredReason;\n    /**\n     * Signals that the user manually requested signature help.\n     * The language service will unconditionally attempt to provide a result.\n     */\n    interface SignatureHelpInvokedReason {\n        kind: "invoked";\n        triggerCharacter?: undefined;\n    }\n    /**\n     * Signals that the signature help request came from a user typing a character.\n     * Depending on the character and the syntactic context, the request may or may not be served a result.\n     */\n    interface SignatureHelpCharacterTypedReason {\n        kind: "characterTyped";\n        /**\n         * Character that was responsible for triggering signature help.\n         */\n        triggerCharacter: SignatureHelpTriggerCharacter;\n    }\n    /**\n     * Signals that this signature help request came from typing a character or moving the cursor.\n     * This should only occur if a signature help session was already active and the editor needs to see if it should adjust.\n     * The language service will unconditionally attempt to provide a result.\n     * `triggerCharacter` can be `undefined` for a retrigger caused by a cursor move.\n     */\n    interface SignatureHelpRetriggeredReason {\n        kind: "retrigger";\n        /**\n         * Character that was responsible for triggering signature help.\n         */\n        triggerCharacter?: SignatureHelpRetriggerCharacter;\n    }\n    /**\n     * Signature help request; value of command field is "signatureHelp".\n     * Given a file location (file, line, col), return the signature\n     * help.\n     */\n    interface SignatureHelpRequest extends FileLocationRequest {\n        command: CommandTypes.SignatureHelp;\n        arguments: SignatureHelpRequestArgs;\n    }\n    /**\n     * Response object for a SignatureHelpRequest.\n     */\n    interface SignatureHelpResponse extends Response {\n        body?: SignatureHelpItems;\n    }\n    /**\n     * Synchronous request for semantic diagnostics of one file.\n     */\n    interface SemanticDiagnosticsSyncRequest extends FileRequest {\n        command: CommandTypes.SemanticDiagnosticsSync;\n        arguments: SemanticDiagnosticsSyncRequestArgs;\n    }\n    interface SemanticDiagnosticsSyncRequestArgs extends FileRequestArgs {\n        includeLinePosition?: boolean;\n    }\n    /**\n     * Response object for synchronous sematic diagnostics request.\n     */\n    interface SemanticDiagnosticsSyncResponse extends Response {\n        body?: Diagnostic[] | DiagnosticWithLinePosition[];\n    }\n    interface SuggestionDiagnosticsSyncRequest extends FileRequest {\n        command: CommandTypes.SuggestionDiagnosticsSync;\n        arguments: SuggestionDiagnosticsSyncRequestArgs;\n    }\n    type SuggestionDiagnosticsSyncRequestArgs = SemanticDiagnosticsSyncRequestArgs;\n    type SuggestionDiagnosticsSyncResponse = SemanticDiagnosticsSyncResponse;\n    /**\n     * Synchronous request for syntactic diagnostics of one file.\n     */\n    interface SyntacticDiagnosticsSyncRequest extends FileRequest {\n        command: CommandTypes.SyntacticDiagnosticsSync;\n        arguments: SyntacticDiagnosticsSyncRequestArgs;\n    }\n    interface SyntacticDiagnosticsSyncRequestArgs extends FileRequestArgs {\n        includeLinePosition?: boolean;\n    }\n    /**\n     * Response object for synchronous syntactic diagnostics request.\n     */\n    interface SyntacticDiagnosticsSyncResponse extends Response {\n        body?: Diagnostic[] | DiagnosticWithLinePosition[];\n    }\n    /**\n     * Arguments for GeterrForProject request.\n     */\n    interface GeterrForProjectRequestArgs {\n        /**\n         * the file requesting project error list\n         */\n        file: string;\n        /**\n         * Delay in milliseconds to wait before starting to compute\n         * errors for the files in the file list\n         */\n        delay: number;\n    }\n    /**\n     * GeterrForProjectRequest request; value of command field is\n     * "geterrForProject". It works similarly with \'Geterr\', only\n     * it request for every file in this project.\n     */\n    interface GeterrForProjectRequest extends Request {\n        command: CommandTypes.GeterrForProject;\n        arguments: GeterrForProjectRequestArgs;\n    }\n    /**\n     * Arguments for geterr messages.\n     */\n    interface GeterrRequestArgs {\n        /**\n         * List of file names for which to compute compiler errors.\n         * The files will be checked in list order.\n         */\n        files: string[];\n        /**\n         * Delay in milliseconds to wait before starting to compute\n         * errors for the files in the file list\n         */\n        delay: number;\n    }\n    /**\n     * Geterr request; value of command field is "geterr". Wait for\n     * delay milliseconds and then, if during the wait no change or\n     * reload messages have arrived for the first file in the files\n     * list, get the syntactic errors for the file, field requests,\n     * and then get the semantic errors for the file.  Repeat with a\n     * smaller delay for each subsequent file on the files list.  Best\n     * practice for an editor is to send a file list containing each\n     * file that is currently visible, in most-recently-used order.\n     */\n    interface GeterrRequest extends Request {\n        command: CommandTypes.Geterr;\n        arguments: GeterrRequestArgs;\n    }\n    type RequestCompletedEventName = "requestCompleted";\n    /**\n     * Event that is sent when server have finished processing request with specified id.\n     */\n    interface RequestCompletedEvent extends Event {\n        event: RequestCompletedEventName;\n        body: RequestCompletedEventBody;\n    }\n    interface RequestCompletedEventBody {\n        request_seq: number;\n    }\n    /**\n     * Item of diagnostic information found in a DiagnosticEvent message.\n     */\n    interface Diagnostic {\n        /**\n         * Starting file location at which text applies.\n         */\n        start: Location;\n        /**\n         * The last file location at which the text applies.\n         */\n        end: Location;\n        /**\n         * Text of diagnostic message.\n         */\n        text: string;\n        /**\n         * The category of the diagnostic message, e.g. "error", "warning", or "suggestion".\n         */\n        category: string;\n        reportsUnnecessary?: {};\n        /**\n         * Any related spans the diagnostic may have, such as other locations relevant to an error, such as declarartion sites\n         */\n        relatedInformation?: DiagnosticRelatedInformation[];\n        /**\n         * The error code of the diagnostic message.\n         */\n        code?: number;\n        /**\n         * The name of the plugin reporting the message.\n         */\n        source?: string;\n    }\n    interface DiagnosticWithFileName extends Diagnostic {\n        /**\n         * Name of the file the diagnostic is in\n         */\n        fileName: string;\n    }\n    /**\n     * Represents additional spans returned with a diagnostic which are relevant to it\n     */\n    interface DiagnosticRelatedInformation {\n        /**\n         * The category of the related information message, e.g. "error", "warning", or "suggestion".\n         */\n        category: string;\n        /**\n         * The code used ot identify the related information\n         */\n        code: number;\n        /**\n         * Text of related or additional information.\n         */\n        message: string;\n        /**\n         * Associated location\n         */\n        span?: FileSpan;\n    }\n    interface DiagnosticEventBody {\n        /**\n         * The file for which diagnostic information is reported.\n         */\n        file: string;\n        /**\n         * An array of diagnostic information items.\n         */\n        diagnostics: Diagnostic[];\n    }\n    type DiagnosticEventKind = "semanticDiag" | "syntaxDiag" | "suggestionDiag";\n    /**\n     * Event message for DiagnosticEventKind event types.\n     * These events provide syntactic and semantic errors for a file.\n     */\n    interface DiagnosticEvent extends Event {\n        body?: DiagnosticEventBody;\n        event: DiagnosticEventKind;\n    }\n    interface ConfigFileDiagnosticEventBody {\n        /**\n         * The file which trigged the searching and error-checking of the config file\n         */\n        triggerFile: string;\n        /**\n         * The name of the found config file.\n         */\n        configFile: string;\n        /**\n         * An arry of diagnostic information items for the found config file.\n         */\n        diagnostics: DiagnosticWithFileName[];\n    }\n    /**\n     * Event message for "configFileDiag" event type.\n     * This event provides errors for a found config file.\n     */\n    interface ConfigFileDiagnosticEvent extends Event {\n        body?: ConfigFileDiagnosticEventBody;\n        event: "configFileDiag";\n    }\n    type ProjectLanguageServiceStateEventName = "projectLanguageServiceState";\n    interface ProjectLanguageServiceStateEvent extends Event {\n        event: ProjectLanguageServiceStateEventName;\n        body?: ProjectLanguageServiceStateEventBody;\n    }\n    interface ProjectLanguageServiceStateEventBody {\n        /**\n         * Project name that has changes in the state of language service.\n         * For configured projects this will be the config file path.\n         * For external projects this will be the name of the projects specified when project was open.\n         * For inferred projects this event is not raised.\n         */\n        projectName: string;\n        /**\n         * True if language service state switched from disabled to enabled\n         * and false otherwise.\n         */\n        languageServiceEnabled: boolean;\n    }\n    type ProjectsUpdatedInBackgroundEventName = "projectsUpdatedInBackground";\n    interface ProjectsUpdatedInBackgroundEvent extends Event {\n        event: ProjectsUpdatedInBackgroundEventName;\n        body: ProjectsUpdatedInBackgroundEventBody;\n    }\n    interface ProjectsUpdatedInBackgroundEventBody {\n        /**\n         * Current set of open files\n         */\n        openFiles: string[];\n    }\n    type ProjectLoadingStartEventName = "projectLoadingStart";\n    interface ProjectLoadingStartEvent extends Event {\n        event: ProjectLoadingStartEventName;\n        body: ProjectLoadingStartEventBody;\n    }\n    interface ProjectLoadingStartEventBody {\n        /** name of the project */\n        projectName: string;\n        /** reason for loading */\n        reason: string;\n    }\n    type ProjectLoadingFinishEventName = "projectLoadingFinish";\n    interface ProjectLoadingFinishEvent extends Event {\n        event: ProjectLoadingFinishEventName;\n        body: ProjectLoadingFinishEventBody;\n    }\n    interface ProjectLoadingFinishEventBody {\n        /** name of the project */\n        projectName: string;\n    }\n    type SurveyReadyEventName = "surveyReady";\n    interface SurveyReadyEvent extends Event {\n        event: SurveyReadyEventName;\n        body: SurveyReadyEventBody;\n    }\n    interface SurveyReadyEventBody {\n        /** Name of the survey. This is an internal machine- and programmer-friendly name */\n        surveyId: string;\n    }\n    type LargeFileReferencedEventName = "largeFileReferenced";\n    interface LargeFileReferencedEvent extends Event {\n        event: LargeFileReferencedEventName;\n        body: LargeFileReferencedEventBody;\n    }\n    interface LargeFileReferencedEventBody {\n        /**\n         * name of the large file being loaded\n         */\n        file: string;\n        /**\n         * size of the file\n         */\n        fileSize: number;\n        /**\n         * max file size allowed on the server\n         */\n        maxFileSize: number;\n    }\n    /**\n     * Arguments for reload request.\n     */\n    interface ReloadRequestArgs extends FileRequestArgs {\n        /**\n         * Name of temporary file from which to reload file\n         * contents. May be same as file.\n         */\n        tmpfile: string;\n    }\n    /**\n     * Reload request message; value of command field is "reload".\n     * Reload contents of file with name given by the \'file\' argument\n     * from temporary file with name given by the \'tmpfile\' argument.\n     * The two names can be identical.\n     */\n    interface ReloadRequest extends FileRequest {\n        command: CommandTypes.Reload;\n        arguments: ReloadRequestArgs;\n    }\n    /**\n     * Response to "reload" request. This is just an acknowledgement, so\n     * no body field is required.\n     */\n    interface ReloadResponse extends Response {\n    }\n    /**\n     * Arguments for saveto request.\n     */\n    interface SavetoRequestArgs extends FileRequestArgs {\n        /**\n         * Name of temporary file into which to save server\'s view of\n         * file contents.\n         */\n        tmpfile: string;\n    }\n    /**\n     * Saveto request message; value of command field is "saveto".\n     * For debugging purposes, save to a temporaryfile (named by\n     * argument \'tmpfile\') the contents of file named by argument\n     * \'file\'.  The server does not currently send a response to a\n     * "saveto" request.\n     */\n    interface SavetoRequest extends FileRequest {\n        command: CommandTypes.Saveto;\n        arguments: SavetoRequestArgs;\n    }\n    /**\n     * Arguments for navto request message.\n     */\n    interface NavtoRequestArgs {\n        /**\n         * Search term to navigate to from current location; term can\n         * be \'.*\' or an identifier prefix.\n         */\n        searchValue: string;\n        /**\n         *  Optional limit on the number of items to return.\n         */\n        maxResultCount?: number;\n        /**\n         * The file for the request (absolute pathname required).\n         */\n        file?: string;\n        /**\n         * Optional flag to indicate we want results for just the current file\n         * or the entire project.\n         */\n        currentFileOnly?: boolean;\n        projectFileName?: string;\n    }\n    /**\n     * Navto request message; value of command field is "navto".\n     * Return list of objects giving file locations and symbols that\n     * match the search term given in argument \'searchTerm\'.  The\n     * context for the search is given by the named file.\n     */\n    interface NavtoRequest extends Request {\n        command: CommandTypes.Navto;\n        arguments: NavtoRequestArgs;\n    }\n    /**\n     * An item found in a navto response.\n     */\n    interface NavtoItem extends FileSpan {\n        /**\n         * The symbol\'s name.\n         */\n        name: string;\n        /**\n         * The symbol\'s kind (such as \'className\' or \'parameterName\').\n         */\n        kind: ScriptElementKind;\n        /**\n         * exact, substring, or prefix.\n         */\n        matchKind: string;\n        /**\n         * If this was a case sensitive or insensitive match.\n         */\n        isCaseSensitive: boolean;\n        /**\n         * Optional modifiers for the kind (such as \'public\').\n         */\n        kindModifiers?: string;\n        /**\n         * Name of symbol\'s container symbol (if any); for example,\n         * the class name if symbol is a class member.\n         */\n        containerName?: string;\n        /**\n         * Kind of symbol\'s container symbol (if any).\n         */\n        containerKind?: ScriptElementKind;\n    }\n    /**\n     * Navto response message. Body is an array of navto items.  Each\n     * item gives a symbol that matched the search term.\n     */\n    interface NavtoResponse extends Response {\n        body?: NavtoItem[];\n    }\n    /**\n     * Arguments for change request message.\n     */\n    interface ChangeRequestArgs extends FormatRequestArgs {\n        /**\n         * Optional string to insert at location (file, line, offset).\n         */\n        insertString?: string;\n    }\n    /**\n     * Change request message; value of command field is "change".\n     * Update the server\'s view of the file named by argument \'file\'.\n     * Server does not currently send a response to a change request.\n     */\n    interface ChangeRequest extends FileLocationRequest {\n        command: CommandTypes.Change;\n        arguments: ChangeRequestArgs;\n    }\n    /**\n     * Response to "brace" request.\n     */\n    interface BraceResponse extends Response {\n        body?: TextSpan[];\n    }\n    /**\n     * Brace matching request; value of command field is "brace".\n     * Return response giving the file locations of matching braces\n     * found in file at location line, offset.\n     */\n    interface BraceRequest extends FileLocationRequest {\n        command: CommandTypes.Brace;\n    }\n    /**\n     * NavBar items request; value of command field is "navbar".\n     * Return response giving the list of navigation bar entries\n     * extracted from the requested file.\n     */\n    interface NavBarRequest extends FileRequest {\n        command: CommandTypes.NavBar;\n    }\n    /**\n     * NavTree request; value of command field is "navtree".\n     * Return response giving the navigation tree of the requested file.\n     */\n    interface NavTreeRequest extends FileRequest {\n        command: CommandTypes.NavTree;\n    }\n    interface NavigationBarItem {\n        /**\n         * The item\'s display text.\n         */\n        text: string;\n        /**\n         * The symbol\'s kind (such as \'className\' or \'parameterName\').\n         */\n        kind: ScriptElementKind;\n        /**\n         * Optional modifiers for the kind (such as \'public\').\n         */\n        kindModifiers?: string;\n        /**\n         * The definition locations of the item.\n         */\n        spans: TextSpan[];\n        /**\n         * Optional children.\n         */\n        childItems?: NavigationBarItem[];\n        /**\n         * Number of levels deep this item should appear.\n         */\n        indent: number;\n    }\n    /** protocol.NavigationTree is identical to ts.NavigationTree, except using protocol.TextSpan instead of ts.TextSpan */\n    interface NavigationTree {\n        text: string;\n        kind: ScriptElementKind;\n        kindModifiers: string;\n        spans: TextSpan[];\n        nameSpan: TextSpan | undefined;\n        childItems?: NavigationTree[];\n    }\n    type TelemetryEventName = "telemetry";\n    interface TelemetryEvent extends Event {\n        event: TelemetryEventName;\n        body: TelemetryEventBody;\n    }\n    interface TelemetryEventBody {\n        telemetryEventName: string;\n        payload: any;\n    }\n    type TypesInstallerInitializationFailedEventName = "typesInstallerInitializationFailed";\n    interface TypesInstallerInitializationFailedEvent extends Event {\n        event: TypesInstallerInitializationFailedEventName;\n        body: TypesInstallerInitializationFailedEventBody;\n    }\n    interface TypesInstallerInitializationFailedEventBody {\n        message: string;\n    }\n    type TypingsInstalledTelemetryEventName = "typingsInstalled";\n    interface TypingsInstalledTelemetryEventBody extends TelemetryEventBody {\n        telemetryEventName: TypingsInstalledTelemetryEventName;\n        payload: TypingsInstalledTelemetryEventPayload;\n    }\n    interface TypingsInstalledTelemetryEventPayload {\n        /**\n         * Comma separated list of installed typing packages\n         */\n        installedPackages: string;\n        /**\n         * true if install request succeeded, otherwise - false\n         */\n        installSuccess: boolean;\n        /**\n         * version of typings installer\n         */\n        typingsInstallerVersion: string;\n    }\n    type BeginInstallTypesEventName = "beginInstallTypes";\n    type EndInstallTypesEventName = "endInstallTypes";\n    interface BeginInstallTypesEvent extends Event {\n        event: BeginInstallTypesEventName;\n        body: BeginInstallTypesEventBody;\n    }\n    interface EndInstallTypesEvent extends Event {\n        event: EndInstallTypesEventName;\n        body: EndInstallTypesEventBody;\n    }\n    interface InstallTypesEventBody {\n        /**\n         * correlation id to match begin and end events\n         */\n        eventId: number;\n        /**\n         * list of packages to install\n         */\n        packages: readonly string[];\n    }\n    interface BeginInstallTypesEventBody extends InstallTypesEventBody {\n    }\n    interface EndInstallTypesEventBody extends InstallTypesEventBody {\n        /**\n         * true if installation succeeded, otherwise false\n         */\n        success: boolean;\n    }\n    interface NavBarResponse extends Response {\n        body?: NavigationBarItem[];\n    }\n    interface NavTreeResponse extends Response {\n        body?: NavigationTree;\n    }\n    interface CallHierarchyItem {\n        name: string;\n        kind: ScriptElementKind;\n        file: string;\n        span: TextSpan;\n        selectionSpan: TextSpan;\n    }\n    interface CallHierarchyIncomingCall {\n        from: CallHierarchyItem;\n        fromSpans: TextSpan[];\n    }\n    interface CallHierarchyOutgoingCall {\n        to: CallHierarchyItem;\n        fromSpans: TextSpan[];\n    }\n    interface PrepareCallHierarchyRequest extends FileLocationRequest {\n        command: CommandTypes.PrepareCallHierarchy;\n    }\n    interface PrepareCallHierarchyResponse extends Response {\n        readonly body: CallHierarchyItem | CallHierarchyItem[];\n    }\n    interface ProvideCallHierarchyIncomingCallsRequest extends FileLocationRequest {\n        command: CommandTypes.ProvideCallHierarchyIncomingCalls;\n    }\n    interface ProvideCallHierarchyIncomingCallsResponse extends Response {\n        readonly body: CallHierarchyIncomingCall[];\n    }\n    interface ProvideCallHierarchyOutgoingCallsRequest extends FileLocationRequest {\n        command: CommandTypes.ProvideCallHierarchyOutgoingCalls;\n    }\n    interface ProvideCallHierarchyOutgoingCallsResponse extends Response {\n        readonly body: CallHierarchyOutgoingCall[];\n    }\n    enum IndentStyle {\n        None = "None",\n        Block = "Block",\n        Smart = "Smart"\n    }\n    enum SemicolonPreference {\n        Ignore = "ignore",\n        Insert = "insert",\n        Remove = "remove"\n    }\n    interface EditorSettings {\n        baseIndentSize?: number;\n        indentSize?: number;\n        tabSize?: number;\n        newLineCharacter?: string;\n        convertTabsToSpaces?: boolean;\n        indentStyle?: IndentStyle | ts.IndentStyle;\n        trimTrailingWhitespace?: boolean;\n    }\n    interface FormatCodeSettings extends EditorSettings {\n        insertSpaceAfterCommaDelimiter?: boolean;\n        insertSpaceAfterSemicolonInForStatements?: boolean;\n        insertSpaceBeforeAndAfterBinaryOperators?: boolean;\n        insertSpaceAfterConstructor?: boolean;\n        insertSpaceAfterKeywordsInControlFlowStatements?: boolean;\n        insertSpaceAfterFunctionKeywordForAnonymousFunctions?: boolean;\n        insertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis?: boolean;\n        insertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets?: boolean;\n        insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces?: boolean;\n        insertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces?: boolean;\n        insertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces?: boolean;\n        insertSpaceAfterTypeAssertion?: boolean;\n        insertSpaceBeforeFunctionParenthesis?: boolean;\n        placeOpenBraceOnNewLineForFunctions?: boolean;\n        placeOpenBraceOnNewLineForControlBlocks?: boolean;\n        insertSpaceBeforeTypeAnnotation?: boolean;\n        semicolons?: SemicolonPreference;\n    }\n    interface UserPreferences {\n        readonly disableSuggestions?: boolean;\n        readonly quotePreference?: "auto" | "double" | "single";\n        /**\n         * If enabled, TypeScript will search through all external modules\' exports and add them to the completions list.\n         * This affects lone identifier completions but not completions on the right hand side of `obj.`.\n         */\n        readonly includeCompletionsForModuleExports?: boolean;\n        /**\n         * If enabled, the completion list will include completions with invalid identifier names.\n         * For those entries, The `insertText` and `replacementSpan` properties will be set to change from `.x` property access to `["x"]`.\n         */\n        readonly includeCompletionsWithInsertText?: boolean;\n        /**\n         * Unless this option is `false`, or `includeCompletionsWithInsertText` is not enabled,\n         * member completion lists triggered with `.` will include entries on potentially-null and potentially-undefined\n         * values, with insertion text to replace preceding `.` tokens with `?.`.\n         */\n        readonly includeAutomaticOptionalChainCompletions?: boolean;\n        readonly importModuleSpecifierPreference?: "auto" | "relative" | "non-relative";\n        /** Determines whether we import `foo/index.ts` as "foo", "foo/index", or "foo/index.js" */\n        readonly importModuleSpecifierEnding?: "auto" | "minimal" | "index" | "js";\n        readonly allowTextChangesInNewFiles?: boolean;\n        readonly lazyConfiguredProjectsFromExternalProject?: boolean;\n        readonly providePrefixAndSuffixTextForRename?: boolean;\n        readonly allowRenameOfImportPath?: boolean;\n    }\n    interface CompilerOptions {\n        allowJs?: boolean;\n        allowSyntheticDefaultImports?: boolean;\n        allowUnreachableCode?: boolean;\n        allowUnusedLabels?: boolean;\n        alwaysStrict?: boolean;\n        baseUrl?: string;\n        charset?: string;\n        checkJs?: boolean;\n        declaration?: boolean;\n        declarationDir?: string;\n        disableSizeLimit?: boolean;\n        downlevelIteration?: boolean;\n        emitBOM?: boolean;\n        emitDecoratorMetadata?: boolean;\n        experimentalDecorators?: boolean;\n        forceConsistentCasingInFileNames?: boolean;\n        importHelpers?: boolean;\n        inlineSourceMap?: boolean;\n        inlineSources?: boolean;\n        isolatedModules?: boolean;\n        jsx?: JsxEmit | ts.JsxEmit;\n        lib?: string[];\n        locale?: string;\n        mapRoot?: string;\n        maxNodeModuleJsDepth?: number;\n        module?: ModuleKind | ts.ModuleKind;\n        moduleResolution?: ModuleResolutionKind | ts.ModuleResolutionKind;\n        newLine?: NewLineKind | ts.NewLineKind;\n        noEmit?: boolean;\n        noEmitHelpers?: boolean;\n        noEmitOnError?: boolean;\n        noErrorTruncation?: boolean;\n        noFallthroughCasesInSwitch?: boolean;\n        noImplicitAny?: boolean;\n        noImplicitReturns?: boolean;\n        noImplicitThis?: boolean;\n        noUnusedLocals?: boolean;\n        noUnusedParameters?: boolean;\n        noImplicitUseStrict?: boolean;\n        noLib?: boolean;\n        noResolve?: boolean;\n        out?: string;\n        outDir?: string;\n        outFile?: string;\n        paths?: MapLike<string[]>;\n        plugins?: PluginImport[];\n        preserveConstEnums?: boolean;\n        preserveSymlinks?: boolean;\n        project?: string;\n        reactNamespace?: string;\n        removeComments?: boolean;\n        references?: ProjectReference[];\n        rootDir?: string;\n        rootDirs?: string[];\n        skipLibCheck?: boolean;\n        skipDefaultLibCheck?: boolean;\n        sourceMap?: boolean;\n        sourceRoot?: string;\n        strict?: boolean;\n        strictNullChecks?: boolean;\n        suppressExcessPropertyErrors?: boolean;\n        suppressImplicitAnyIndexErrors?: boolean;\n        useDefineForClassFields?: boolean;\n        target?: ScriptTarget | ts.ScriptTarget;\n        traceResolution?: boolean;\n        resolveJsonModule?: boolean;\n        types?: string[];\n        /** Paths used to used to compute primary types search locations */\n        typeRoots?: string[];\n        [option: string]: CompilerOptionsValue | undefined;\n    }\n    enum JsxEmit {\n        None = "None",\n        Preserve = "Preserve",\n        ReactNative = "ReactNative",\n        React = "React"\n    }\n    enum ModuleKind {\n        None = "None",\n        CommonJS = "CommonJS",\n        AMD = "AMD",\n        UMD = "UMD",\n        System = "System",\n        ES6 = "ES6",\n        ES2015 = "ES2015",\n        ESNext = "ESNext"\n    }\n    enum ModuleResolutionKind {\n        Classic = "Classic",\n        Node = "Node"\n    }\n    enum NewLineKind {\n        Crlf = "Crlf",\n        Lf = "Lf"\n    }\n    enum ScriptTarget {\n        ES3 = "ES3",\n        ES5 = "ES5",\n        ES6 = "ES6",\n        ES2015 = "ES2015",\n        ES2016 = "ES2016",\n        ES2017 = "ES2017",\n        ES2018 = "ES2018",\n        ES2019 = "ES2019",\n        ES2020 = "ES2020",\n        ESNext = "ESNext"\n    }\n}\ndeclare namespace ts.server {\n    interface ScriptInfoVersion {\n        svc: number;\n        text: number;\n    }\n    class ScriptInfo {\n        private readonly host;\n        readonly fileName: NormalizedPath;\n        readonly scriptKind: ScriptKind;\n        readonly hasMixedContent: boolean;\n        readonly path: Path;\n        /**\n         * All projects that include this file\n         */\n        readonly containingProjects: Project[];\n        private formatSettings;\n        private preferences;\n        private textStorage;\n        constructor(host: ServerHost, fileName: NormalizedPath, scriptKind: ScriptKind, hasMixedContent: boolean, path: Path, initialVersion?: ScriptInfoVersion);\n        isScriptOpen(): boolean;\n        open(newText: string): void;\n        close(fileExists?: boolean): void;\n        getSnapshot(): IScriptSnapshot;\n        private ensureRealPath;\n        getFormatCodeSettings(): FormatCodeSettings | undefined;\n        getPreferences(): protocol.UserPreferences | undefined;\n        attachToProject(project: Project): boolean;\n        isAttached(project: Project): boolean;\n        detachFromProject(project: Project): void;\n        detachAllProjects(): void;\n        getDefaultProject(): Project;\n        registerFileUpdate(): void;\n        setOptions(formatSettings: FormatCodeSettings, preferences: protocol.UserPreferences | undefined): void;\n        getLatestVersion(): string;\n        saveTo(fileName: string): void;\n        reloadFromFile(tempFileName?: NormalizedPath): boolean;\n        editContent(start: number, end: number, newText: string): void;\n        markContainingProjectsAsDirty(): void;\n        isOrphan(): boolean;\n        /**\n         *  @param line 1 based index\n         */\n        lineToTextSpan(line: number): TextSpan;\n        /**\n         * @param line 1 based index\n         * @param offset 1 based index\n         */\n        lineOffsetToPosition(line: number, offset: number): number;\n        positionToLineOffset(position: number): protocol.Location;\n        isJavaScript(): boolean;\n    }\n}\ndeclare namespace ts.server {\n    interface InstallPackageOptionsWithProject extends InstallPackageOptions {\n        projectName: string;\n        projectRootPath: Path;\n    }\n    interface ITypingsInstaller {\n        isKnownTypesPackageName(name: string): boolean;\n        installPackage(options: InstallPackageOptionsWithProject): Promise<ApplyCodeActionCommandResult>;\n        enqueueInstallTypingsRequest(p: Project, typeAcquisition: TypeAcquisition, unresolvedImports: SortedReadonlyArray<string> | undefined): void;\n        attach(projectService: ProjectService): void;\n        onProjectClosed(p: Project): void;\n        readonly globalTypingsCacheLocation: string | undefined;\n    }\n    const nullTypingsInstaller: ITypingsInstaller;\n}\ndeclare namespace ts.server {\n    enum ProjectKind {\n        Inferred = 0,\n        Configured = 1,\n        External = 2\n    }\n    function allRootFilesAreJsOrDts(project: Project): boolean;\n    function allFilesAreJsOrDts(project: Project): boolean;\n    interface PluginCreateInfo {\n        project: Project;\n        languageService: LanguageService;\n        languageServiceHost: LanguageServiceHost;\n        serverHost: ServerHost;\n        config: any;\n    }\n    interface PluginModule {\n        create(createInfo: PluginCreateInfo): LanguageService;\n        getExternalFiles?(proj: Project): string[];\n        onConfigurationChanged?(config: any): void;\n    }\n    interface PluginModuleWithName {\n        name: string;\n        module: PluginModule;\n    }\n    type PluginModuleFactory = (mod: {\n        typescript: typeof ts;\n    }) => PluginModule;\n    abstract class Project implements LanguageServiceHost, ModuleResolutionHost {\n        readonly projectName: string;\n        readonly projectKind: ProjectKind;\n        readonly projectService: ProjectService;\n        private documentRegistry;\n        private compilerOptions;\n        compileOnSaveEnabled: boolean;\n        protected watchOptions: WatchOptions | undefined;\n        private rootFiles;\n        private rootFilesMap;\n        private program;\n        private externalFiles;\n        private missingFilesMap;\n        private generatedFilesMap;\n        private plugins;\n        private lastFileExceededProgramSize;\n        protected languageService: LanguageService;\n        languageServiceEnabled: boolean;\n        readonly trace?: (s: string) => void;\n        readonly realpath?: (path: string) => string;\n        private builderState;\n        /**\n         * Set of files names that were updated since the last call to getChangesSinceVersion.\n         */\n        private updatedFileNames;\n        /**\n         * Set of files that was returned from the last call to getChangesSinceVersion.\n         */\n        private lastReportedFileNames;\n        /**\n         * Last version that was reported.\n         */\n        private lastReportedVersion;\n        /**\n         * Current project\'s program version. (incremented everytime new program is created that is not complete reuse from the old one)\n         * This property is changed in \'updateGraph\' based on the set of files in program\n         */\n        private projectProgramVersion;\n        /**\n         * Current version of the project state. It is changed when:\n         * - new root file was added/removed\n         * - edit happen in some file that is currently included in the project.\n         * This property is different from projectStructureVersion since in most cases edits don\'t affect set of files in the project\n         */\n        private projectStateVersion;\n        protected isInitialLoadPending: () => boolean;\n        private readonly cancellationToken;\n        isNonTsProject(): boolean;\n        isJsOnlyProject(): boolean;\n        static resolveModule(moduleName: string, initialDir: string, host: ServerHost, log: (message: string) => void, logErrors?: (message: string) => void): {} | undefined;\n        isKnownTypesPackageName(name: string): boolean;\n        installPackage(options: InstallPackageOptions): Promise<ApplyCodeActionCommandResult>;\n        private get typingsCache();\n        getCompilationSettings(): CompilerOptions;\n        getCompilerOptions(): CompilerOptions;\n        getNewLine(): string;\n        getProjectVersion(): string;\n        getProjectReferences(): readonly ProjectReference[] | undefined;\n        getScriptFileNames(): string[];\n        private getOrCreateScriptInfoAndAttachToProject;\n        getScriptKind(fileName: string): ScriptKind;\n        getScriptVersion(filename: string): string;\n        getScriptSnapshot(filename: string): IScriptSnapshot | undefined;\n        getCancellationToken(): HostCancellationToken;\n        getCurrentDirectory(): string;\n        getDefaultLibFileName(): string;\n        useCaseSensitiveFileNames(): boolean;\n        readDirectory(path: string, extensions?: readonly string[], exclude?: readonly string[], include?: readonly string[], depth?: number): string[];\n        readFile(fileName: string): string | undefined;\n        writeFile(fileName: string, content: string): void;\n        fileExists(file: string): boolean;\n        resolveModuleNames(moduleNames: string[], containingFile: string, reusedNames?: string[], redirectedReference?: ResolvedProjectReference): (ResolvedModuleFull | undefined)[];\n        getResolvedModuleWithFailedLookupLocationsFromCache(moduleName: string, containingFile: string): ResolvedModuleWithFailedLookupLocations | undefined;\n        resolveTypeReferenceDirectives(typeDirectiveNames: string[], containingFile: string, redirectedReference?: ResolvedProjectReference): (ResolvedTypeReferenceDirective | undefined)[];\n        directoryExists(path: string): boolean;\n        getDirectories(path: string): string[];\n        log(s: string): void;\n        error(s: string): void;\n        private setInternalCompilerOptionsForEmittingJsFiles;\n        /**\n         * Get the errors that dont have any file name associated\n         */\n        getGlobalProjectErrors(): readonly Diagnostic[];\n        getAllProjectErrors(): readonly Diagnostic[];\n        getLanguageService(ensureSynchronized?: boolean): LanguageService;\n        getCompileOnSaveAffectedFileList(scriptInfo: ScriptInfo): string[];\n        /**\n         * Returns true if emit was conducted\n         */\n        emitFile(scriptInfo: ScriptInfo, writeFile: (path: string, data: string, writeByteOrderMark?: boolean) => void): EmitResult;\n        enableLanguageService(): void;\n        disableLanguageService(lastFileExceededProgramSize?: string): void;\n        getProjectName(): string;\n        abstract getTypeAcquisition(): TypeAcquisition;\n        protected removeLocalTypingsFromTypeAcquisition(newTypeAcquisition: TypeAcquisition): TypeAcquisition;\n        getExternalFiles(): SortedReadonlyArray<string>;\n        getSourceFile(path: Path): SourceFile | undefined;\n        close(): void;\n        private detachScriptInfoIfNotRoot;\n        isClosed(): boolean;\n        hasRoots(): boolean;\n        getRootFiles(): NormalizedPath[];\n        getRootScriptInfos(): ScriptInfo[];\n        getScriptInfos(): ScriptInfo[];\n        getExcludedFiles(): readonly NormalizedPath[];\n        getFileNames(excludeFilesFromExternalLibraries?: boolean, excludeConfigFiles?: boolean): NormalizedPath[];\n        hasConfigFile(configFilePath: NormalizedPath): boolean;\n        containsScriptInfo(info: ScriptInfo): boolean;\n        containsFile(filename: NormalizedPath, requireOpen?: boolean): boolean;\n        isRoot(info: ScriptInfo): boolean;\n        addRoot(info: ScriptInfo, fileName?: NormalizedPath): void;\n        addMissingFileRoot(fileName: NormalizedPath): void;\n        removeFile(info: ScriptInfo, fileExists: boolean, detachFromProject: boolean): void;\n        registerFileUpdate(fileName: string): void;\n        markAsDirty(): void;\n        /**\n         * Updates set of files that contribute to this project\n         * @returns: true if set of files in the project stays the same and false - otherwise.\n         */\n        updateGraph(): boolean;\n        protected removeExistingTypings(include: string[]): string[];\n        private updateGraphWorker;\n        private detachScriptInfoFromProject;\n        private addMissingFileWatcher;\n        private isWatchedMissingFile;\n        private createGeneratedFileWatcher;\n        private isValidGeneratedFileWatcher;\n        private clearGeneratedFileWatch;\n        getScriptInfoForNormalizedPath(fileName: NormalizedPath): ScriptInfo | undefined;\n        getScriptInfo(uncheckedFileName: string): ScriptInfo | undefined;\n        filesToString(writeProjectFileNames: boolean): string;\n        setCompilerOptions(compilerOptions: CompilerOptions): void;\n        protected removeRoot(info: ScriptInfo): void;\n        protected enableGlobalPlugins(options: CompilerOptions, pluginConfigOverrides: Map<any> | undefined): void;\n        protected enablePlugin(pluginConfigEntry: PluginImport, searchPaths: string[], pluginConfigOverrides: Map<any> | undefined): void;\n        private enableProxy;\n        /** Starts a new check for diagnostics. Call this if some file has updated that would cause diagnostics to be changed. */\n        refreshDiagnostics(): void;\n        private watchPackageJsonFile;\n    }\n    /**\n     * If a file is opened and no tsconfig (or jsconfig) is found,\n     * the file and its imports/references are put into an InferredProject.\n     */\n    class InferredProject extends Project {\n        private static readonly newName;\n        private _isJsInferredProject;\n        toggleJsInferredProject(isJsInferredProject: boolean): void;\n        setCompilerOptions(options?: CompilerOptions): void;\n        /** this is canonical project root path */\n        readonly projectRootPath: string | undefined;\n        addRoot(info: ScriptInfo): void;\n        removeRoot(info: ScriptInfo): void;\n        isProjectWithSingleRoot(): boolean;\n        close(): void;\n        getTypeAcquisition(): TypeAcquisition;\n    }\n    /**\n     * If a file is opened, the server will look for a tsconfig (or jsconfig)\n     * and if successful create a ConfiguredProject for it.\n     * Otherwise it will create an InferredProject.\n     */\n    class ConfiguredProject extends Project {\n        private typeAcquisition;\n        private directoriesWatchedForWildcards;\n        readonly canonicalConfigFilePath: NormalizedPath;\n        /** Ref count to the project when opened from external project */\n        private externalProjectRefCount;\n        private projectErrors;\n        private projectReferences;\n        /**\n         * If the project has reload from disk pending, it reloads (and then updates graph as part of that) instead of just updating the graph\n         * @returns: true if set of files in the project stays the same and false - otherwise.\n         */\n        updateGraph(): boolean;\n        getConfigFilePath(): NormalizedPath;\n        getProjectReferences(): readonly ProjectReference[] | undefined;\n        updateReferences(refs: readonly ProjectReference[] | undefined): void;\n        /**\n         * Get the errors that dont have any file name associated\n         */\n        getGlobalProjectErrors(): readonly Diagnostic[];\n        /**\n         * Get all the project errors\n         */\n        getAllProjectErrors(): readonly Diagnostic[];\n        setProjectErrors(projectErrors: Diagnostic[]): void;\n        setTypeAcquisition(newTypeAcquisition: TypeAcquisition): void;\n        getTypeAcquisition(): TypeAcquisition;\n        close(): void;\n        getEffectiveTypeRoots(): string[];\n    }\n    /**\n     * Project whose configuration is handled externally, such as in a \'.csproj\'.\n     * These are created only if a host explicitly calls `openExternalProject`.\n     */\n    class ExternalProject extends Project {\n        externalProjectName: string;\n        compileOnSaveEnabled: boolean;\n        excludedFiles: readonly NormalizedPath[];\n        private typeAcquisition;\n        updateGraph(): boolean;\n        getExcludedFiles(): readonly NormalizedPath[];\n        getTypeAcquisition(): TypeAcquisition;\n        setTypeAcquisition(newTypeAcquisition: TypeAcquisition): void;\n    }\n}\ndeclare namespace ts.server {\n    export const maxProgramSizeForNonTsFiles: number;\n    export const ProjectsUpdatedInBackgroundEvent = "projectsUpdatedInBackground";\n    export const ProjectLoadingStartEvent = "projectLoadingStart";\n    export const ProjectLoadingFinishEvent = "projectLoadingFinish";\n    export const LargeFileReferencedEvent = "largeFileReferenced";\n    export const ConfigFileDiagEvent = "configFileDiag";\n    export const ProjectLanguageServiceStateEvent = "projectLanguageServiceState";\n    export const ProjectInfoTelemetryEvent = "projectInfo";\n    export const OpenFileInfoTelemetryEvent = "openFileInfo";\n    export interface ProjectsUpdatedInBackgroundEvent {\n        eventName: typeof ProjectsUpdatedInBackgroundEvent;\n        data: {\n            openFiles: string[];\n        };\n    }\n    export interface ProjectLoadingStartEvent {\n        eventName: typeof ProjectLoadingStartEvent;\n        data: {\n            project: Project;\n            reason: string;\n        };\n    }\n    export interface ProjectLoadingFinishEvent {\n        eventName: typeof ProjectLoadingFinishEvent;\n        data: {\n            project: Project;\n        };\n    }\n    export interface LargeFileReferencedEvent {\n        eventName: typeof LargeFileReferencedEvent;\n        data: {\n            file: string;\n            fileSize: number;\n            maxFileSize: number;\n        };\n    }\n    export interface ConfigFileDiagEvent {\n        eventName: typeof ConfigFileDiagEvent;\n        data: {\n            triggerFile: string;\n            configFileName: string;\n            diagnostics: readonly Diagnostic[];\n        };\n    }\n    export interface ProjectLanguageServiceStateEvent {\n        eventName: typeof ProjectLanguageServiceStateEvent;\n        data: {\n            project: Project;\n            languageServiceEnabled: boolean;\n        };\n    }\n    /** This will be converted to the payload of a protocol.TelemetryEvent in session.defaultEventHandler. */\n    export interface ProjectInfoTelemetryEvent {\n        readonly eventName: typeof ProjectInfoTelemetryEvent;\n        readonly data: ProjectInfoTelemetryEventData;\n    }\n    export interface ProjectInfoTelemetryEventData {\n        /** Cryptographically secure hash of project file location. */\n        readonly projectId: string;\n        /** Count of file extensions seen in the project. */\n        readonly fileStats: FileStats;\n        /**\n         * Any compiler options that might contain paths will be taken out.\n         * Enum compiler options will be converted to strings.\n         */\n        readonly compilerOptions: CompilerOptions;\n        readonly extends: boolean | undefined;\n        readonly files: boolean | undefined;\n        readonly include: boolean | undefined;\n        readonly exclude: boolean | undefined;\n        readonly compileOnSave: boolean;\n        readonly typeAcquisition: ProjectInfoTypeAcquisitionData;\n        readonly configFileName: "tsconfig.json" | "jsconfig.json" | "other";\n        readonly projectType: "external" | "configured";\n        readonly languageServiceEnabled: boolean;\n        /** TypeScript version used by the server. */\n        readonly version: string;\n    }\n    /**\n     * Info that we may send about a file that was just opened.\n     * Info about a file will only be sent once per session, even if the file changes in ways that might affect the info.\n     * Currently this is only sent for \'.js\' files.\n     */\n    export interface OpenFileInfoTelemetryEvent {\n        readonly eventName: typeof OpenFileInfoTelemetryEvent;\n        readonly data: OpenFileInfoTelemetryEventData;\n    }\n    export interface OpenFileInfoTelemetryEventData {\n        readonly info: OpenFileInfo;\n    }\n    export interface ProjectInfoTypeAcquisitionData {\n        readonly enable: boolean | undefined;\n        readonly include: boolean;\n        readonly exclude: boolean;\n    }\n    export interface FileStats {\n        readonly js: number;\n        readonly jsSize?: number;\n        readonly jsx: number;\n        readonly jsxSize?: number;\n        readonly ts: number;\n        readonly tsSize?: number;\n        readonly tsx: number;\n        readonly tsxSize?: number;\n        readonly dts: number;\n        readonly dtsSize?: number;\n        readonly deferred: number;\n        readonly deferredSize?: number;\n    }\n    export interface OpenFileInfo {\n        readonly checkJs: boolean;\n    }\n    export type ProjectServiceEvent = LargeFileReferencedEvent | ProjectsUpdatedInBackgroundEvent | ProjectLoadingStartEvent | ProjectLoadingFinishEvent | ConfigFileDiagEvent | ProjectLanguageServiceStateEvent | ProjectInfoTelemetryEvent | OpenFileInfoTelemetryEvent;\n    export type ProjectServiceEventHandler = (event: ProjectServiceEvent) => void;\n    export interface SafeList {\n        [name: string]: {\n            match: RegExp;\n            exclude?: (string | number)[][];\n            types?: string[];\n        };\n    }\n    export interface TypesMapFile {\n        typesMap: SafeList;\n        simpleMap: {\n            [libName: string]: string;\n        };\n    }\n    export function convertFormatOptions(protocolOptions: protocol.FormatCodeSettings): FormatCodeSettings;\n    export function convertCompilerOptions(protocolOptions: protocol.ExternalProjectCompilerOptions): CompilerOptions & protocol.CompileOnSaveMixin;\n    export function convertWatchOptions(protocolOptions: protocol.ExternalProjectCompilerOptions): WatchOptions | undefined;\n    export function tryConvertScriptKindName(scriptKindName: protocol.ScriptKindName | ScriptKind): ScriptKind;\n    export function convertScriptKindName(scriptKindName: protocol.ScriptKindName): ScriptKind.Unknown | ScriptKind.JS | ScriptKind.JSX | ScriptKind.TS | ScriptKind.TSX;\n    export interface HostConfiguration {\n        formatCodeOptions: FormatCodeSettings;\n        preferences: protocol.UserPreferences;\n        hostInfo: string;\n        extraFileExtensions?: FileExtensionInfo[];\n        watchOptions?: WatchOptions;\n    }\n    export interface OpenConfiguredProjectResult {\n        configFileName?: NormalizedPath;\n        configFileErrors?: readonly Diagnostic[];\n    }\n    export interface ProjectServiceOptions {\n        host: ServerHost;\n        logger: Logger;\n        cancellationToken: HostCancellationToken;\n        useSingleInferredProject: boolean;\n        useInferredProjectPerProjectRoot: boolean;\n        typingsInstaller: ITypingsInstaller;\n        eventHandler?: ProjectServiceEventHandler;\n        suppressDiagnosticEvents?: boolean;\n        throttleWaitMilliseconds?: number;\n        globalPlugins?: readonly string[];\n        pluginProbeLocations?: readonly string[];\n        allowLocalPluginLoads?: boolean;\n        typesMapLocation?: string;\n        syntaxOnly?: boolean;\n    }\n    export class ProjectService {\n        private readonly scriptInfoInNodeModulesWatchers;\n        /**\n         * Contains all the deleted script info\'s version information so that\n         * it does not reset when creating script info again\n         * (and could have potentially collided with version where contents mismatch)\n         */\n        private readonly filenameToScriptInfoVersion;\n        private readonly allJsFilesForOpenFileTelemetry;\n        /**\n         * maps external project file name to list of config files that were the part of this project\n         */\n        private readonly externalProjectToConfiguredProjectMap;\n        /**\n         * external projects (configuration and list of root files is not controlled by tsserver)\n         */\n        readonly externalProjects: ExternalProject[];\n        /**\n         * projects built from openFileRoots\n         */\n        readonly inferredProjects: InferredProject[];\n        /**\n         * projects specified by a tsconfig.json file\n         */\n        readonly configuredProjects: Map<ConfiguredProject>;\n        /**\n         * Open files: with value being project root path, and key being Path of the file that is open\n         */\n        readonly openFiles: Map<NormalizedPath | undefined>;\n        /**\n         * Map of open files that are opened without complete path but have projectRoot as current directory\n         */\n        private readonly openFilesWithNonRootedDiskPath;\n        private compilerOptionsForInferredProjects;\n        private compilerOptionsForInferredProjectsPerProjectRoot;\n        private watchOptionsForInferredProjects;\n        private watchOptionsForInferredProjectsPerProjectRoot;\n        /**\n         * Project size for configured or external projects\n         */\n        private readonly projectToSizeMap;\n        /**\n         * This is a map of config file paths existence that doesnt need query to disk\n         * - The entry can be present because there is inferred project that needs to watch addition of config file to directory\n         *   In this case the exists could be true/false based on config file is present or not\n         * - Or it is present if we have configured project open with config file at that location\n         *   In this case the exists property is always true\n         */\n        private readonly configFileExistenceInfoCache;\n        private readonly throttledOperations;\n        private readonly hostConfiguration;\n        private safelist;\n        private readonly legacySafelist;\n        private pendingProjectUpdates;\n        readonly currentDirectory: NormalizedPath;\n        readonly toCanonicalFileName: (f: string) => string;\n        readonly host: ServerHost;\n        readonly logger: Logger;\n        readonly cancellationToken: HostCancellationToken;\n        readonly useSingleInferredProject: boolean;\n        readonly useInferredProjectPerProjectRoot: boolean;\n        readonly typingsInstaller: ITypingsInstaller;\n        private readonly globalCacheLocationDirectoryPath;\n        readonly throttleWaitMilliseconds?: number;\n        private readonly eventHandler?;\n        private readonly suppressDiagnosticEvents?;\n        readonly globalPlugins: readonly string[];\n        readonly pluginProbeLocations: readonly string[];\n        readonly allowLocalPluginLoads: boolean;\n        private currentPluginConfigOverrides;\n        readonly typesMapLocation: string | undefined;\n        readonly syntaxOnly?: boolean;\n        /** Tracks projects that we have already sent telemetry for. */\n        private readonly seenProjects;\n        private performanceEventHandler?;\n        constructor(opts: ProjectServiceOptions);\n        toPath(fileName: string): Path;\n        private loadTypesMap;\n        updateTypingsForProject(response: SetTypings | InvalidateCachedTypings | PackageInstalledResponse): void;\n        private delayEnsureProjectForOpenFiles;\n        private delayUpdateProjectGraph;\n        private delayUpdateProjectGraphs;\n        setCompilerOptionsForInferredProjects(projectCompilerOptions: protocol.ExternalProjectCompilerOptions, projectRootPath?: string): void;\n        findProject(projectName: string): Project | undefined;\n        getDefaultProjectForFile(fileName: NormalizedPath, ensureProject: boolean): Project | undefined;\n        private doEnsureDefaultProjectForFile;\n        getScriptInfoEnsuringProjectsUptoDate(uncheckedFileName: string): ScriptInfo | undefined;\n        /**\n         * Ensures the project structures are upto date\n         * This means,\n         * - we go through all the projects and update them if they are dirty\n         * - if updates reflect some change in structure or there was pending request to ensure projects for open files\n         *   ensure that each open script info has project\n         */\n        private ensureProjectStructuresUptoDate;\n        getFormatCodeOptions(file: NormalizedPath): FormatCodeSettings;\n        getPreferences(file: NormalizedPath): protocol.UserPreferences;\n        getHostFormatCodeOptions(): FormatCodeSettings;\n        getHostPreferences(): protocol.UserPreferences;\n        private onSourceFileChanged;\n        private handleSourceMapProjects;\n        private delayUpdateSourceInfoProjects;\n        private delayUpdateProjectsOfScriptInfoPath;\n        private handleDeletedFile;\n        /**\n         * This is the callback function for the config file add/remove/change at any location\n         * that matters to open script info but doesnt have configured project open\n         * for the config file\n         */\n        private onConfigFileChangeForOpenScriptInfo;\n        private removeProject;\n        private assignOrphanScriptInfosToInferredProject;\n        /**\n         * Remove this file from the set of open, non-configured files.\n         * @param info The file that has been closed or newly configured\n         */\n        private closeOpenFile;\n        private deleteScriptInfo;\n        private configFileExists;\n        private setConfigFileExistenceByNewConfiguredProject;\n        /**\n         * Returns true if the configFileExistenceInfo is needed/impacted by open files that are root of inferred project\n         */\n        private configFileExistenceImpactsRootOfInferredProject;\n        private setConfigFileExistenceInfoByClosedConfiguredProject;\n        private logConfigFileWatchUpdate;\n        /**\n         * Create the watcher for the configFileExistenceInfo\n         */\n        private createConfigFileWatcherOfConfigFileExistence;\n        /**\n         * Close the config file watcher in the cached ConfigFileExistenceInfo\n         *   if there arent any open files that are root of inferred project\n         */\n        private closeConfigFileWatcherOfConfigFileExistenceInfo;\n        /**\n         * This is called on file close, so that we stop watching the config file for this script info\n         */\n        private stopWatchingConfigFilesForClosedScriptInfo;\n        /**\n         * This function tries to search for a tsconfig.json for the given file.\n         * This is different from the method the compiler uses because\n         * the compiler can assume it will always start searching in the\n         * current directory (the directory in which tsc was invoked).\n         * The server must start searching from the directory containing\n         * the newly opened file.\n         */\n        private forEachConfigFileLocation;\n        /**\n         * This function tries to search for a tsconfig.json for the given file.\n         * This is different from the method the compiler uses because\n         * the compiler can assume it will always start searching in the\n         * current directory (the directory in which tsc was invoked).\n         * The server must start searching from the directory containing\n         * the newly opened file.\n         * If script info is passed in, it is asserted to be open script info\n         * otherwise just file name\n         */\n        private getConfigFileNameForFile;\n        private printProjects;\n        private getConfiguredProjectByCanonicalConfigFilePath;\n        private findExternalProjectByProjectName;\n        /** Get a filename if the language service exceeds the maximum allowed program size; otherwise returns undefined. */\n        private getFilenameForExceededTotalSizeLimitForNonTsFiles;\n        private createExternalProject;\n        private addFilesToNonInferredProject;\n        private updateNonInferredProjectFiles;\n        private updateRootAndOptionsOfNonInferredProject;\n        private sendConfigFileDiagEvent;\n        private getOrCreateInferredProjectForProjectRootPathIfEnabled;\n        private getOrCreateSingleInferredProjectIfEnabled;\n        private getOrCreateSingleInferredWithoutProjectRoot;\n        private createInferredProject;\n        getScriptInfo(uncheckedFileName: string): ScriptInfo | undefined;\n        private watchClosedScriptInfo;\n        private watchClosedScriptInfoInNodeModules;\n        private getModifiedTime;\n        private refreshScriptInfo;\n        private refreshScriptInfosInDirectory;\n        private stopWatchingScriptInfo;\n        private getOrCreateScriptInfoNotOpenedByClientForNormalizedPath;\n        private getOrCreateScriptInfoOpenedByClientForNormalizedPath;\n        getOrCreateScriptInfoForNormalizedPath(fileName: NormalizedPath, openedByClient: boolean, fileContent?: string, scriptKind?: ScriptKind, hasMixedContent?: boolean, hostToQueryFileExistsOn?: {\n            fileExists(path: string): boolean;\n        }): ScriptInfo | undefined;\n        private getOrCreateScriptInfoWorker;\n        /**\n         * This gets the script info for the normalized path. If the path is not rooted disk path then the open script info with project root context is preferred\n         */\n        getScriptInfoForNormalizedPath(fileName: NormalizedPath): ScriptInfo | undefined;\n        getScriptInfoForPath(fileName: Path): ScriptInfo | undefined;\n        private addSourceInfoToSourceMap;\n        private addMissingSourceMapFile;\n        setHostConfiguration(args: protocol.ConfigureRequestArguments): void;\n        closeLog(): void;\n        /**\n         * This function rebuilds the project for every file opened by the client\n         * This does not reload contents of open files from disk. But we could do that if needed\n         */\n        reloadProjects(): void;\n        private delayReloadConfiguredProjectForFiles;\n        /**\n         * This function goes through all the openFiles and tries to file the config file for them.\n         * If the config file is found and it refers to existing project, it reloads it either immediately\n         * or schedules it for reload depending on delayReload option\n         * If the there is no existing project it just opens the configured project for the config file\n         * reloadForInfo provides a way to filter out files to reload configured project for\n         */\n        private reloadConfiguredProjectForFiles;\n        /**\n         * Remove the root of inferred project if script info is part of another project\n         */\n        private removeRootOfInferredProjectIfNowPartOfOtherProject;\n        /**\n         * This function is to update the project structure for every inferred project.\n         * It is called on the premise that all the configured projects are\n         * up to date.\n         * This will go through open files and assign them to inferred project if open file is not part of any other project\n         * After that all the inferred project graphs are updated\n         */\n        private ensureProjectForOpenFiles;\n        /**\n         * Open file whose contents is managed by the client\n         * @param filename is absolute pathname\n         * @param fileContent is a known version of the file content that is more up to date than the one on disk\n         */\n        openClientFile(fileName: string, fileContent?: string, scriptKind?: ScriptKind, projectRootPath?: string): OpenConfiguredProjectResult;\n        private findExternalProjectContainingOpenScriptInfo;\n        private getOrCreateOpenScriptInfo;\n        private assignProjectToOpenedScriptInfo;\n        private createAncestorProjects;\n        private ensureProjectChildren;\n        private cleanupAfterOpeningFile;\n        openClientFileWithNormalizedPath(fileName: NormalizedPath, fileContent?: string, scriptKind?: ScriptKind, hasMixedContent?: boolean, projectRootPath?: NormalizedPath): OpenConfiguredProjectResult;\n        private removeOrphanConfiguredProjects;\n        private removeOrphanScriptInfos;\n        private telemetryOnOpenFile;\n        /**\n         * Close file whose contents is managed by the client\n         * @param filename is absolute pathname\n         */\n        closeClientFile(uncheckedFileName: string): void;\n        private collectChanges;\n        private closeConfiguredProjectReferencedFromExternalProject;\n        closeExternalProject(uncheckedFileName: string): void;\n        openExternalProjects(projects: protocol.ExternalProject[]): void;\n        /** Makes a filename safe to insert in a RegExp */\n        private static readonly filenameEscapeRegexp;\n        private static escapeFilenameForRegex;\n        resetSafeList(): void;\n        applySafeList(proj: protocol.ExternalProject): NormalizedPath[];\n        openExternalProject(proj: protocol.ExternalProject): void;\n        hasDeferredExtension(): boolean;\n        configurePlugin(args: protocol.ConfigurePluginRequestArguments): void;\n    }\n    export {};\n}\ndeclare namespace ts.server {\n    interface ServerCancellationToken extends HostCancellationToken {\n        setRequest(requestId: number): void;\n        resetRequest(requestId: number): void;\n    }\n    const nullCancellationToken: ServerCancellationToken;\n    interface PendingErrorCheck {\n        fileName: NormalizedPath;\n        project: Project;\n    }\n    type CommandNames = protocol.CommandTypes;\n    const CommandNames: any;\n    function formatMessage<T extends protocol.Message>(msg: T, logger: Logger, byteLength: (s: string, encoding: string) => number, newLine: string): string;\n    type Event = <T extends object>(body: T, eventName: string) => void;\n    interface EventSender {\n        event: Event;\n    }\n    interface SessionOptions {\n        host: ServerHost;\n        cancellationToken: ServerCancellationToken;\n        useSingleInferredProject: boolean;\n        useInferredProjectPerProjectRoot: boolean;\n        typingsInstaller: ITypingsInstaller;\n        byteLength: (buf: string, encoding?: string) => number;\n        hrtime: (start?: number[]) => number[];\n        logger: Logger;\n        /**\n         * If falsy, all events are suppressed.\n         */\n        canUseEvents: boolean;\n        eventHandler?: ProjectServiceEventHandler;\n        /** Has no effect if eventHandler is also specified. */\n        suppressDiagnosticEvents?: boolean;\n        syntaxOnly?: boolean;\n        throttleWaitMilliseconds?: number;\n        noGetErrOnBackgroundUpdate?: boolean;\n        globalPlugins?: readonly string[];\n        pluginProbeLocations?: readonly string[];\n        allowLocalPluginLoads?: boolean;\n        typesMapLocation?: string;\n    }\n    class Session implements EventSender {\n        private readonly gcTimer;\n        protected projectService: ProjectService;\n        private changeSeq;\n        private updateGraphDurationMs;\n        private currentRequestId;\n        private errorCheck;\n        protected host: ServerHost;\n        private readonly cancellationToken;\n        protected readonly typingsInstaller: ITypingsInstaller;\n        protected byteLength: (buf: string, encoding?: string) => number;\n        private hrtime;\n        protected logger: Logger;\n        protected canUseEvents: boolean;\n        private suppressDiagnosticEvents?;\n        private eventHandler;\n        private readonly noGetErrOnBackgroundUpdate?;\n        constructor(opts: SessionOptions);\n        private sendRequestCompletedEvent;\n        private performanceEventHandler;\n        private defaultEventHandler;\n        private projectsUpdatedInBackgroundEvent;\n        logError(err: Error, cmd: string): void;\n        private logErrorWorker;\n        send(msg: protocol.Message): void;\n        event<T extends object>(body: T, eventName: string): void;\n        /** @deprecated */\n        output(info: any, cmdName: string, reqSeq?: number, errorMsg?: string): void;\n        private doOutput;\n        private semanticCheck;\n        private syntacticCheck;\n        private suggestionCheck;\n        private sendDiagnosticsEvent;\n        /** It is the caller\'s responsibility to verify that `!this.suppressDiagnosticEvents`. */\n        private updateErrorCheck;\n        private cleanProjects;\n        private cleanup;\n        private getEncodedSyntacticClassifications;\n        private getEncodedSemanticClassifications;\n        private getProject;\n        private getConfigFileAndProject;\n        private getConfigFileDiagnostics;\n        private convertToDiagnosticsWithLinePositionFromDiagnosticFile;\n        private getCompilerOptionsDiagnostics;\n        private convertToDiagnosticsWithLinePosition;\n        private getDiagnosticsWorker;\n        private getDefinition;\n        private mapDefinitionInfoLocations;\n        private getDefinitionAndBoundSpan;\n        private getEmitOutput;\n        private mapDefinitionInfo;\n        private static mapToOriginalLocation;\n        private toFileSpan;\n        private toFileSpanWithContext;\n        private getTypeDefinition;\n        private mapImplementationLocations;\n        private getImplementation;\n        private getOccurrences;\n        private getSyntacticDiagnosticsSync;\n        private getSemanticDiagnosticsSync;\n        private getSuggestionDiagnosticsSync;\n        private getJsxClosingTag;\n        private getDocumentHighlights;\n        private setCompilerOptionsForInferredProjects;\n        private getProjectInfo;\n        private getProjectInfoWorker;\n        private getRenameInfo;\n        private getProjects;\n        private getDefaultProject;\n        private getRenameLocations;\n        private mapRenameInfo;\n        private toSpanGroups;\n        private getReferences;\n        /**\n         * @param fileName is the name of the file to be opened\n         * @param fileContent is a version of the file content that is known to be more up to date than the one on disk\n         */\n        private openClientFile;\n        private getPosition;\n        private getPositionInFile;\n        private getFileAndProject;\n        private getFileAndLanguageServiceForSyntacticOperation;\n        private getFileAndProjectWorker;\n        private getOutliningSpans;\n        private getTodoComments;\n        private getDocCommentTemplate;\n        private getSpanOfEnclosingComment;\n        private getIndentation;\n        private getBreakpointStatement;\n        private getNameOrDottedNameSpan;\n        private isValidBraceCompletion;\n        private getQuickInfoWorker;\n        private getFormattingEditsForRange;\n        private getFormattingEditsForRangeFull;\n        private getFormattingEditsForDocumentFull;\n        private getFormattingEditsAfterKeystrokeFull;\n        private getFormattingEditsAfterKeystroke;\n        private getCompletions;\n        private getCompletionEntryDetails;\n        private getCompileOnSaveAffectedFileList;\n        private emitFile;\n        private getSignatureHelpItems;\n        private toPendingErrorCheck;\n        private getDiagnostics;\n        private change;\n        private reload;\n        private saveToTmp;\n        private closeClientFile;\n        private mapLocationNavigationBarItems;\n        private getNavigationBarItems;\n        private toLocationNavigationTree;\n        private getNavigationTree;\n        private getNavigateToItems;\n        private getFullNavigateToItems;\n        private getSupportedCodeFixes;\n        private isLocation;\n        private extractPositionOrRange;\n        private getApplicableRefactors;\n        private getEditsForRefactor;\n        private organizeImports;\n        private getEditsForFileRename;\n        private getCodeFixes;\n        private getCombinedCodeFix;\n        private applyCodeActionCommand;\n        private getStartAndEndPosition;\n        private mapCodeAction;\n        private mapCodeFixAction;\n        private mapTextChangesToCodeEdits;\n        private mapTextChangeToCodeEdit;\n        private convertTextChangeToCodeEdit;\n        private getBraceMatching;\n        private getDiagnosticsForProject;\n        private configurePlugin;\n        private getSmartSelectionRange;\n        private mapSelectionRange;\n        private getScriptInfoFromProjectService;\n        private toProtocolCallHierarchyItem;\n        private toProtocolCallHierarchyIncomingCall;\n        private toProtocolCallHierarchyOutgoingCall;\n        private prepareCallHierarchy;\n        private provideCallHierarchyIncomingCalls;\n        private provideCallHierarchyOutgoingCalls;\n        getCanonicalFileName(fileName: string): string;\n        exit(): void;\n        private notRequired;\n        private requiredResponse;\n        private handlers;\n        addProtocolHandler(command: string, handler: (request: protocol.Request) => HandlerResponse): void;\n        private setCurrentRequest;\n        private resetCurrentRequest;\n        executeWithRequestId<T>(requestId: number, f: () => T): T;\n        executeCommand(request: protocol.Request): HandlerResponse;\n        onMessage(message: string): void;\n        private getFormatOptions;\n        private getPreferences;\n        private getHostFormatOptions;\n        private getHostPreferences;\n    }\n    interface HandlerResponse {\n        response?: {};\n        responseRequired?: boolean;\n    }\n}\n\nexport = ts;\nexport as namespace ts;'}});